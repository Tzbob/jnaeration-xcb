package xcb;
import com.sun.jna.Library;
import com.sun.jna.Native;
import com.sun.jna.NativeLibrary;
import com.sun.jna.Pointer;
import com.sun.jna.PointerType;
import com.sun.jna.ptr.IntByReference;
import com.sun.jna.ptr.PointerByReference;
import java.nio.ByteBuffer;
import java.nio.IntBuffer;
import xcb.xcb_generic_error_t.ByReference;
/**
 * JNA Wrapper for library <b>xcb</b><br>
 * This file was autogenerated by <a href="http://jnaerator.googlecode.com/">JNAerator</a>,<br>
 * a tool written by <a href="http://ochafik.com/">Olivier Chafik</a> that <a href="http://code.google.com/p/jnaerator/wiki/CreditsAndLicense">uses a few opensource projects.</a>.<br>
 * For help, please visit <a href="http://nativelibs4java.googlecode.com/">NativeLibs4Java</a> , <a href="http://rococoa.dev.java.net/">Rococoa</a>, or <a href="http://jna.dev.java.net/">JNA</a>.
 */
public interface XcbLibrary extends Library {
	public static final String JNA_LIBRARY_NAME = "xcb";
	public static final NativeLibrary JNA_NATIVE_LIB = NativeLibrary.getInstance(XcbLibrary.JNA_LIBRARY_NAME);
	public static final XcbLibrary INSTANCE = (XcbLibrary)Native.loadLibrary(XcbLibrary.JNA_LIBRARY_NAME, XcbLibrary.class);
	/**
	 * <i>native declaration : xcb/xproto.h:169</i><br>
	 * enum values
	 */
	public static interface xcb_visual_class_t {
		/** <i>native declaration : xcb/xproto.h:163</i> */
		public static final int XCB_VISUAL_CLASS_STATIC_GRAY = 0;
		/** <i>native declaration : xcb/xproto.h:164</i> */
		public static final int XCB_VISUAL_CLASS_GRAY_SCALE = 1;
		/** <i>native declaration : xcb/xproto.h:165</i> */
		public static final int XCB_VISUAL_CLASS_STATIC_COLOR = 2;
		/** <i>native declaration : xcb/xproto.h:166</i> */
		public static final int XCB_VISUAL_CLASS_PSEUDO_COLOR = 3;
		/** <i>native declaration : xcb/xproto.h:167</i> */
		public static final int XCB_VISUAL_CLASS_TRUE_COLOR = 4;
		/** <i>native declaration : xcb/xproto.h:168</i> */
		public static final int XCB_VISUAL_CLASS_DIRECT_COLOR = 5;
	};
	/**
	 * <i>native declaration : xcb/xproto.h:227</i><br>
	 * enum values
	 */
	public static interface xcb_event_mask_t {
		/** <i>native declaration : xcb/xproto.h:201</i> */
		public static final int XCB_EVENT_MASK_NO_EVENT = 0;
		/** <i>native declaration : xcb/xproto.h:202</i> */
		public static final int XCB_EVENT_MASK_KEY_PRESS = 1;
		/** <i>native declaration : xcb/xproto.h:203</i> */
		public static final int XCB_EVENT_MASK_KEY_RELEASE = 2;
		/** <i>native declaration : xcb/xproto.h:204</i> */
		public static final int XCB_EVENT_MASK_BUTTON_PRESS = 4;
		/** <i>native declaration : xcb/xproto.h:205</i> */
		public static final int XCB_EVENT_MASK_BUTTON_RELEASE = 8;
		/** <i>native declaration : xcb/xproto.h:206</i> */
		public static final int XCB_EVENT_MASK_ENTER_WINDOW = 16;
		/** <i>native declaration : xcb/xproto.h:207</i> */
		public static final int XCB_EVENT_MASK_LEAVE_WINDOW = 32;
		/** <i>native declaration : xcb/xproto.h:208</i> */
		public static final int XCB_EVENT_MASK_POINTER_MOTION = 64;
		/** <i>native declaration : xcb/xproto.h:209</i> */
		public static final int XCB_EVENT_MASK_POINTER_MOTION_HINT = 128;
		/** <i>native declaration : xcb/xproto.h:210</i> */
		public static final int XCB_EVENT_MASK_BUTTON_1_MOTION = 256;
		/** <i>native declaration : xcb/xproto.h:211</i> */
		public static final int XCB_EVENT_MASK_BUTTON_2_MOTION = 512;
		/** <i>native declaration : xcb/xproto.h:212</i> */
		public static final int XCB_EVENT_MASK_BUTTON_3_MOTION = 1024;
		/** <i>native declaration : xcb/xproto.h:213</i> */
		public static final int XCB_EVENT_MASK_BUTTON_4_MOTION = 2048;
		/** <i>native declaration : xcb/xproto.h:214</i> */
		public static final int XCB_EVENT_MASK_BUTTON_5_MOTION = 4096;
		/** <i>native declaration : xcb/xproto.h:215</i> */
		public static final int XCB_EVENT_MASK_BUTTON_MOTION = 8192;
		/** <i>native declaration : xcb/xproto.h:216</i> */
		public static final int XCB_EVENT_MASK_KEYMAP_STATE = 16384;
		/** <i>native declaration : xcb/xproto.h:217</i> */
		public static final int XCB_EVENT_MASK_EXPOSURE = 32768;
		/** <i>native declaration : xcb/xproto.h:218</i> */
		public static final int XCB_EVENT_MASK_VISIBILITY_CHANGE = 65536;
		/** <i>native declaration : xcb/xproto.h:219</i> */
		public static final int XCB_EVENT_MASK_STRUCTURE_NOTIFY = 131072;
		/** <i>native declaration : xcb/xproto.h:220</i> */
		public static final int XCB_EVENT_MASK_RESIZE_REDIRECT = 262144;
		/** <i>native declaration : xcb/xproto.h:221</i> */
		public static final int XCB_EVENT_MASK_SUBSTRUCTURE_NOTIFY = 524288;
		/** <i>native declaration : xcb/xproto.h:222</i> */
		public static final int XCB_EVENT_MASK_SUBSTRUCTURE_REDIRECT = 1048576;
		/** <i>native declaration : xcb/xproto.h:223</i> */
		public static final int XCB_EVENT_MASK_FOCUS_CHANGE = 2097152;
		/** <i>native declaration : xcb/xproto.h:224</i> */
		public static final int XCB_EVENT_MASK_PROPERTY_CHANGE = 4194304;
		/** <i>native declaration : xcb/xproto.h:225</i> */
		public static final int XCB_EVENT_MASK_COLOR_MAP_CHANGE = 8388608;
		/** <i>native declaration : xcb/xproto.h:226</i> */
		public static final int XCB_EVENT_MASK_OWNER_GRAB_BUTTON = 16777216;
	};
	/**
	 * <i>native declaration : xcb/xproto.h:232</i><br>
	 * enum values
	 */
	public static interface xcb_backing_store_t {
		/** <i>native declaration : xcb/xproto.h:229</i> */
		public static final int XCB_BACKING_STORE_NOT_USEFUL = 0;
		/** <i>native declaration : xcb/xproto.h:230</i> */
		public static final int XCB_BACKING_STORE_WHEN_MAPPED = 1;
		/** <i>native declaration : xcb/xproto.h:231</i> */
		public static final int XCB_BACKING_STORE_ALWAYS = 2;
	};
	/**
	 * <i>native declaration : xcb/xproto.h:303</i><br>
	 * enum values
	 */
	public static interface xcb_image_order_t {
		/** <i>native declaration : xcb/xproto.h:301</i> */
		public static final int XCB_IMAGE_ORDER_LSB_FIRST = 0;
		/** <i>native declaration : xcb/xproto.h:302</i> */
		public static final int XCB_IMAGE_ORDER_MSB_FIRST = 1;
	};
	/**
	 * <i>native declaration : xcb/xproto.h:343</i><br>
	 * enum values
	 */
	public static interface xcb_mod_mask_t {
		/** <i>native declaration : xcb/xproto.h:334</i> */
		public static final int XCB_MOD_MASK_SHIFT = 1;
		/** <i>native declaration : xcb/xproto.h:335</i> */
		public static final int XCB_MOD_MASK_LOCK = 2;
		/** <i>native declaration : xcb/xproto.h:336</i> */
		public static final int XCB_MOD_MASK_CONTROL = 4;
		/** <i>native declaration : xcb/xproto.h:337</i> */
		public static final int XCB_MOD_MASK_1 = 8;
		/** <i>native declaration : xcb/xproto.h:338</i> */
		public static final int XCB_MOD_MASK_2 = 16;
		/** <i>native declaration : xcb/xproto.h:339</i> */
		public static final int XCB_MOD_MASK_3 = 32;
		/** <i>native declaration : xcb/xproto.h:340</i> */
		public static final int XCB_MOD_MASK_4 = 64;
		/** <i>native declaration : xcb/xproto.h:341</i> */
		public static final int XCB_MOD_MASK_5 = 128;
		/** <i>native declaration : xcb/xproto.h:342</i> */
		public static final int XCB_MOD_MASK_ANY = 32768;
	};
	/**
	 * <i>native declaration : xcb/xproto.h:358</i><br>
	 * enum values
	 */
	public static interface xcb_key_but_mask_t {
		/** <i>native declaration : xcb/xproto.h:345</i> */
		public static final int XCB_KEY_BUT_MASK_SHIFT = 1;
		/** <i>native declaration : xcb/xproto.h:346</i> */
		public static final int XCB_KEY_BUT_MASK_LOCK = 2;
		/** <i>native declaration : xcb/xproto.h:347</i> */
		public static final int XCB_KEY_BUT_MASK_CONTROL = 4;
		/** <i>native declaration : xcb/xproto.h:348</i> */
		public static final int XCB_KEY_BUT_MASK_MOD_1 = 8;
		/** <i>native declaration : xcb/xproto.h:349</i> */
		public static final int XCB_KEY_BUT_MASK_MOD_2 = 16;
		/** <i>native declaration : xcb/xproto.h:350</i> */
		public static final int XCB_KEY_BUT_MASK_MOD_3 = 32;
		/** <i>native declaration : xcb/xproto.h:351</i> */
		public static final int XCB_KEY_BUT_MASK_MOD_4 = 64;
		/** <i>native declaration : xcb/xproto.h:352</i> */
		public static final int XCB_KEY_BUT_MASK_MOD_5 = 128;
		/** <i>native declaration : xcb/xproto.h:353</i> */
		public static final int XCB_KEY_BUT_MASK_BUTTON_1 = 256;
		/** <i>native declaration : xcb/xproto.h:354</i> */
		public static final int XCB_KEY_BUT_MASK_BUTTON_2 = 512;
		/** <i>native declaration : xcb/xproto.h:355</i> */
		public static final int XCB_KEY_BUT_MASK_BUTTON_3 = 1024;
		/** <i>native declaration : xcb/xproto.h:356</i> */
		public static final int XCB_KEY_BUT_MASK_BUTTON_4 = 2048;
		/** <i>native declaration : xcb/xproto.h:357</i> */
		public static final int XCB_KEY_BUT_MASK_BUTTON_5 = 4096;
	};
	/**
	 * <i>native declaration : xcb/xproto.h:361</i><br>
	 * enum values
	 */
	public static interface xcb_window_enum_t {
		/** <i>native declaration : xcb/xproto.h:360</i> */
		public static final int XCB_WINDOW_NONE = 0;
	};
	/**
	 * <i>native declaration : xcb/xproto.h:388</i><br>
	 * enum values
	 */
	public static interface xcb_button_mask_t {
		/** <i>native declaration : xcb/xproto.h:382</i> */
		public static final int XCB_BUTTON_MASK_1 = 256;
		/** <i>native declaration : xcb/xproto.h:383</i> */
		public static final int XCB_BUTTON_MASK_2 = 512;
		/** <i>native declaration : xcb/xproto.h:384</i> */
		public static final int XCB_BUTTON_MASK_3 = 1024;
		/** <i>native declaration : xcb/xproto.h:385</i> */
		public static final int XCB_BUTTON_MASK_4 = 2048;
		/** <i>native declaration : xcb/xproto.h:386</i> */
		public static final int XCB_BUTTON_MASK_5 = 4096;
		/** <i>native declaration : xcb/xproto.h:387</i> */
		public static final int XCB_BUTTON_MASK_ANY = 32768;
	};
	/**
	 * <i>native declaration : xcb/xproto.h:411</i><br>
	 * enum values
	 */
	public static interface xcb_motion_t {
		/** <i>native declaration : xcb/xproto.h:409</i> */
		public static final int XCB_MOTION_NORMAL = 0;
		/** <i>native declaration : xcb/xproto.h:410</i> */
		public static final int XCB_MOTION_HINT = 1;
	};
	/**
	 * <i>native declaration : xcb/xproto.h:438</i><br>
	 * enum values
	 */
	public static interface xcb_notify_detail_t {
		/** <i>native declaration : xcb/xproto.h:430</i> */
		public static final int XCB_NOTIFY_DETAIL_ANCESTOR = 0;
		/** <i>native declaration : xcb/xproto.h:431</i> */
		public static final int XCB_NOTIFY_DETAIL_VIRTUAL = 1;
		/** <i>native declaration : xcb/xproto.h:432</i> */
		public static final int XCB_NOTIFY_DETAIL_INFERIOR = 2;
		/** <i>native declaration : xcb/xproto.h:433</i> */
		public static final int XCB_NOTIFY_DETAIL_NONLINEAR = 3;
		/** <i>native declaration : xcb/xproto.h:434</i> */
		public static final int XCB_NOTIFY_DETAIL_NONLINEAR_VIRTUAL = 4;
		/** <i>native declaration : xcb/xproto.h:435</i> */
		public static final int XCB_NOTIFY_DETAIL_POINTER = 5;
		/** <i>native declaration : xcb/xproto.h:436</i> */
		public static final int XCB_NOTIFY_DETAIL_POINTER_ROOT = 6;
		/** <i>native declaration : xcb/xproto.h:437</i> */
		public static final int XCB_NOTIFY_DETAIL_NONE = 7;
	};
	/**
	 * <i>native declaration : xcb/xproto.h:444</i><br>
	 * enum values
	 */
	public static interface xcb_notify_mode_t {
		/** <i>native declaration : xcb/xproto.h:440</i> */
		public static final int XCB_NOTIFY_MODE_NORMAL = 0;
		/** <i>native declaration : xcb/xproto.h:441</i> */
		public static final int XCB_NOTIFY_MODE_GRAB = 1;
		/** <i>native declaration : xcb/xproto.h:442</i> */
		public static final int XCB_NOTIFY_MODE_UNGRAB = 2;
		/** <i>native declaration : xcb/xproto.h:443</i> */
		public static final int XCB_NOTIFY_MODE_WHILE_GRABBED = 3;
	};
	/**
	 * <i>native declaration : xcb/xproto.h:522</i><br>
	 * enum values
	 */
	public static interface xcb_visibility_t {
		/** <i>native declaration : xcb/xproto.h:519</i> */
		public static final int XCB_VISIBILITY_UNOBSCURED = 0;
		/** <i>native declaration : xcb/xproto.h:520</i> */
		public static final int XCB_VISIBILITY_PARTIALLY_OBSCURED = 1;
		/** <i>native declaration : xcb/xproto.h:521</i> */
		public static final int XCB_VISIBILITY_FULLY_OBSCURED = 2;
	};
	/**
	 * <i>native declaration : xcb/xproto.h:650</i><br>
	 * enum values
	 */
	public static interface xcb_place_t {
		/** <i>native declaration : xcb/xproto.h:647</i> */
		public static final int XCB_PLACE_ON_TOP = 0;
		/**
		 * < The window is now on top of all siblings.<br>
		 * <i>native declaration : xcb/xproto.h:649</i>
		 */
		public static final int XCB_PLACE_ON_BOTTOM = 1;
	};
	/**
	 * <i>native declaration : xcb/xproto.h:667</i><br>
	 * enum values
	 */
	public static interface xcb_property_t {
		/** <i>native declaration : xcb/xproto.h:665</i> */
		public static final int XCB_PROPERTY_NEW_VALUE = 0;
		/** <i>native declaration : xcb/xproto.h:666</i> */
		public static final int XCB_PROPERTY_DELETE = 1;
	};
	/**
	 * <i>native declaration : xcb/xproto.h:690</i><br>
	 * enum values
	 */
	public static interface xcb_time_t {
		/** <i>native declaration : xcb/xproto.h:689</i> */
		public static final int XCB_TIME_CURRENT_TIME = 0;
	};
	/**
	 * <i>native declaration : xcb/xproto.h:762</i><br>
	 * enum values
	 */
	public static interface xcb_atom_enum_t {
		/** <i>native declaration : xcb/xproto.h:692</i> */
		public static final int XCB_ATOM_NONE = 0;
		/** <i>native declaration : xcb/xproto.h:693</i> */
		public static final int XCB_ATOM_ANY = 0;
		/** <i>native declaration : xcb/xproto.h:694</i> */
		public static final int XCB_ATOM_PRIMARY = 1;
		/** <i>native declaration : xcb/xproto.h:695</i> */
		public static final int XCB_ATOM_SECONDARY = 2;
		/** <i>native declaration : xcb/xproto.h:696</i> */
		public static final int XCB_ATOM_ARC = 3;
		/** <i>native declaration : xcb/xproto.h:697</i> */
		public static final int XCB_ATOM_ATOM = 4;
		/** <i>native declaration : xcb/xproto.h:698</i> */
		public static final int XCB_ATOM_BITMAP = 5;
		/** <i>native declaration : xcb/xproto.h:699</i> */
		public static final int XCB_ATOM_CARDINAL = 6;
		/** <i>native declaration : xcb/xproto.h:700</i> */
		public static final int XCB_ATOM_COLORMAP = 7;
		/** <i>native declaration : xcb/xproto.h:701</i> */
		public static final int XCB_ATOM_CURSOR = 8;
		/** <i>native declaration : xcb/xproto.h:702</i> */
		public static final int XCB_ATOM_CUT_BUFFER0 = 9;
		/** <i>native declaration : xcb/xproto.h:703</i> */
		public static final int XCB_ATOM_CUT_BUFFER1 = 10;
		/** <i>native declaration : xcb/xproto.h:704</i> */
		public static final int XCB_ATOM_CUT_BUFFER2 = 11;
		/** <i>native declaration : xcb/xproto.h:705</i> */
		public static final int XCB_ATOM_CUT_BUFFER3 = 12;
		/** <i>native declaration : xcb/xproto.h:706</i> */
		public static final int XCB_ATOM_CUT_BUFFER4 = 13;
		/** <i>native declaration : xcb/xproto.h:707</i> */
		public static final int XCB_ATOM_CUT_BUFFER5 = 14;
		/** <i>native declaration : xcb/xproto.h:708</i> */
		public static final int XCB_ATOM_CUT_BUFFER6 = 15;
		/** <i>native declaration : xcb/xproto.h:709</i> */
		public static final int XCB_ATOM_CUT_BUFFER7 = 16;
		/** <i>native declaration : xcb/xproto.h:710</i> */
		public static final int XCB_ATOM_DRAWABLE = 17;
		/** <i>native declaration : xcb/xproto.h:711</i> */
		public static final int XCB_ATOM_FONT = 18;
		/** <i>native declaration : xcb/xproto.h:712</i> */
		public static final int XCB_ATOM_INTEGER = 19;
		/** <i>native declaration : xcb/xproto.h:713</i> */
		public static final int XCB_ATOM_PIXMAP = 20;
		/** <i>native declaration : xcb/xproto.h:714</i> */
		public static final int XCB_ATOM_POINT = 21;
		/** <i>native declaration : xcb/xproto.h:715</i> */
		public static final int XCB_ATOM_RECTANGLE = 22;
		/** <i>native declaration : xcb/xproto.h:716</i> */
		public static final int XCB_ATOM_RESOURCE_MANAGER = 23;
		/** <i>native declaration : xcb/xproto.h:717</i> */
		public static final int XCB_ATOM_RGB_COLOR_MAP = 24;
		/** <i>native declaration : xcb/xproto.h:718</i> */
		public static final int XCB_ATOM_RGB_BEST_MAP = 25;
		/** <i>native declaration : xcb/xproto.h:719</i> */
		public static final int XCB_ATOM_RGB_BLUE_MAP = 26;
		/** <i>native declaration : xcb/xproto.h:720</i> */
		public static final int XCB_ATOM_RGB_DEFAULT_MAP = 27;
		/** <i>native declaration : xcb/xproto.h:721</i> */
		public static final int XCB_ATOM_RGB_GRAY_MAP = 28;
		/** <i>native declaration : xcb/xproto.h:722</i> */
		public static final int XCB_ATOM_RGB_GREEN_MAP = 29;
		/** <i>native declaration : xcb/xproto.h:723</i> */
		public static final int XCB_ATOM_RGB_RED_MAP = 30;
		/** <i>native declaration : xcb/xproto.h:724</i> */
		public static final int XCB_ATOM_STRING = 31;
		/** <i>native declaration : xcb/xproto.h:725</i> */
		public static final int XCB_ATOM_VISUALID = 32;
		/** <i>native declaration : xcb/xproto.h:726</i> */
		public static final int XCB_ATOM_WINDOW = 33;
		/** <i>native declaration : xcb/xproto.h:727</i> */
		public static final int XCB_ATOM_WM_COMMAND = 34;
		/** <i>native declaration : xcb/xproto.h:728</i> */
		public static final int XCB_ATOM_WM_HINTS = 35;
		/** <i>native declaration : xcb/xproto.h:729</i> */
		public static final int XCB_ATOM_WM_CLIENT_MACHINE = 36;
		/** <i>native declaration : xcb/xproto.h:730</i> */
		public static final int XCB_ATOM_WM_ICON_NAME = 37;
		/** <i>native declaration : xcb/xproto.h:731</i> */
		public static final int XCB_ATOM_WM_ICON_SIZE = 38;
		/** <i>native declaration : xcb/xproto.h:732</i> */
		public static final int XCB_ATOM_WM_NAME = 39;
		/** <i>native declaration : xcb/xproto.h:733</i> */
		public static final int XCB_ATOM_WM_NORMAL_HINTS = 40;
		/** <i>native declaration : xcb/xproto.h:734</i> */
		public static final int XCB_ATOM_WM_SIZE_HINTS = 41;
		/** <i>native declaration : xcb/xproto.h:735</i> */
		public static final int XCB_ATOM_WM_ZOOM_HINTS = 42;
		/** <i>native declaration : xcb/xproto.h:736</i> */
		public static final int XCB_ATOM_MIN_SPACE = 43;
		/** <i>native declaration : xcb/xproto.h:737</i> */
		public static final int XCB_ATOM_NORM_SPACE = 44;
		/** <i>native declaration : xcb/xproto.h:738</i> */
		public static final int XCB_ATOM_MAX_SPACE = 45;
		/** <i>native declaration : xcb/xproto.h:739</i> */
		public static final int XCB_ATOM_END_SPACE = 46;
		/** <i>native declaration : xcb/xproto.h:740</i> */
		public static final int XCB_ATOM_SUPERSCRIPT_X = 47;
		/** <i>native declaration : xcb/xproto.h:741</i> */
		public static final int XCB_ATOM_SUPERSCRIPT_Y = 48;
		/** <i>native declaration : xcb/xproto.h:742</i> */
		public static final int XCB_ATOM_SUBSCRIPT_X = 49;
		/** <i>native declaration : xcb/xproto.h:743</i> */
		public static final int XCB_ATOM_SUBSCRIPT_Y = 50;
		/** <i>native declaration : xcb/xproto.h:744</i> */
		public static final int XCB_ATOM_UNDERLINE_POSITION = 51;
		/** <i>native declaration : xcb/xproto.h:745</i> */
		public static final int XCB_ATOM_UNDERLINE_THICKNESS = 52;
		/** <i>native declaration : xcb/xproto.h:746</i> */
		public static final int XCB_ATOM_STRIKEOUT_ASCENT = 53;
		/** <i>native declaration : xcb/xproto.h:747</i> */
		public static final int XCB_ATOM_STRIKEOUT_DESCENT = 54;
		/** <i>native declaration : xcb/xproto.h:748</i> */
		public static final int XCB_ATOM_ITALIC_ANGLE = 55;
		/** <i>native declaration : xcb/xproto.h:749</i> */
		public static final int XCB_ATOM_X_HEIGHT = 56;
		/** <i>native declaration : xcb/xproto.h:750</i> */
		public static final int XCB_ATOM_QUAD_WIDTH = 57;
		/** <i>native declaration : xcb/xproto.h:751</i> */
		public static final int XCB_ATOM_WEIGHT = 58;
		/** <i>native declaration : xcb/xproto.h:752</i> */
		public static final int XCB_ATOM_POINT_SIZE = 59;
		/** <i>native declaration : xcb/xproto.h:753</i> */
		public static final int XCB_ATOM_RESOLUTION = 60;
		/** <i>native declaration : xcb/xproto.h:754</i> */
		public static final int XCB_ATOM_COPYRIGHT = 61;
		/** <i>native declaration : xcb/xproto.h:755</i> */
		public static final int XCB_ATOM_NOTICE = 62;
		/** <i>native declaration : xcb/xproto.h:756</i> */
		public static final int XCB_ATOM_FONT_NAME = 63;
		/** <i>native declaration : xcb/xproto.h:757</i> */
		public static final int XCB_ATOM_FAMILY_NAME = 64;
		/** <i>native declaration : xcb/xproto.h:758</i> */
		public static final int XCB_ATOM_FULL_NAME = 65;
		/** <i>native declaration : xcb/xproto.h:759</i> */
		public static final int XCB_ATOM_CAP_HEIGHT = 66;
		/** <i>native declaration : xcb/xproto.h:760</i> */
		public static final int XCB_ATOM_WM_CLASS = 67;
		/** <i>native declaration : xcb/xproto.h:761</i> */
		public static final int XCB_ATOM_WM_TRANSIENT_FOR = 68;
	};
	/**
	 * <i>native declaration : xcb/xproto.h:790</i><br>
	 * enum values
	 */
	public static interface xcb_colormap_state_t {
		/** <i>native declaration : xcb/xproto.h:787</i> */
		public static final int XCB_COLORMAP_STATE_UNINSTALLED = 0;
		/**
		 * < The colormap was uninstalled.<br>
		 * <i>native declaration : xcb/xproto.h:789</i>
		 */
		public static final int XCB_COLORMAP_STATE_INSTALLED = 1;
	};
	/**
	 * <i>native declaration : xcb/xproto.h:793</i><br>
	 * enum values
	 */
	public static interface xcb_colormap_enum_t {
		/** <i>native declaration : xcb/xproto.h:792</i> */
		public static final int XCB_COLORMAP_NONE = 0;
	};
	/**
	 * <i>native declaration : xcb/xproto.h:830</i><br>
	 * enum values
	 */
	public static interface xcb_mapping_t {
		/** <i>native declaration : xcb/xproto.h:827</i> */
		public static final int XCB_MAPPING_MODIFIER = 0;
		/** <i>native declaration : xcb/xproto.h:828</i> */
		public static final int XCB_MAPPING_KEYBOARD = 1;
		/** <i>native declaration : xcb/xproto.h:829</i> */
		public static final int XCB_MAPPING_POINTER = 2;
	};
	/**
	 * <i>native declaration : xcb/xproto.h:905</i><br>
	 * enum values
	 */
	public static interface xcb_window_class_t {
		/** <i>native declaration : xcb/xproto.h:902</i> */
		public static final int XCB_WINDOW_CLASS_COPY_FROM_PARENT = 0;
		/** <i>native declaration : xcb/xproto.h:903</i> */
		public static final int XCB_WINDOW_CLASS_INPUT_OUTPUT = 1;
		/** <i>native declaration : xcb/xproto.h:904</i> */
		public static final int XCB_WINDOW_CLASS_INPUT_ONLY = 2;
	};
	/**
	 * <i>native declaration : xcb/xproto.h:1010</i><br>
	 * enum values
	 */
	public static interface xcb_cw_t {
		/** <i>native declaration : xcb/xproto.h:907</i> */
		public static final int XCB_CW_BACK_PIXMAP = 1;
		/**
		 * < Overrides the default background-pixmap. The background pixmap and window must<br>
		 * have the same root and same depth. Any size pixmap can be used, although some<br>
		 * sizes may be faster than others.<br>
		 * If `XCB_BACK_PIXMAP_NONE` is specified, the window has no defined background.<br>
		 * The server may fill the contents with the previous screen contents or with<br>
		 * contents of its own choosing.<br>
		 * If `XCB_BACK_PIXMAP_PARENT_RELATIVE` is specified, the parent's background is<br>
		 * used, but the window must have the same depth as the parent (or a Match error<br>
		 * results).   The parent's background is tracked, and the current version is<br>
		 * used each time the window background is required.<br>
		 * <i>native declaration : xcb/xproto.h:920</i>
		 */
		public static final int XCB_CW_BACK_PIXEL = 2;
		/**
		 * < Overrides `BackPixmap`. A pixmap of undefined size filled with the specified<br>
		 * background pixel is used for the background. Range-checking is not performed,<br>
		 * the background pixel is truncated to the appropriate number of bits.<br>
		 * <i>native declaration : xcb/xproto.h:926</i>
		 */
		public static final int XCB_CW_BORDER_PIXMAP = 4;
		/**
		 * < Overrides the default border-pixmap. The border pixmap and window must have the<br>
		 * same root and the same depth. Any size pixmap can be used, although some sizes<br>
		 * may be faster than others.<br>
		 * The special value `XCB_COPY_FROM_PARENT` means the parent's border pixmap is<br>
		 * copied (subsequent changes to the parent's border attribute do not affect the<br>
		 * child), but the window must have the same depth as the parent.<br>
		 * <i>native declaration : xcb/xproto.h:935</i>
		 */
		public static final int XCB_CW_BORDER_PIXEL = 8;
		/**
		 * < Overrides `BorderPixmap`. A pixmap of undefined size filled with the specified<br>
		 * border pixel is used for the border. Range checking is not performed on the<br>
		 * border-pixel value, it is truncated to the appropriate number of bits.<br>
		 * <i>native declaration : xcb/xproto.h:941</i>
		 */
		public static final int XCB_CW_BIT_GRAVITY = 16;
		/**
		 * < Defines which region of the window should be retained if the window is resized.<br>
		 * <i>native declaration : xcb/xproto.h:943</i>
		 */
		public static final int XCB_CW_WIN_GRAVITY = 32;
		/**
		 * < Defines how the window should be repositioned if the parent is resized (see<br>
		 * `ConfigureWindow`).<br>
		 * <i>native declaration : xcb/xproto.h:948</i>
		 */
		public static final int XCB_CW_BACKING_STORE = 64;
		/**
		 * < A backing-store of `WhenMapped` advises the server that maintaining contents of<br>
		 * obscured regions when the window is mapped would be beneficial. A backing-store<br>
		 * of `Always` advises the server that maintaining contents even when the window<br>
		 * is unmapped would be beneficial. In this case, the server may generate an<br>
		 * exposure event when the window is created. A value of `NotUseful` advises the<br>
		 * server that maintaining contents is unnecessary, although a server may still<br>
		 * choose to maintain contents while the window is mapped. Note that if the server<br>
		 * maintains contents, then the server should maintain complete contents not just<br>
		 * the region within the parent boundaries, even if the window is larger than its<br>
		 * parent. While the server maintains contents, exposure events will not normally<br>
		 * be generated, but the server may stop maintaining contents at any time.<br>
		 * <i>native declaration : xcb/xproto.h:962</i>
		 */
		public static final int XCB_CW_BACKING_PLANES = 128;
		/**
		 * < The backing-planes indicates (with bits set to 1) which bit planes of the<br>
		 * window hold dynamic data that must be preserved in backing-stores and during<br>
		 * save-unders.<br>
		 * <i>native declaration : xcb/xproto.h:968</i>
		 */
		public static final int XCB_CW_BACKING_PIXEL = 256;
		/**
		 * < The backing-pixel specifies what value to use in planes not covered by<br>
		 * backing-planes. The server is free to save only the specified bit planes in the<br>
		 * backing-store or save-under and regenerate the remaining planes with the<br>
		 * specified pixel value. Any bits beyond the specified depth of the window in<br>
		 * these values are simply ignored.<br>
		 * <i>native declaration : xcb/xproto.h:976</i>
		 */
		public static final int XCB_CW_OVERRIDE_REDIRECT = 512;
		/**
		 * < The override-redirect specifies whether map and configure requests on this<br>
		 * window should override a SubstructureRedirect on the parent, typically to<br>
		 * inform a window manager not to tamper with the window.<br>
		 * <i>native declaration : xcb/xproto.h:982</i>
		 */
		public static final int XCB_CW_SAVE_UNDER = 1024;
		/**
		 * < If 1, the server is advised that when this window is mapped, saving the<br>
		 * contents of windows it obscures would be beneficial.<br>
		 * <i>native declaration : xcb/xproto.h:987</i>
		 */
		public static final int XCB_CW_EVENT_MASK = 2048;
		/**
		 * < The event-mask defines which events the client is interested in for this window<br>
		 * (or for some event types, inferiors of the window).<br>
		 * <i>native declaration : xcb/xproto.h:992</i>
		 */
		public static final int XCB_CW_DONT_PROPAGATE = 4096;
		/**
		 * < The do-not-propagate-mask defines which events should not be propagated to<br>
		 * ancestor windows when no client has the event type selected in this window.<br>
		 * <i>native declaration : xcb/xproto.h:997</i>
		 */
		public static final int XCB_CW_COLORMAP = 8192;
		/**
		 * < The colormap specifies the colormap that best reflects the true colors of the window. Servers<br>
		 * capable of supporting multiple hardware colormaps may use this information, and window man-<br>
		 * agers may use it for InstallColormap requests. The colormap must have the same visual type<br>
		 * and root as the window (or a Match error results). If CopyFromParent is specified, the parent's<br>
		 * colormap is copied (subsequent changes to the parent's colormap attribute do not affect the child).<br>
		 * However, the window must have the same visual type as the parent (or a Match error results),<br>
		 * and the parent must not have a colormap of None (or a Match error results). For an explanation<br>
		 * of None, see FreeColormap request. The colormap is copied by sharing the colormap object<br>
		 * between the child and the parent, not by making a complete copy of the colormap contents.<br>
		 * <i>native declaration : xcb/xproto.h:1009</i>
		 */
		public static final int XCB_CW_CURSOR = 16384;
	};
	/**
	 * <i>native declaration : xcb/xproto.h:1014</i><br>
	 * enum values
	 */
	public static interface xcb_back_pixmap_t {
		/** <i>native declaration : xcb/xproto.h:1012</i> */
		public static final int XCB_BACK_PIXMAP_NONE = 0;
		/** <i>native declaration : xcb/xproto.h:1013</i> */
		public static final int XCB_BACK_PIXMAP_PARENT_RELATIVE = 1;
	};
	/**
	 * <i>native declaration : xcb/xproto.h:1028</i><br>
	 * enum values
	 */
	public static interface xcb_gravity_t {
		/** <i>native declaration : xcb/xproto.h:1016</i> */
		public static final int XCB_GRAVITY_BIT_FORGET = 0;
		/** <i>native declaration : xcb/xproto.h:1017</i> */
		public static final int XCB_GRAVITY_WIN_UNMAP = 0;
		/** <i>native declaration : xcb/xproto.h:1018</i> */
		public static final int XCB_GRAVITY_NORTH_WEST = 1;
		/** <i>native declaration : xcb/xproto.h:1019</i> */
		public static final int XCB_GRAVITY_NORTH = 2;
		/** <i>native declaration : xcb/xproto.h:1020</i> */
		public static final int XCB_GRAVITY_NORTH_EAST = 3;
		/** <i>native declaration : xcb/xproto.h:1021</i> */
		public static final int XCB_GRAVITY_WEST = 4;
		/** <i>native declaration : xcb/xproto.h:1022</i> */
		public static final int XCB_GRAVITY_CENTER = 5;
		/** <i>native declaration : xcb/xproto.h:1023</i> */
		public static final int XCB_GRAVITY_EAST = 6;
		/** <i>native declaration : xcb/xproto.h:1024</i> */
		public static final int XCB_GRAVITY_SOUTH_WEST = 7;
		/** <i>native declaration : xcb/xproto.h:1025</i> */
		public static final int XCB_GRAVITY_SOUTH = 8;
		/** <i>native declaration : xcb/xproto.h:1026</i> */
		public static final int XCB_GRAVITY_SOUTH_EAST = 9;
		/** <i>native declaration : xcb/xproto.h:1027</i> */
		public static final int XCB_GRAVITY_STATIC = 10;
	};
	/**
	 * <i>native declaration : xcb/xproto.h:1057</i><br>
	 * enum values
	 */
	public static interface xcb_map_state_t {
		/** <i>native declaration : xcb/xproto.h:1054</i> */
		public static final int XCB_MAP_STATE_UNMAPPED = 0;
		/** <i>native declaration : xcb/xproto.h:1055</i> */
		public static final int XCB_MAP_STATE_UNVIEWABLE = 1;
		/** <i>native declaration : xcb/xproto.h:1056</i> */
		public static final int XCB_MAP_STATE_VIEWABLE = 2;
	};
	/**
	 * <i>native declaration : xcb/xproto.h:1108</i><br>
	 * enum values
	 */
	public static interface xcb_set_mode_t {
		/** <i>native declaration : xcb/xproto.h:1106</i> */
		public static final int XCB_SET_MODE_INSERT = 0;
		/** <i>native declaration : xcb/xproto.h:1107</i> */
		public static final int XCB_SET_MODE_DELETE = 1;
	};
	/**
	 * <i>native declaration : xcb/xproto.h:1162</i><br>
	 * enum values
	 */
	public static interface xcb_config_window_t {
		/** <i>native declaration : xcb/xproto.h:1155</i> */
		public static final int XCB_CONFIG_WINDOW_X = 1;
		/** <i>native declaration : xcb/xproto.h:1156</i> */
		public static final int XCB_CONFIG_WINDOW_Y = 2;
		/** <i>native declaration : xcb/xproto.h:1157</i> */
		public static final int XCB_CONFIG_WINDOW_WIDTH = 4;
		/** <i>native declaration : xcb/xproto.h:1158</i> */
		public static final int XCB_CONFIG_WINDOW_HEIGHT = 8;
		/** <i>native declaration : xcb/xproto.h:1159</i> */
		public static final int XCB_CONFIG_WINDOW_BORDER_WIDTH = 16;
		/** <i>native declaration : xcb/xproto.h:1160</i> */
		public static final int XCB_CONFIG_WINDOW_SIBLING = 32;
		/** <i>native declaration : xcb/xproto.h:1161</i> */
		public static final int XCB_CONFIG_WINDOW_STACK_MODE = 64;
	};
	/**
	 * <i>native declaration : xcb/xproto.h:1169</i><br>
	 * enum values
	 */
	public static interface xcb_stack_mode_t {
		/** <i>native declaration : xcb/xproto.h:1164</i> */
		public static final int XCB_STACK_MODE_ABOVE = 0;
		/** <i>native declaration : xcb/xproto.h:1165</i> */
		public static final int XCB_STACK_MODE_BELOW = 1;
		/** <i>native declaration : xcb/xproto.h:1166</i> */
		public static final int XCB_STACK_MODE_TOP_IF = 2;
		/** <i>native declaration : xcb/xproto.h:1167</i> */
		public static final int XCB_STACK_MODE_BOTTOM_IF = 3;
		/** <i>native declaration : xcb/xproto.h:1168</i> */
		public static final int XCB_STACK_MODE_OPPOSITE = 4;
	};
	/**
	 * <i>native declaration : xcb/xproto.h:1182</i><br>
	 * enum values
	 */
	public static interface xcb_circulate_t {
		/** <i>native declaration : xcb/xproto.h:1180</i> */
		public static final int XCB_CIRCULATE_RAISE_LOWEST = 0;
		/** <i>native declaration : xcb/xproto.h:1181</i> */
		public static final int XCB_CIRCULATE_LOWER_HIGHEST = 1;
	};
	/**
	 * <i>native declaration : xcb/xproto.h:1287</i><br>
	 * enum values
	 */
	public static interface xcb_prop_mode_t {
		/** <i>native declaration : xcb/xproto.h:1278</i> */
		public static final int XCB_PROP_MODE_REPLACE = 0;
		/**
		 * < Discard the previous property value and store the new data.<br>
		 * <i>native declaration : xcb/xproto.h:1280</i>
		 */
		public static final int XCB_PROP_MODE_PREPEND = 1;
		/**
		 * < Insert the new data before the beginning of existing data. The `format` must<br>
		 * match existing property value. If the property is undefined, it is treated as<br>
		 * defined with the correct type and format with zero-length data.<br>
		 * <i>native declaration : xcb/xproto.h:1286</i>
		 */
		public static final int XCB_PROP_MODE_APPEND = 2;
	};
	/**
	 * <i>native declaration : xcb/xproto.h:1310</i><br>
	 * enum values
	 */
	public static interface xcb_get_property_type_t {
		/** <i>native declaration : xcb/xproto.h:1309</i> */
		public static final int XCB_GET_PROPERTY_TYPE_ANY = 0;
	};
	/**
	 * <i>native declaration : xcb/xproto.h:1399</i><br>
	 * enum values
	 */
	public static interface xcb_send_event_dest_t {
		/** <i>native declaration : xcb/xproto.h:1397</i> */
		public static final int XCB_SEND_EVENT_DEST_POINTER_WINDOW = 0;
		/** <i>native declaration : xcb/xproto.h:1398</i> */
		public static final int XCB_SEND_EVENT_DEST_ITEM_FOCUS = 1;
	};
	/**
	 * <i>native declaration : xcb/xproto.h:1417</i><br>
	 * enum values
	 */
	public static interface xcb_grab_mode_t {
		/** <i>native declaration : xcb/xproto.h:1410</i> */
		public static final int XCB_GRAB_MODE_SYNC = 0;
		/**
		 * < The state of the keyboard appears to freeze: No further keyboard events are<br>
		 * generated by the server until the grabbing client issues a releasing<br>
		 * `AllowEvents` request or until the keyboard grab is released.<br>
		 * <i>native declaration : xcb/xproto.h:1416</i>
		 */
		public static final int XCB_GRAB_MODE_ASYNC = 1;
	};
	/**
	 * <i>native declaration : xcb/xproto.h:1424</i><br>
	 * enum values
	 */
	public static interface xcb_grab_status_t {
		/** <i>native declaration : xcb/xproto.h:1419</i> */
		public static final int XCB_GRAB_STATUS_SUCCESS = 0;
		/** <i>native declaration : xcb/xproto.h:1420</i> */
		public static final int XCB_GRAB_STATUS_ALREADY_GRABBED = 1;
		/** <i>native declaration : xcb/xproto.h:1421</i> */
		public static final int XCB_GRAB_STATUS_INVALID_TIME = 2;
		/** <i>native declaration : xcb/xproto.h:1422</i> */
		public static final int XCB_GRAB_STATUS_NOT_VIEWABLE = 3;
		/** <i>native declaration : xcb/xproto.h:1423</i> */
		public static final int XCB_GRAB_STATUS_FROZEN = 4;
	};
	/**
	 * <i>native declaration : xcb/xproto.h:1427</i><br>
	 * enum values
	 */
	public static interface xcb_cursor_enum_t {
		/** <i>native declaration : xcb/xproto.h:1426</i> */
		public static final int XCB_CURSOR_NONE = 0;
	};
	/**
	 * <i>native declaration : xcb/xproto.h:1471</i><br>
	 * enum values
	 */
	public static interface xcb_button_index_t {
		/** <i>native declaration : xcb/xproto.h:1460</i> */
		public static final int XCB_BUTTON_INDEX_ANY = 0;
		/**
		 * < Any of the following (or none):<br>
		 * <i>native declaration : xcb/xproto.h:1462</i>
		 */
		public static final int XCB_BUTTON_INDEX_1 = 1;
		/**
		 * < The left mouse button.<br>
		 * <i>native declaration : xcb/xproto.h:1464</i>
		 */
		public static final int XCB_BUTTON_INDEX_2 = 2;
		/**
		 * < The right mouse button.<br>
		 * <i>native declaration : xcb/xproto.h:1466</i>
		 */
		public static final int XCB_BUTTON_INDEX_3 = 3;
		/**
		 * < The middle mouse button.<br>
		 * <i>native declaration : xcb/xproto.h:1468</i>
		 */
		public static final int XCB_BUTTON_INDEX_4 = 4;
		/**
		 * < Scroll wheel. TODO: direction?<br>
		 * <i>native declaration : xcb/xproto.h:1470</i>
		 */
		public static final int XCB_BUTTON_INDEX_5 = 5;
	};
	/**
	 * <i>native declaration : xcb/xproto.h:1537</i><br>
	 * enum values
	 */
	public static interface xcb_grab_t {
		/** <i>native declaration : xcb/xproto.h:1536</i> */
		public static final int XCB_GRAB_ANY = 0;
	};
	/**
	 * <i>native declaration : xcb/xproto.h:1627</i><br>
	 * enum values
	 */
	public static interface xcb_allow_t {
		/** <i>native declaration : xcb/xproto.h:1560</i> */
		public static final int XCB_ALLOW_ASYNC_POINTER = 0;
		/**
		 * < For AsyncPointer, if the pointer is frozen by the client, pointer event<br>
		 * processing continues normally. If the pointer is frozen twice by the client on<br>
		 * behalf of two separate grabs, AsyncPointer thaws for both. AsyncPointer has no<br>
		 * effect if the pointer is not frozen by the client, but the pointer need not be<br>
		 * grabbed by the client.<br>
		 * TODO: rewrite this in more understandable terms.<br>
		 * <i>native declaration : xcb/xproto.h:1569</i>
		 */
		public static final int XCB_ALLOW_SYNC_POINTER = 1;
		/**
		 * < For SyncPointer, if the pointer is frozen and actively grabbed by the client,<br>
		 * pointer event processing continues normally until the next ButtonPress or<br>
		 * ButtonRelease event is reported to the client, at which time the pointer again<br>
		 * appears to freeze. However, if the reported event causes the pointer grab to be<br>
		 * released, then the pointer does not freeze. SyncPointer has no effect if the<br>
		 * pointer is not frozen by the client or if the pointer is not grabbed by the<br>
		 * client.<br>
		 * <i>native declaration : xcb/xproto.h:1579</i>
		 */
		public static final int XCB_ALLOW_REPLAY_POINTER = 2;
		/**
		 * < For ReplayPointer, if the pointer is actively grabbed by the client and is<br>
		 * frozen as the result of an event having been sent to the client (either from<br>
		 * the activation of a GrabButton or from a previous AllowEvents with mode<br>
		 * SyncPointer but not from a GrabPointer), then the pointer grab is released and<br>
		 * that event is completely reprocessed, this time ignoring any passive grabs at<br>
		 * or above (towards the root) the grab-window of the grab just released. The<br>
		 * request has no effect if the pointer is not grabbed by the client or if the<br>
		 * pointer is not frozen as the result of an event.<br>
		 * <i>native declaration : xcb/xproto.h:1590</i>
		 */
		public static final int XCB_ALLOW_ASYNC_KEYBOARD = 3;
		/**
		 * < For AsyncKeyboard, if the keyboard is frozen by the client, keyboard event<br>
		 * processing continues normally. If the keyboard is frozen twice by the client on<br>
		 * behalf of two separate grabs, AsyncKeyboard thaws for both. AsyncKeyboard has<br>
		 * no effect if the keyboard is not frozen by the client, but the keyboard need<br>
		 * not be grabbed by the client.<br>
		 * <i>native declaration : xcb/xproto.h:1598</i>
		 */
		public static final int XCB_ALLOW_SYNC_KEYBOARD = 4;
		/**
		 * < For SyncKeyboard, if the keyboard is frozen and actively grabbed by the client,<br>
		 * keyboard event processing continues normally until the next KeyPress or<br>
		 * KeyRelease event is reported to the client, at which time the keyboard again<br>
		 * appears to freeze. However, if the reported event causes the keyboard grab to<br>
		 * be released, then the keyboard does not freeze. SyncKeyboard has no effect if<br>
		 * the keyboard is not frozen by the client or if the keyboard is not grabbed by<br>
		 * the client.<br>
		 * <i>native declaration : xcb/xproto.h:1608</i>
		 */
		public static final int XCB_ALLOW_REPLAY_KEYBOARD = 5;
		/**
		 * < For ReplayKeyboard, if the keyboard is actively grabbed by the client and is<br>
		 * frozen as the result of an event having been sent to the client (either from<br>
		 * the activation of a GrabKey or from a previous AllowEvents with mode<br>
		 * SyncKeyboard but not from a GrabKeyboard), then the keyboard grab is released<br>
		 * and that event is completely reprocessed, this time ignoring any passive grabs<br>
		 * at or above (towards the root) the grab-window of the grab just released. The<br>
		 * request has no effect if the keyboard is not grabbed by the client or if the<br>
		 * keyboard is not frozen as the result of an event.<br>
		 * <i>native declaration : xcb/xproto.h:1619</i>
		 */
		public static final int XCB_ALLOW_ASYNC_BOTH = 6;
		/**
		 * < For AsyncBoth, if the pointer and the keyboard are frozen by the client, event<br>
		 * processing for both devices continues normally. If a device is frozen twice by<br>
		 * the client on behalf of two separate grabs, AsyncBoth thaws for both. AsyncBoth<br>
		 * has no effect unless both pointer and keyboard are frozen by the client.<br>
		 * <i>native declaration : xcb/xproto.h:1626</i>
		 */
		public static final int XCB_ALLOW_SYNC_BOTH = 7;
	};
	/**
	 * <i>native declaration : xcb/xproto.h:1760</i><br>
	 * enum values
	 */
	public static interface xcb_input_focus_t {
		/** <i>native declaration : xcb/xproto.h:1746</i> */
		public static final int XCB_INPUT_FOCUS_NONE = 0;
		/**
		 * < The focus reverts to `XCB_NONE`, so no window will have the input focus.<br>
		 * <i>native declaration : xcb/xproto.h:1748</i>
		 */
		public static final int XCB_INPUT_FOCUS_POINTER_ROOT = 1;
		/**
		 * < The focus reverts to `XCB_POINTER_ROOT` respectively. When the focus reverts,<br>
		 * FocusIn and FocusOut events are generated, but the last-focus-change time is<br>
		 * not changed.<br>
		 * <i>native declaration : xcb/xproto.h:1754</i>
		 */
		public static final int XCB_INPUT_FOCUS_PARENT = 2;
		/**
		 * < The focus reverts to the parent (or closest viewable ancestor) and the new<br>
		 * revert_to value is `XCB_INPUT_FOCUS_NONE`.<br>
		 * <i>native declaration : xcb/xproto.h:1759</i>
		 */
		public static final int XCB_INPUT_FOCUS_FOLLOW_KEYBOARD = 3;
	};
	/**
	 * <i>native declaration : xcb/xproto.h:1824</i><br>
	 * enum values
	 */
	public static interface xcb_font_draw_t {
		/** <i>native declaration : xcb/xproto.h:1822</i> */
		public static final int XCB_FONT_DRAW_LEFT_TO_RIGHT = 0;
		/** <i>native declaration : xcb/xproto.h:1823</i> */
		public static final int XCB_FONT_DRAW_RIGHT_TO_LEFT = 1;
	};
	/**
	 * <i>native declaration : xcb/xproto.h:2161</i><br>
	 * enum values
	 */
	public static interface xcb_gc_t {
		/** <i>native declaration : xcb/xproto.h:2019</i> */
		public static final int XCB_GC_FUNCTION = 1;
		/**
		 * < TODO: Refer to GX<br>
		 * <i>native declaration : xcb/xproto.h:2021</i>
		 */
		public static final int XCB_GC_PLANE_MASK = 2;
		/**
		 * < In graphics operations, given a source and destination pixel, the result is<br>
		 * computed bitwise on corresponding bits of the pixels; that is, a Boolean<br>
		 * operation is performed in each bit plane. The plane-mask restricts the<br>
		 * operation to a subset of planes, so the result is:<br>
		 * ((src FUNC dst) AND plane-mask) OR (dst AND (NOT plane-mask))<br>
		 * <i>native declaration : xcb/xproto.h:2029</i>
		 */
		public static final int XCB_GC_FOREGROUND = 4;
		/**
		 * < Foreground colorpixel.<br>
		 * <i>native declaration : xcb/xproto.h:2031</i>
		 */
		public static final int XCB_GC_BACKGROUND = 8;
		/**
		 * < Background colorpixel.<br>
		 * <i>native declaration : xcb/xproto.h:2033</i>
		 */
		public static final int XCB_GC_LINE_WIDTH = 16;
		/**
		 * < The line-width is measured in pixels and can be greater than or equal to one, a wide line, or the<br>
		 * special value zero, a thin line.<br>
		 * <i>native declaration : xcb/xproto.h:2038</i>
		 */
		public static final int XCB_GC_LINE_STYLE = 32;
		/**
		 * < The line-style defines which sections of a line are drawn:<br>
		 * Solid                The full path of the line is drawn.<br>
		 * DoubleDash           The full path of the line is drawn, but the even dashes are filled differently<br>
		 * than the odd dashes (see fill-style), with Butt cap-style used where even and<br>
		 * odd dashes meet.<br>
		 * OnOffDash            Only the even dashes are drawn, and cap-style applies to all internal ends of<br>
		 * the individual dashes (except NotLast is treated as Butt).<br>
		 * <i>native declaration : xcb/xproto.h:2048</i>
		 */
		public static final int XCB_GC_CAP_STYLE = 64;
		/**
		 * < The cap-style defines how the endpoints of a path are drawn:<br>
		 * NotLast    The result is equivalent to Butt, except that for a line-width of zero the final<br>
		 * endpoint is not drawn.<br>
		 * Butt       The result is square at the endpoint (perpendicular to the slope of the line)<br>
		 * with no projection beyond.<br>
		 * Round      The result is a circular arc with its diameter equal to the line-width, centered<br>
		 * on the endpoint; it is equivalent to Butt for line-width zero.<br>
		 * Projecting The result is square at the end, but the path continues beyond the endpoint for<br>
		 * a distance equal to half the line-width; it is equivalent to Butt for line-width<br>
		 * zero.<br>
		 * <i>native declaration : xcb/xproto.h:2061</i>
		 */
		public static final int XCB_GC_JOIN_STYLE = 128;
		/**
		 * < The join-style defines how corners are drawn for wide lines:<br>
		 * Miter               The outer edges of the two lines extend to meet at an angle. However, if the<br>
		 * angle is less than 11 degrees, a Bevel join-style is used instead.<br>
		 * Round               The result is a circular arc with a diameter equal to the line-width, centered<br>
		 * on the joinpoint.<br>
		 * Bevel               The result is Butt endpoint styles, and then the triangular notch is filled.<br>
		 * <i>native declaration : xcb/xproto.h:2070</i>
		 */
		public static final int XCB_GC_FILL_STYLE = 256;
		/**
		 * < The fill-style defines the contents of the source for line, text, and fill requests. For all text and fill<br>
		 * requests (for example, PolyText8, PolyText16, PolyFillRectangle, FillPoly, and PolyFillArc)<br>
		 * as well as for line requests with line-style Solid, (for example, PolyLine, PolySegment,<br>
		 * PolyRectangle, PolyArc) and for the even dashes for line requests with line-style OnOffDash<br>
		 * or DoubleDash:<br>
		 * Solid                     Foreground<br>
		 * Tiled                     Tile<br>
		 * OpaqueStippled            A tile with the same width and height as stipple but with background<br>
		 * everywhere stipple has a zero and with foreground everywhere stipple<br>
		 * has a one<br>
		 * Stippled                  Foreground masked by stipple<br>
		 * For the odd dashes for line requests with line-style DoubleDash:<br>
		 * Solid                     Background<br>
		 * Tiled                     Same as for even dashes<br>
		 * OpaqueStippled            Same as for even dashes<br>
		 * Stippled                  Background masked by stipple<br>
		 * <i>native declaration : xcb/xproto.h:2089</i>
		 */
		public static final int XCB_GC_FILL_RULE = 512;
		/**
		 * <<br>
		 * <i>native declaration : xcb/xproto.h:2091</i>
		 */
		public static final int XCB_GC_TILE = 1024;
		/**
		 * < The tile/stipple represents an infinite two-dimensional plane with the tile/stipple replicated in all<br>
		 * dimensions. When that plane is superimposed on the drawable for use in a graphics operation,<br>
		 * the upper-left corner of some instance of the tile/stipple is at the coordinates within the drawable<br>
		 * specified by the tile/stipple origin. The tile/stipple and clip origins are interpreted relative to the<br>
		 * origin of whatever destination drawable is specified in a graphics request.<br>
		 * The tile pixmap must have the same root and depth as the gcontext (or a Match error results).<br>
		 * The stipple pixmap must have depth one and must have the same root as the gcontext (or a<br>
		 * Match error results). For fill-style Stippled (but not fill-style<br>
		 * OpaqueStippled), the stipple pattern is tiled in a single plane and acts as an<br>
		 * additional clip mask to be ANDed with the clip-mask.<br>
		 * Any size pixmap can be used for tiling or stippling, although some sizes may be faster to use than<br>
		 * others.<br>
		 * <i>native declaration : xcb/xproto.h:2106</i>
		 */
		public static final int XCB_GC_STIPPLE = 2048;
		/**
		 * < The tile/stipple represents an infinite two-dimensional plane with the tile/stipple replicated in all<br>
		 * dimensions. When that plane is superimposed on the drawable for use in a graphics operation,<br>
		 * the upper-left corner of some instance of the tile/stipple is at the coordinates within the drawable<br>
		 * specified by the tile/stipple origin. The tile/stipple and clip origins are interpreted relative to the<br>
		 * origin of whatever destination drawable is specified in a graphics request.<br>
		 * The tile pixmap must have the same root and depth as the gcontext (or a Match error results).<br>
		 * The stipple pixmap must have depth one and must have the same root as the gcontext (or a<br>
		 * Match error results). For fill-style Stippled (but not fill-style<br>
		 * OpaqueStippled), the stipple pattern is tiled in a single plane and acts as an<br>
		 * additional clip mask to be ANDed with the clip-mask.<br>
		 * Any size pixmap can be used for tiling or stippling, although some sizes may be faster to use than<br>
		 * others.<br>
		 * <i>native declaration : xcb/xproto.h:2121</i>
		 */
		public static final int XCB_GC_TILE_STIPPLE_ORIGIN_X = 4096;
		/**
		 * < TODO<br>
		 * <i>native declaration : xcb/xproto.h:2123</i>
		 */
		public static final int XCB_GC_TILE_STIPPLE_ORIGIN_Y = 8192;
		/**
		 * < TODO<br>
		 * <i>native declaration : xcb/xproto.h:2125</i>
		 */
		public static final int XCB_GC_FONT = 16384;
		/**
		 * < Which font to use for the `ImageText8` and `ImageText16` requests.<br>
		 * <i>native declaration : xcb/xproto.h:2127</i>
		 */
		public static final int XCB_GC_SUBWINDOW_MODE = 32768;
		/**
		 * < For ClipByChildren, both source and destination windows are additionally<br>
		 * clipped by all viewable InputOutput children. For IncludeInferiors, neither<br>
		 * source nor destination window is<br>
		 * clipped by inferiors. This will result in including subwindow contents in the source and drawing<br>
		 * through subwindow boundaries of the destination. The use of IncludeInferiors with a source or<br>
		 * destination window of one depth with mapped inferiors of differing depth is not illegal, but the<br>
		 * semantics is undefined by the core protocol.<br>
		 * <i>native declaration : xcb/xproto.h:2137</i>
		 */
		public static final int XCB_GC_GRAPHICS_EXPOSURES = 65536;
		/**
		 * < Whether ExposureEvents should be generated (1) or not (0).<br>
		 * The default is 1.<br>
		 * <i>native declaration : xcb/xproto.h:2142</i>
		 */
		public static final int XCB_GC_CLIP_ORIGIN_X = 131072;
		/**
		 * < TODO<br>
		 * <i>native declaration : xcb/xproto.h:2144</i>
		 */
		public static final int XCB_GC_CLIP_ORIGIN_Y = 262144;
		/**
		 * < TODO<br>
		 * <i>native declaration : xcb/xproto.h:2146</i>
		 */
		public static final int XCB_GC_CLIP_MASK = 524288;
		/**
		 * < The clip-mask restricts writes to the destination drawable. Only pixels where the clip-mask has<br>
		 * bits set to 1 are drawn. Pixels are not drawn outside the area covered by the clip-mask or where<br>
		 * the clip-mask has bits set to 0. The clip-mask affects all graphics requests, but it does not clip<br>
		 * sources. The clip-mask origin is interpreted relative to the origin of whatever destination drawable is specified in a graphics request. If a pixmap is specified as the clip-mask, it must have<br>
		 * depth 1 and have the same root as the gcontext (or a Match error results). If clip-mask is None,<br>
		 * then pixels are always drawn, regardless of the clip origin. The clip-mask can also be set with the<br>
		 * SetClipRectangles request.<br>
		 * <i>native declaration : xcb/xproto.h:2156</i>
		 */
		public static final int XCB_GC_DASH_OFFSET = 1048576;
		/**
		 * < TODO<br>
		 * <i>native declaration : xcb/xproto.h:2158</i>
		 */
		public static final int XCB_GC_DASH_LIST = 2097152;
		/**
		 * < TODO<br>
		 * <i>native declaration : xcb/xproto.h:2160</i>
		 */
		public static final int XCB_GC_ARC_MODE = 4194304;
	};
	/**
	 * <i>native declaration : xcb/xproto.h:2179</i><br>
	 * enum values
	 */
	public static interface xcb_gx_t {
		/** <i>native declaration : xcb/xproto.h:2163</i> */
		public static final int XCB_GX_CLEAR = 0;
		/** <i>native declaration : xcb/xproto.h:2164</i> */
		public static final int XCB_GX_AND = 1;
		/** <i>native declaration : xcb/xproto.h:2165</i> */
		public static final int XCB_GX_AND_REVERSE = 2;
		/** <i>native declaration : xcb/xproto.h:2166</i> */
		public static final int XCB_GX_COPY = 3;
		/** <i>native declaration : xcb/xproto.h:2167</i> */
		public static final int XCB_GX_AND_INVERTED = 4;
		/** <i>native declaration : xcb/xproto.h:2168</i> */
		public static final int XCB_GX_NOOP = 5;
		/** <i>native declaration : xcb/xproto.h:2169</i> */
		public static final int XCB_GX_XOR = 6;
		/** <i>native declaration : xcb/xproto.h:2170</i> */
		public static final int XCB_GX_OR = 7;
		/** <i>native declaration : xcb/xproto.h:2171</i> */
		public static final int XCB_GX_NOR = 8;
		/** <i>native declaration : xcb/xproto.h:2172</i> */
		public static final int XCB_GX_EQUIV = 9;
		/** <i>native declaration : xcb/xproto.h:2173</i> */
		public static final int XCB_GX_INVERT = 10;
		/** <i>native declaration : xcb/xproto.h:2174</i> */
		public static final int XCB_GX_OR_REVERSE = 11;
		/** <i>native declaration : xcb/xproto.h:2175</i> */
		public static final int XCB_GX_COPY_INVERTED = 12;
		/** <i>native declaration : xcb/xproto.h:2176</i> */
		public static final int XCB_GX_OR_INVERTED = 13;
		/** <i>native declaration : xcb/xproto.h:2177</i> */
		public static final int XCB_GX_NAND = 14;
		/** <i>native declaration : xcb/xproto.h:2178</i> */
		public static final int XCB_GX_SET = 15;
	};
	/**
	 * <i>native declaration : xcb/xproto.h:2184</i><br>
	 * enum values
	 */
	public static interface xcb_line_style_t {
		/** <i>native declaration : xcb/xproto.h:2181</i> */
		public static final int XCB_LINE_STYLE_SOLID = 0;
		/** <i>native declaration : xcb/xproto.h:2182</i> */
		public static final int XCB_LINE_STYLE_ON_OFF_DASH = 1;
		/** <i>native declaration : xcb/xproto.h:2183</i> */
		public static final int XCB_LINE_STYLE_DOUBLE_DASH = 2;
	};
	/**
	 * <i>native declaration : xcb/xproto.h:2190</i><br>
	 * enum values
	 */
	public static interface xcb_cap_style_t {
		/** <i>native declaration : xcb/xproto.h:2186</i> */
		public static final int XCB_CAP_STYLE_NOT_LAST = 0;
		/** <i>native declaration : xcb/xproto.h:2187</i> */
		public static final int XCB_CAP_STYLE_BUTT = 1;
		/** <i>native declaration : xcb/xproto.h:2188</i> */
		public static final int XCB_CAP_STYLE_ROUND = 2;
		/** <i>native declaration : xcb/xproto.h:2189</i> */
		public static final int XCB_CAP_STYLE_PROJECTING = 3;
	};
	/**
	 * <i>native declaration : xcb/xproto.h:2195</i><br>
	 * enum values
	 */
	public static interface xcb_join_style_t {
		/** <i>native declaration : xcb/xproto.h:2192</i> */
		public static final int XCB_JOIN_STYLE_MITER = 0;
		/** <i>native declaration : xcb/xproto.h:2193</i> */
		public static final int XCB_JOIN_STYLE_ROUND = 1;
		/** <i>native declaration : xcb/xproto.h:2194</i> */
		public static final int XCB_JOIN_STYLE_BEVEL = 2;
	};
	/**
	 * <i>native declaration : xcb/xproto.h:2201</i><br>
	 * enum values
	 */
	public static interface xcb_fill_style_t {
		/** <i>native declaration : xcb/xproto.h:2197</i> */
		public static final int XCB_FILL_STYLE_SOLID = 0;
		/** <i>native declaration : xcb/xproto.h:2198</i> */
		public static final int XCB_FILL_STYLE_TILED = 1;
		/** <i>native declaration : xcb/xproto.h:2199</i> */
		public static final int XCB_FILL_STYLE_STIPPLED = 2;
		/** <i>native declaration : xcb/xproto.h:2200</i> */
		public static final int XCB_FILL_STYLE_OPAQUE_STIPPLED = 3;
	};
	/**
	 * <i>native declaration : xcb/xproto.h:2205</i><br>
	 * enum values
	 */
	public static interface xcb_fill_rule_t {
		/** <i>native declaration : xcb/xproto.h:2203</i> */
		public static final int XCB_FILL_RULE_EVEN_ODD = 0;
		/** <i>native declaration : xcb/xproto.h:2204</i> */
		public static final int XCB_FILL_RULE_WINDING = 1;
	};
	/**
	 * <i>native declaration : xcb/xproto.h:2209</i><br>
	 * enum values
	 */
	public static interface xcb_subwindow_mode_t {
		/** <i>native declaration : xcb/xproto.h:2207</i> */
		public static final int XCB_SUBWINDOW_MODE_CLIP_BY_CHILDREN = 0;
		/** <i>native declaration : xcb/xproto.h:2208</i> */
		public static final int XCB_SUBWINDOW_MODE_INCLUDE_INFERIORS = 1;
	};
	/**
	 * <i>native declaration : xcb/xproto.h:2213</i><br>
	 * enum values
	 */
	public static interface xcb_arc_mode_t {
		/** <i>native declaration : xcb/xproto.h:2211</i> */
		public static final int XCB_ARC_MODE_CHORD = 0;
		/** <i>native declaration : xcb/xproto.h:2212</i> */
		public static final int XCB_ARC_MODE_PIE_SLICE = 1;
	};
	/**
	 * <i>native declaration : xcb/xproto.h:2254</i><br>
	 * enum values
	 */
	public static interface xcb_clip_ordering_t {
		/** <i>native declaration : xcb/xproto.h:2250</i> */
		public static final int XCB_CLIP_ORDERING_UNSORTED = 0;
		/** <i>native declaration : xcb/xproto.h:2251</i> */
		public static final int XCB_CLIP_ORDERING_Y_SORTED = 1;
		/** <i>native declaration : xcb/xproto.h:2252</i> */
		public static final int XCB_CLIP_ORDERING_YX_SORTED = 2;
		/** <i>native declaration : xcb/xproto.h:2253</i> */
		public static final int XCB_CLIP_ORDERING_YX_BANDED = 3;
	};
	/**
	 * <i>native declaration : xcb/xproto.h:2317</i><br>
	 * enum values
	 */
	public static interface xcb_coord_mode_t {
		/** <i>native declaration : xcb/xproto.h:2314</i> */
		public static final int XCB_COORD_MODE_ORIGIN = 0;
		/**
		 * < Treats all coordinates as relative to the origin.<br>
		 * <i>native declaration : xcb/xproto.h:2316</i>
		 */
		public static final int XCB_COORD_MODE_PREVIOUS = 1;
	};
	/**
	 * <i>native declaration : xcb/xproto.h:2375</i><br>
	 * enum values
	 */
	public static interface xcb_poly_shape_t {
		/** <i>native declaration : xcb/xproto.h:2372</i> */
		public static final int XCB_POLY_SHAPE_COMPLEX = 0;
		/** <i>native declaration : xcb/xproto.h:2373</i> */
		public static final int XCB_POLY_SHAPE_NONCONVEX = 1;
		/** <i>native declaration : xcb/xproto.h:2374</i> */
		public static final int XCB_POLY_SHAPE_CONVEX = 2;
	};
	/**
	 * <i>native declaration : xcb/xproto.h:2407</i><br>
	 * enum values
	 */
	public static interface xcb_image_format_t {
		/** <i>native declaration : xcb/xproto.h:2404</i> */
		public static final int XCB_IMAGE_FORMAT_XY_BITMAP = 0;
		/** <i>native declaration : xcb/xproto.h:2405</i> */
		public static final int XCB_IMAGE_FORMAT_XY_PIXMAP = 1;
		/** <i>native declaration : xcb/xproto.h:2406</i> */
		public static final int XCB_IMAGE_FORMAT_Z_PIXMAP = 2;
	};
	/**
	 * <i>native declaration : xcb/xproto.h:2491</i><br>
	 * enum values
	 */
	public static interface xcb_colormap_alloc_t {
		/** <i>native declaration : xcb/xproto.h:2489</i> */
		public static final int XCB_COLORMAP_ALLOC_NONE = 0;
		/** <i>native declaration : xcb/xproto.h:2490</i> */
		public static final int XCB_COLORMAP_ALLOC_ALL = 1;
	};
	/**
	 * <i>native declaration : xcb/xproto.h:2667</i><br>
	 * enum values
	 */
	public static interface xcb_color_flag_t {
		/** <i>native declaration : xcb/xproto.h:2664</i> */
		public static final int XCB_COLOR_FLAG_RED = 1;
		/** <i>native declaration : xcb/xproto.h:2665</i> */
		public static final int XCB_COLOR_FLAG_GREEN = 2;
		/** <i>native declaration : xcb/xproto.h:2666</i> */
		public static final int XCB_COLOR_FLAG_BLUE = 4;
	};
	/**
	 * <i>native declaration : xcb/xproto.h:2761</i><br>
	 * enum values
	 */
	public static interface xcb_pixmap_enum_t {
		/** <i>native declaration : xcb/xproto.h:2760</i> */
		public static final int XCB_PIXMAP_NONE = 0;
	};
	/**
	 * <i>native declaration : xcb/xproto.h:2781</i><br>
	 * enum values
	 */
	public static interface xcb_font_enum_t {
		/** <i>native declaration : xcb/xproto.h:2780</i> */
		public static final int XCB_FONT_NONE = 0;
	};
	/**
	 * <i>native declaration : xcb/xproto.h:2823</i><br>
	 * enum values
	 */
	public static interface xcb_query_shape_of_t {
		/** <i>native declaration : xcb/xproto.h:2820</i> */
		public static final int XCB_QUERY_SHAPE_OF_LARGEST_CURSOR = 0;
		/** <i>native declaration : xcb/xproto.h:2821</i> */
		public static final int XCB_QUERY_SHAPE_OF_FASTEST_TILE = 1;
		/** <i>native declaration : xcb/xproto.h:2822</i> */
		public static final int XCB_QUERY_SHAPE_OF_FASTEST_STIPPLE = 2;
	};
	/**
	 * <i>native declaration : xcb/xproto.h:2925</i><br>
	 * enum values
	 */
	public static interface xcb_kb_t {
		/** <i>native declaration : xcb/xproto.h:2917</i> */
		public static final int XCB_KB_KEY_CLICK_PERCENT = 1;
		/** <i>native declaration : xcb/xproto.h:2918</i> */
		public static final int XCB_KB_BELL_PERCENT = 2;
		/** <i>native declaration : xcb/xproto.h:2919</i> */
		public static final int XCB_KB_BELL_PITCH = 4;
		/** <i>native declaration : xcb/xproto.h:2920</i> */
		public static final int XCB_KB_BELL_DURATION = 8;
		/** <i>native declaration : xcb/xproto.h:2921</i> */
		public static final int XCB_KB_LED = 16;
		/** <i>native declaration : xcb/xproto.h:2922</i> */
		public static final int XCB_KB_LED_MODE = 32;
		/** <i>native declaration : xcb/xproto.h:2923</i> */
		public static final int XCB_KB_KEY = 64;
		/** <i>native declaration : xcb/xproto.h:2924</i> */
		public static final int XCB_KB_AUTO_REPEAT_MODE = 128;
	};
	/**
	 * <i>native declaration : xcb/xproto.h:2929</i><br>
	 * enum values
	 */
	public static interface xcb_led_mode_t {
		/** <i>native declaration : xcb/xproto.h:2927</i> */
		public static final int XCB_LED_MODE_OFF = 0;
		/** <i>native declaration : xcb/xproto.h:2928</i> */
		public static final int XCB_LED_MODE_ON = 1;
	};
	/**
	 * <i>native declaration : xcb/xproto.h:2934</i><br>
	 * enum values
	 */
	public static interface xcb_auto_repeat_mode_t {
		/** <i>native declaration : xcb/xproto.h:2931</i> */
		public static final int XCB_AUTO_REPEAT_MODE_OFF = 0;
		/** <i>native declaration : xcb/xproto.h:2932</i> */
		public static final int XCB_AUTO_REPEAT_MODE_ON = 1;
		/** <i>native declaration : xcb/xproto.h:2933</i> */
		public static final int XCB_AUTO_REPEAT_MODE_DEFAULT = 2;
	};
	/**
	 * <i>native declaration : xcb/xproto.h:3008</i><br>
	 * enum values
	 */
	public static interface xcb_blanking_t {
		/** <i>native declaration : xcb/xproto.h:3005</i> */
		public static final int XCB_BLANKING_NOT_PREFERRED = 0;
		/** <i>native declaration : xcb/xproto.h:3006</i> */
		public static final int XCB_BLANKING_PREFERRED = 1;
		/** <i>native declaration : xcb/xproto.h:3007</i> */
		public static final int XCB_BLANKING_DEFAULT = 2;
	};
	/**
	 * <i>native declaration : xcb/xproto.h:3013</i><br>
	 * enum values
	 */
	public static interface xcb_exposures_t {
		/** <i>native declaration : xcb/xproto.h:3010</i> */
		public static final int XCB_EXPOSURES_NOT_ALLOWED = 0;
		/** <i>native declaration : xcb/xproto.h:3011</i> */
		public static final int XCB_EXPOSURES_ALLOWED = 1;
		/** <i>native declaration : xcb/xproto.h:3012</i> */
		public static final int XCB_EXPOSURES_DEFAULT = 2;
	};
	/**
	 * <i>native declaration : xcb/xproto.h:3049</i><br>
	 * enum values
	 */
	public static interface xcb_host_mode_t {
		/** <i>native declaration : xcb/xproto.h:3047</i> */
		public static final int XCB_HOST_MODE_INSERT = 0;
		/** <i>native declaration : xcb/xproto.h:3048</i> */
		public static final int XCB_HOST_MODE_DELETE = 1;
	};
	/**
	 * <i>native declaration : xcb/xproto.h:3056</i><br>
	 * enum values
	 */
	public static interface xcb_family_t {
		/** <i>native declaration : xcb/xproto.h:3051</i> */
		public static final int XCB_FAMILY_INTERNET = 0;
		/** <i>native declaration : xcb/xproto.h:3052</i> */
		public static final int XCB_FAMILY_DECNET = 1;
		/** <i>native declaration : xcb/xproto.h:3053</i> */
		public static final int XCB_FAMILY_CHAOS = 2;
		/** <i>native declaration : xcb/xproto.h:3054</i> */
		public static final int XCB_FAMILY_SERVER_INTERPRETED = 5;
		/** <i>native declaration : xcb/xproto.h:3055</i> */
		public static final int XCB_FAMILY_INTERNET_6 = 6;
	};
	/**
	 * <i>native declaration : xcb/xproto.h:3100</i><br>
	 * enum values
	 */
	public static interface xcb_access_control_t {
		/** <i>native declaration : xcb/xproto.h:3098</i> */
		public static final int XCB_ACCESS_CONTROL_DISABLE = 0;
		/** <i>native declaration : xcb/xproto.h:3099</i> */
		public static final int XCB_ACCESS_CONTROL_ENABLE = 1;
	};
	/**
	 * <i>native declaration : xcb/xproto.h:3111</i><br>
	 * enum values
	 */
	public static interface xcb_close_down_t {
		/** <i>native declaration : xcb/xproto.h:3108</i> */
		public static final int XCB_CLOSE_DOWN_DESTROY_ALL = 0;
		/** <i>native declaration : xcb/xproto.h:3109</i> */
		public static final int XCB_CLOSE_DOWN_RETAIN_PERMANENT = 1;
		/** <i>native declaration : xcb/xproto.h:3110</i> */
		public static final int XCB_CLOSE_DOWN_RETAIN_TEMPORARY = 2;
	};
	/**
	 * <i>native declaration : xcb/xproto.h:3120</i><br>
	 * enum values
	 */
	public static interface xcb_kill_t {
		/** <i>native declaration : xcb/xproto.h:3119</i> */
		public static final int XCB_KILL_ALL_TEMPORARY = 0;
	};
	/**
	 * <i>native declaration : xcb/xproto.h:3140</i><br>
	 * enum values
	 */
	public static interface xcb_screen_saver_t {
		/** <i>native declaration : xcb/xproto.h:3138</i> */
		public static final int XCB_SCREEN_SAVER_RESET = 0;
		/** <i>native declaration : xcb/xproto.h:3139</i> */
		public static final int XCB_SCREEN_SAVER_ACTIVE = 1;
	};
	/**
	 * <i>native declaration : xcb/xproto.h:3151</i><br>
	 * enum values
	 */
	public static interface xcb_mapping_status_t {
		/** <i>native declaration : xcb/xproto.h:3148</i> */
		public static final int XCB_MAPPING_STATUS_SUCCESS = 0;
		/** <i>native declaration : xcb/xproto.h:3149</i> */
		public static final int XCB_MAPPING_STATUS_BUSY = 1;
		/** <i>native declaration : xcb/xproto.h:3150</i> */
		public static final int XCB_MAPPING_STATUS_FAILURE = 2;
	};
	/**
	 * <i>native declaration : xcb/xproto.h:3196</i><br>
	 * enum values
	 */
	public static interface xcb_map_index_t {
		/** <i>native declaration : xcb/xproto.h:3188</i> */
		public static final int XCB_MAP_INDEX_SHIFT = 0;
		/** <i>native declaration : xcb/xproto.h:3189</i> */
		public static final int XCB_MAP_INDEX_LOCK = 1;
		/** <i>native declaration : xcb/xproto.h:3190</i> */
		public static final int XCB_MAP_INDEX_CONTROL = 2;
		/** <i>native declaration : xcb/xproto.h:3191</i> */
		public static final int XCB_MAP_INDEX_1 = 3;
		/** <i>native declaration : xcb/xproto.h:3192</i> */
		public static final int XCB_MAP_INDEX_2 = 4;
		/** <i>native declaration : xcb/xproto.h:3193</i> */
		public static final int XCB_MAP_INDEX_3 = 5;
		/** <i>native declaration : xcb/xproto.h:3194</i> */
		public static final int XCB_MAP_INDEX_4 = 6;
		/** <i>native declaration : xcb/xproto.h:3195</i> */
		public static final int XCB_MAP_INDEX_5 = 7;
	};
	/** <i>native declaration : xcb/xproto.h</i> */
	public static final int XCB_CHANGE_PROPERTY = (int)18;
	/** <i>native declaration : xcb/xproto.h</i> */
	public static final int XCB_VALUE = (int)2;
	/** <i>native declaration : xcb/xproto.h</i> */
	public static final int XCB_GRAB_POINTER = (int)26;
	/** <i>native declaration : xcb/xproto.h</i> */
	public static final int XCB_CONFIGURE_NOTIFY = (int)22;
	/** <i>native declaration : xcb/xproto.h</i> */
	public static final int XCB_MAP_NOTIFY = (int)19;
	/** <i>native declaration : xcb/xproto.h</i> */
	public static final int XCB_CLOSE_FONT = (int)46;
	/** <i>native declaration : xcb/xcb.h</i> */
	public static final int XCB_CONN_CLOSED_MEM_INSUFFICIENT = (int)3;
	/** <i>native declaration : xcb/xproto.h</i> */
	public static final int XCB_GET_SCREEN_SAVER = (int)108;
	/** <i>native declaration : xcb/xproto.h</i> */
	public static final int XCB_KEY_RELEASE = (int)3;
	/** <i>native declaration : xcb/xproto.h</i> */
	public static final int XCB_ID_CHOICE = (int)14;
	/** <i>native declaration : xcb/xproto.h</i> */
	public static final int XCB_GET_IMAGE = (int)73;
	/** <i>native declaration : xcb/xcb.h</i> */
	public static final int XCB_CONN_CLOSED_PARSE_ERR = (int)5;
	/** <i>native declaration : xcb/xcb.h</i> */
	public static final int XCB_NONE = (int)0;
	/** <i>native declaration : xcb/xproto.h</i> */
	public static final int XCB_INSTALL_COLORMAP = (int)81;
	/** <i>native declaration : xcb/xcb.h</i> */
	public static final int XCB_CONN_CLOSED_EXT_NOTSUPPORTED = (int)2;
	/** <i>native declaration : xcb/xproto.h</i> */
	public static final int XCB_CREATE_NOTIFY = (int)16;
	/** <i>native declaration : xcb/xproto.h</i> */
	public static final int XCB_COPY_COLORMAP_AND_FREE = (int)80;
	/** <i>native declaration : xcb/xproto.h</i> */
	public static final int XCB_SELECTION_CLEAR = (int)29;
	/** <i>native declaration : xcb/xcb.h</i> */
	public static final int XCB_NO_SYMBOL = (int)0;
	/** <i>native declaration : xcb/xproto.h</i> */
	public static final int XCB_GET_PROPERTY = (int)20;
	/** <i>native declaration : xcb/xproto.h</i> */
	public static final int XCB_CREATE_COLORMAP = (int)78;
	/** <i>native declaration : xcb/xproto.h</i> */
	public static final int XCB_SET_SCREEN_SAVER = (int)107;
	/** <i>native declaration : xcb/xproto.h</i> */
	public static final int XCB_FREE_PIXMAP = (int)54;
	/** <i>native declaration : xcb/xproto.h</i> */
	public static final int XCB_CIRCULATE_REQUEST = (int)27;
	/** <i>native declaration : xcb/xproto.h</i> */
	public static final int XCB_ACCESS = (int)10;
	/** <i>native declaration : xcb/xproto.h</i> */
	public static final int XCB_QUERY_EXTENSION = (int)98;
	/** <i>native declaration : xcb/xproto.h</i> */
	public static final int XCB_VISIBILITY_NOTIFY = (int)15;
	/** <i>native declaration : xcb/xproto.h</i> */
	public static final int XCB_SET_MODIFIER_MAPPING = (int)118;
	/** <i>native declaration : xcb/xproto.h</i> */
	public static final int XCB_UNGRAB_BUTTON = (int)29;
	/** <i>native declaration : xcb/xproto.h</i> */
	public static final int XCB_DESTROY_NOTIFY = (int)17;
	/** <i>native declaration : xcb/xproto.h</i> */
	public static final int XCB_BUTTON_PRESS = (int)4;
	/** <i>native declaration : xcb/xcb.h</i> */
	public static final int XCB_CONN_CLOSED_INVALID_SCREEN = (int)6;
	/** <i>native declaration : xcb/xproto.h</i> */
	public static final int XCB_UNGRAB_SERVER = (int)37;
	/** <i>native declaration : xcb/xproto.h</i> */
	public static final int XCB_QUERY_POINTER = (int)38;
	/** <i>native declaration : xcb/xproto.h</i> */
	public static final int XCB_PIXMAP = (int)4;
	/** <i>native declaration : xcb/xproto.h</i> */
	public static final int XCB_NAME = (int)15;
	/** <i>native declaration : xcb/xproto.h</i> */
	public static final int XCB_KEYMAP_NOTIFY = (int)11;
	/** <i>native declaration : xcb/xproto.h</i> */
	public static final int XCB_GET_KEYBOARD_CONTROL = (int)103;
	/** <i>native declaration : xcb/xproto.h</i> */
	public static final int XCB_RECOLOR_CURSOR = (int)96;
	/** <i>native declaration : xcb/xproto.h</i> */
	public static final int XCB_FREE_COLORS = (int)88;
	/** <i>native declaration : xcb/xproto.h</i> */
	public static final int XCB_REQUEST = (int)1;
	/** <i>native declaration : xcb/xproto.h</i> */
	public static final int XCB_SEND_EVENT = (int)25;
	/** <i>native declaration : xcb/xproto.h</i> */
	public static final int XCB_GRAVITY_NOTIFY = (int)24;
	/** <i>native declaration : xcb/xproto.h</i> */
	public static final int XCB_POLY_LINE = (int)65;
	/** <i>native declaration : xcb/xcb.h</i> */
	public static final int X_PROTOCOL = (int)11;
	/** <i>native declaration : xcb/xproto.h</i> */
	public static final int XCB_FREE_GC = (int)60;
	/** <i>native declaration : xcb/xcb.h</i> */
	public static final int X_TCP_PORT = (int)6000;
	/** <i>native declaration : xcb/xproto.h</i> */
	public static final int XCB_CHANGE_POINTER_CONTROL = (int)105;
	/** <i>native declaration : xcb/xproto.h</i> */
	public static final int XCB_LIST_FONTS_WITH_INFO = (int)50;
	/** <i>native declaration : xcb/xproto.h</i> */
	public static final int XCB_CIRCULATE_NOTIFY = (int)26;
	/** <i>native declaration : xcb/xproto.h</i> */
	public static final int XCB_ALLOC_NAMED_COLOR = (int)85;
	/** <i>native declaration : xcb/xproto.h</i> */
	public static final int XCB_GET_SELECTION_OWNER = (int)23;
	/** <i>native declaration : xcb/xcb.h</i> */
	public static final int XCB_CONN_CLOSED_REQ_LEN_EXCEED = (int)4;
	/** <i>native declaration : xcb/xproto.h</i> */
	public static final int XCB_LIST_HOSTS = (int)110;
	/** <i>native declaration : xcb/xproto.h</i> */
	public static final int XCB_IMAGE_TEXT_16 = (int)77;
	/** <i>native declaration : xcb/xcb.h</i> */
	public static final int XCB_CONN_CLOSED_FDPASSING_FAILED = (int)7;
	/** <i>native declaration : xcb/xproto.h</i> */
	public static final int XCB_EXPOSE = (int)12;
	/** <i>native declaration : xcb/xproto.h</i> */
	public static final int XCB_REPARENT_NOTIFY = (int)21;
	/** <i>native declaration : xcb/xproto.h</i> */
	public static final int XCB_GET_MOTION_EVENTS = (int)39;
	/** <i>native declaration : xcb/xproto.h</i> */
	public static final int XCB_GET_ATOM_NAME = (int)17;
	/** <i>native declaration : xcb/xproto.h</i> */
	public static final int XCB_LEAVE_NOTIFY = (int)8;
	/** <i>native declaration : xcb/xproto.h</i> */
	public static final int XCB_IMAGE_TEXT_8 = (int)76;
	/** <i>native declaration : xcb/xproto.h</i> */
	public static final int XCB_QUERY_KEYMAP = (int)44;
	/** <i>native declaration : xcb/xproto.h</i> */
	public static final int XCB_GET_POINTER_MAPPING = (int)117;
	/** <i>native declaration : xcb/xproto.h</i> */
	public static final int XCB_CHANGE_KEYBOARD_CONTROL = (int)102;
	/** <i>native declaration : xcb/xproto.h</i> */
	public static final int XCB_FORCE_SCREEN_SAVER = (int)115;
	/** <i>native declaration : xcb/xproto.h</i> */
	public static final int XCB_LIST_PROPERTIES = (int)21;
	/** <i>native declaration : xcb/xproto.h</i> */
	public static final int XCB_CHANGE_HOSTS = (int)109;
	/** <i>native declaration : xcb/xproto.h</i> */
	public static final int XCB_GET_GEOMETRY = (int)14;
	/** <i>native declaration : xcb/xproto.h</i> */
	public static final int XCB_UNGRAB_KEYBOARD = (int)32;
	/** <i>native declaration : xcb/xproto.h</i> */
	public static final int XCB_FILL_POLY = (int)69;
	/** <i>native declaration : xcb/xproto.h</i> */
	public static final int XCB_FOCUS_IN = (int)9;
	/** <i>native declaration : xcb/xproto.h</i> */
	public static final int XCB_UNINSTALL_COLORMAP = (int)82;
	/** <i>native declaration : xcb/xproto.h</i> */
	public static final int XCB_SELECTION_NOTIFY = (int)31;
	/** <i>native declaration : xcb/xcb.h</i> */
	public static final int XCB_CURRENT_TIME = (int)0;
	/** <i>native declaration : xcb/xcb.h</i> */
	public static final int X_PROTOCOL_REVISION = (int)0;
	/** <i>native declaration : xcb/xproto.h</i> */
	public static final int XCB_CHANGE_KEYBOARD_MAPPING = (int)100;
	/** <i>native declaration : xcb/xproto.h</i> */
	public static final int XCB_STORE_COLORS = (int)89;
	/** <i>native declaration : xcb/xproto.h</i> */
	public static final int XCB_GET_POINTER_CONTROL = (int)106;
	/** <i>native declaration : xcb/xcb.h</i> */
	public static final int XCB_CONN_ERROR = (int)1;
	/** <i>native declaration : xcb/xproto.h</i> */
	public static final int XCB_COLORMAP = (int)12;
	/** <i>native declaration : xcb/xproto.h</i> */
	public static final int XCB_CLEAR_AREA = (int)61;
	/** <i>native declaration : xcb/xproto.h</i> */
	public static final int XCB_UNMAP_SUBWINDOWS = (int)11;
	/** <i>native declaration : xcb/xproto.h</i> */
	public static final int XCB_RESIZE_REQUEST = (int)25;
	/** <i>native declaration : xcb/xproto.h</i> */
	public static final int XCB_CREATE_CURSOR = (int)93;
	/** <i>native declaration : xcb/xproto.h</i> */
	public static final int XCB_QUERY_FONT = (int)47;
	/** <i>native declaration : xcb/xproto.h</i> */
	public static final int XCB_DESTROY_SUBWINDOWS = (int)5;
	/** <i>native declaration : xcb/xproto.h</i> */
	public static final int XCB_COPY_PLANE = (int)63;
	/** <i>native declaration : xcb/xproto.h</i> */
	public static final int XCB_REPARENT_WINDOW = (int)7;
	/** <i>native declaration : xcb/xproto.h</i> */
	public static final int XCB_POLY_RECTANGLE = (int)67;
	/** <i>native declaration : xcb/xproto.h</i> */
	public static final int XCB_GRAPHICS_EXPOSURE = (int)13;
	/** <i>native declaration : xcb/xproto.h</i> */
	public static final int XCB_CIRCULATE_WINDOW = (int)13;
	/** <i>native declaration : xcb/xproto.h</i> */
	public static final int XCB_DESTROY_WINDOW = (int)4;
	/** <i>native declaration : xcb/xproto.h</i> */
	public static final int XCB_CURSOR = (int)6;
	/** <i>native declaration : xcb/xproto.h</i> */
	public static final int XCB_CONVERT_SELECTION = (int)24;
	/** <i>native declaration : xcb/xproto.h</i> */
	public static final int XCB_SET_SELECTION_OWNER = (int)22;
	/** <i>native declaration : xcb/xproto.h</i> */
	public static final int XCB_KILL_CLIENT = (int)113;
	/** <i>native declaration : xcb/xproto.h</i> */
	public static final int XCB_ALLOC_COLOR = (int)84;
	/** <i>native declaration : xcb/xproto.h</i> */
	public static final int XCB_BELL = (int)104;
	/** <i>native declaration : xcb/xproto.h</i> */
	public static final int XCB_CREATE_WINDOW = (int)1;
	/** <i>native declaration : xcb/xproto.h</i> */
	public static final int XCB_FREE_COLORMAP = (int)79;
	/** <i>native declaration : xcb/xproto.h</i> */
	public static final int XCB_STORE_NAMED_COLOR = (int)90;
	/** <i>native declaration : xcb/xproto.h</i> */
	public static final int XCB_CONFIGURE_REQUEST = (int)23;
	/** <i>native declaration : xcb/xproto.h</i> */
	public static final int XCB_PROPERTY_NOTIFY = (int)28;
	/** <i>native declaration : xcb/xproto.h</i> */
	public static final int XCB_MAP_REQUEST = (int)20;
	/** <i>native declaration : xcb/xproto.h</i> */
	public static final int XCB_GET_INPUT_FOCUS = (int)43;
	/** <i>native declaration : xcb/xproto.h</i> */
	public static final int XCB_DELETE_PROPERTY = (int)19;
	/** <i>native declaration : xcb/xproto.h</i> */
	public static final int XCB_POLY_TEXT_8 = (int)74;
	/** <i>native declaration : xcb/xproto.h</i> */
	public static final int XCB_SELECTION_REQUEST = (int)30;
	/** <i>native declaration : xcb/xproto.h</i> */
	public static final int XCB_CONFIGURE_WINDOW = (int)12;
	/** <i>native declaration : xcb/xproto.h</i> */
	public static final int XCB_FOCUS_OUT = (int)10;
	/** <i>native declaration : xcb/xproto.h</i> */
	public static final int XCB_MAPPING_NOTIFY = (int)34;
	/** <i>native declaration : xcb/xproto.h</i> */
	public static final int XCB_SET_CLIP_RECTANGLES = (int)59;
	/** <i>native declaration : xcb/xproto.h</i> */
	public static final int XCB_SET_DASHES = (int)58;
	/** <i>native declaration : xcb/xproto.h</i> */
	public static final int XCB_ATOM = (int)5;
	/** <i>native declaration : xcb/xproto.h</i> */
	public static final int XCB_MAP_SUBWINDOWS = (int)9;
	/** <i>native declaration : xcb/xproto.h</i> */
	public static final int XCB_QUERY_TREE = (int)15;
	/** <i>native declaration : xcb/xproto.h</i> */
	public static final int XCB_GRAB_BUTTON = (int)28;
	/** <i>native declaration : xcb/xproto.h</i> */
	public static final int XCB_POLY_ARC = (int)68;
	/** <i>native declaration : xcb/xproto.h</i> */
	public static final int XCB_GET_MODIFIER_MAPPING = (int)119;
	/** <i>native declaration : xcb/xproto.h</i> */
	public static final int XCB_UNGRAB_POINTER = (int)27;
	/** <i>native declaration : xcb/xproto.h</i> */
	public static final int XCB_ALLOC_COLOR_CELLS = (int)86;
	/** <i>native declaration : xcb/xcb.h</i> */
	public static final int XCB_COPY_FROM_PARENT = (int)0;
	/** <i>native declaration : xcb/xproto.h</i> */
	public static final int XCB_IMPLEMENTATION = (int)17;
	/** <i>native declaration : xcb/xproto.h</i> */
	public static final int XCB_LOOKUP_COLOR = (int)92;
	/** <i>native declaration : xcb/xproto.h</i> */
	public static final int XCB_CHANGE_ACTIVE_POINTER_GRAB = (int)30;
	/** <i>native declaration : xcb/xproto.h</i> */
	public static final int XCB_BUTTON_RELEASE = (int)5;
	/** <i>native declaration : xcb/xproto.h</i> */
	public static final int XCB_GET_WINDOW_ATTRIBUTES = (int)3;
	/** <i>native declaration : xcb/xproto.h</i> */
	public static final int XCB_TRANSLATE_COORDINATES = (int)40;
	/** <i>native declaration : xcb/xproto.h</i> */
	public static final int XCB_POLY_FILL_RECTANGLE = (int)70;
	/** <i>native declaration : xcb/xproto.h</i> */
	public static final int XCB_FREE_CURSOR = (int)95;
	/** <i>native declaration : xcb/xproto.h</i> */
	public static final int XCB_NO_EXPOSURE = (int)14;
	/** <i>native declaration : xcb/xproto.h</i> */
	public static final int XCB_CLIENT_MESSAGE = (int)33;
	/** <i>native declaration : xcb/xproto.h</i> */
	public static final int XCB_MOTION_NOTIFY = (int)6;
	/** <i>native declaration : xcb/xproto.h</i> */
	public static final int XCB_CHANGE_WINDOW_ATTRIBUTES = (int)2;
	/** <i>native declaration : xcb/xproto.h</i> */
	public static final int XCB_CHANGE_SAVE_SET = (int)6;
	/** <i>native declaration : xcb/xproto.h</i> */
	public static final int XCB_LIST_EXTENSIONS = (int)99;
	/** <i>native declaration : xcb/xproto.h</i> */
	public static final int XCB_POLY_POINT = (int)64;
	/** <i>native declaration : xcb/xproto.h</i> */
	public static final int XCB_QUERY_TEXT_EXTENTS = (int)48;
	/** <i>native declaration : xcb/xproto.h</i> */
	public static final int XCB_OPEN_FONT = (int)45;
	/** <i>native declaration : xcb/xproto.h</i> */
	public static final int XCB_POLY_SEGMENT = (int)66;
	/** <i>native declaration : xcb/xproto.h</i> */
	public static final int XCB_LENGTH = (int)16;
	/** <i>native declaration : xcb/xproto.h</i> */
	public static final int XCB_ALLOC = (int)11;
	/** <i>native declaration : xcb/xproto.h</i> */
	public static final int XCB_GRAB_KEYBOARD = (int)31;
	/** <i>native declaration : xcb/xproto.h</i> */
	public static final int XCB_SET_INPUT_FOCUS = (int)42;
	/** <i>native declaration : xcb/xproto.h</i> */
	public static final int XCB_WINDOW = (int)3;
	/** <i>native declaration : xcb/xproto.h</i> */
	public static final int XCB_ROTATE_PROPERTIES = (int)114;
	/** <i>native declaration : xcb/xproto.h</i> */
	public static final int XCB_GE_GENERIC = (int)35;
	/** <i>native declaration : xcb/xproto.h</i> */
	public static final int XCB_POLY_FILL_ARC = (int)71;
	/** <i>native declaration : xcb/xproto.h</i> */
	public static final int XCB_CREATE_PIXMAP = (int)53;
	/** <i>native declaration : xcb/xproto.h</i> */
	public static final int XCB_NO_OPERATION = (int)127;
	/** <i>native declaration : xcb/xproto.h</i> */
	public static final int XCB_MATCH = (int)8;
	/** <i>native declaration : xcb/xproto.h</i> */
	public static final int XCB_UNMAP_NOTIFY = (int)18;
	/** <i>native declaration : xcb/xproto.h</i> */
	public static final int XCB_POLY_TEXT_16 = (int)75;
	/** <i>native declaration : xcb/xproto.h</i> */
	public static final int XCB_FONT = (int)7;
	/** <i>native declaration : xcb/xproto.h</i> */
	public static final int XCB_QUERY_BEST_SIZE = (int)97;
	/** <i>native declaration : xcb/xproto.h</i> */
	public static final int XCB_GRAB_KEY = (int)33;
	/** <i>native declaration : xcb/xproto.h</i> */
	public static final int XCB_SET_CLOSE_DOWN_MODE = (int)112;
	/** <i>native declaration : xcb/xproto.h</i> */
	public static final int XCB_DRAWABLE = (int)9;
	/** <i>native declaration : xcb/xproto.h</i> */
	public static final int XCB_SET_POINTER_MAPPING = (int)116;
	/** <i>native declaration : xcb/xproto.h</i> */
	public static final int XCB_ENTER_NOTIFY = (int)7;
	/** <i>native declaration : xcb/xproto.h</i> */
	public static final int XCB_GRAB_SERVER = (int)36;
	/** <i>native declaration : xcb/xproto.h</i> */
	public static final int XCB_LIST_INSTALLED_COLORMAPS = (int)83;
	/** <i>native declaration : xcb/xproto.h</i> */
	public static final int XCB_LIST_FONTS = (int)49;
	/** <i>native declaration : xcb/xproto.h</i> */
	public static final int XCB_SET_ACCESS_CONTROL = (int)111;
	/** <i>native declaration : xcb/xproto.h</i> */
	public static final int XCB_KEY_PRESS = (int)2;
	/** <i>native declaration : xcb/xproto.h</i> */
	public static final int XCB_QUERY_COLORS = (int)91;
	/** <i>native declaration : xcb/xproto.h</i> */
	public static final int XCB_ALLOW_EVENTS = (int)35;
	/** <i>native declaration : xcb/xproto.h</i> */
	public static final int XCB_UNGRAB_KEY = (int)34;
	/** <i>native declaration : xcb/xproto.h</i> */
	public static final int XCB_GET_FONT_PATH = (int)52;
	/** <i>native declaration : xcb/xproto.h</i> */
	public static final int XCB_G_CONTEXT = (int)13;
	/** <i>native declaration : xcb/xproto.h</i> */
	public static final int XCB_COLORMAP_NOTIFY = (int)32;
	/** <i>native declaration : xcb/xproto.h</i> */
	public static final int XCB_MAP_WINDOW = (int)8;
	/** <i>native declaration : xcb/xproto.h</i> */
	public static final int XCB_INTERN_ATOM = (int)16;
	/** <i>native declaration : xcb/xproto.h</i> */
	public static final int XCB_CREATE_GLYPH_CURSOR = (int)94;
	/** <i>native declaration : xcb/xproto.h</i> */
	public static final int XCB_PUT_IMAGE = (int)72;
	/** <i>native declaration : xcb/xproto.h</i> */
	public static final int XCB_CHANGE_GC = (int)56;
	/** <i>native declaration : xcb/xproto.h</i> */
	public static final int XCB_UNMAP_WINDOW = (int)10;
	/** <i>native declaration : xcb/xproto.h</i> */
	public static final int XCB_WARP_POINTER = (int)41;
	/** <i>native declaration : xcb/xproto.h</i> */
	public static final int XCB_COPY_AREA = (int)62;
	/** <i>native declaration : xcb/xproto.h</i> */
	public static final int XCB_GET_KEYBOARD_MAPPING = (int)101;
	/** <i>native declaration : xcb/xproto.h</i> */
	public static final int XCB_CREATE_GC = (int)55;
	/** <i>native declaration : xcb/xproto.h</i> */
	public static final int XCB_COPY_GC = (int)57;
	/** <i>native declaration : xcb/xproto.h</i> */
	public static final int XCB_SET_FONT_PATH = (int)51;
	/** <i>native declaration : xcb/xproto.h</i> */
	public static final int XCB_ALLOC_COLOR_PLANES = (int)87;
	/**
	 * Get the next element of the iterator<br>
	 * @param i Pointer to a xcb_char2b_iterator_t<br>
	 * Get the next element in the iterator. The member rem is<br>
	 * decreased by one. The member data points to the next<br>
	 * element. The member index is increased by sizeof(xcb_char2b_t)<br>
	 * Original signature : <code>void xcb_char2b_next(xcb_char2b_iterator_t*)</code><br>
	 * @param i <<br>
	 * <i>native declaration : xcb/xproto.h:3247</i>
	 */
	void xcb_char2b_next(xcb_char2b_iterator_t i);
	/**
	 * Return the iterator pointing to the last element<br>
	 * @param i An xcb_char2b_iterator_t<br>
	 * @return  The iterator pointing to the last element<br>
	 * Set the current element in the iterator to the last element.<br>
	 * The member rem is set to 0. The member data points to the<br>
	 * last element.<br>
	 * Original signature : <code>xcb_generic_iterator_t xcb_char2b_end(xcb_char2b_iterator_t)</code><br>
	 * @param i <<br>
	 * <i>native declaration : xcb/xproto.h:3258</i>
	 */
	xcb.xcb_generic_iterator_t.ByValue xcb_char2b_end(xcb_char2b_iterator_t.ByValue i);
	/**
	 * Get the next element of the iterator<br>
	 * @param i Pointer to a xcb_window_iterator_t<br>
	 * Get the next element in the iterator. The member rem is<br>
	 * decreased by one. The member data points to the next<br>
	 * element. The member index is increased by sizeof(xcb_window_t)<br>
	 * Original signature : <code>void xcb_window_next(xcb_window_iterator_t*)</code><br>
	 * @param i <<br>
	 * <i>native declaration : xcb/xproto.h:3268</i>
	 */
	void xcb_window_next(xcb_window_iterator_t i);
	/**
	 * Return the iterator pointing to the last element<br>
	 * @param i An xcb_window_iterator_t<br>
	 * @return  The iterator pointing to the last element<br>
	 * Set the current element in the iterator to the last element.<br>
	 * The member rem is set to 0. The member data points to the<br>
	 * last element.<br>
	 * Original signature : <code>xcb_generic_iterator_t xcb_window_end(xcb_window_iterator_t)</code><br>
	 * @param i <<br>
	 * <i>native declaration : xcb/xproto.h:3279</i>
	 */
	xcb.xcb_generic_iterator_t.ByValue xcb_window_end(xcb_window_iterator_t.ByValue i);
	/**
	 * Get the next element of the iterator<br>
	 * @param i Pointer to a xcb_pixmap_iterator_t<br>
	 * Get the next element in the iterator. The member rem is<br>
	 * decreased by one. The member data points to the next<br>
	 * element. The member index is increased by sizeof(xcb_pixmap_t)<br>
	 * Original signature : <code>void xcb_pixmap_next(xcb_pixmap_iterator_t*)</code><br>
	 * @param i <<br>
	 * <i>native declaration : xcb/xproto.h:3289</i>
	 */
	void xcb_pixmap_next(xcb_pixmap_iterator_t i);
	/**
	 * Return the iterator pointing to the last element<br>
	 * @param i An xcb_pixmap_iterator_t<br>
	 * @return  The iterator pointing to the last element<br>
	 * Set the current element in the iterator to the last element.<br>
	 * The member rem is set to 0. The member data points to the<br>
	 * last element.<br>
	 * Original signature : <code>xcb_generic_iterator_t xcb_pixmap_end(xcb_pixmap_iterator_t)</code><br>
	 * @param i <<br>
	 * <i>native declaration : xcb/xproto.h:3300</i>
	 */
	xcb.xcb_generic_iterator_t.ByValue xcb_pixmap_end(xcb_pixmap_iterator_t.ByValue i);
	/**
	 * Get the next element of the iterator<br>
	 * @param i Pointer to a xcb_cursor_iterator_t<br>
	 * Get the next element in the iterator. The member rem is<br>
	 * decreased by one. The member data points to the next<br>
	 * element. The member index is increased by sizeof(xcb_cursor_t)<br>
	 * Original signature : <code>void xcb_cursor_next(xcb_cursor_iterator_t*)</code><br>
	 * @param i <<br>
	 * <i>native declaration : xcb/xproto.h:3310</i>
	 */
	void xcb_cursor_next(xcb_cursor_iterator_t i);
	/**
	 * Return the iterator pointing to the last element<br>
	 * @param i An xcb_cursor_iterator_t<br>
	 * @return  The iterator pointing to the last element<br>
	 * Set the current element in the iterator to the last element.<br>
	 * The member rem is set to 0. The member data points to the<br>
	 * last element.<br>
	 * Original signature : <code>xcb_generic_iterator_t xcb_cursor_end(xcb_cursor_iterator_t)</code><br>
	 * @param i <<br>
	 * <i>native declaration : xcb/xproto.h:3321</i>
	 */
	xcb.xcb_generic_iterator_t.ByValue xcb_cursor_end(xcb_cursor_iterator_t.ByValue i);
	/**
	 * Get the next element of the iterator<br>
	 * @param i Pointer to a xcb_font_iterator_t<br>
	 * Get the next element in the iterator. The member rem is<br>
	 * decreased by one. The member data points to the next<br>
	 * element. The member index is increased by sizeof(xcb_font_t)<br>
	 * Original signature : <code>void xcb_font_next(xcb_font_iterator_t*)</code><br>
	 * @param i <<br>
	 * <i>native declaration : xcb/xproto.h:3331</i>
	 */
	void xcb_font_next(xcb_font_iterator_t i);
	/**
	 * Return the iterator pointing to the last element<br>
	 * @param i An xcb_font_iterator_t<br>
	 * @return  The iterator pointing to the last element<br>
	 * Set the current element in the iterator to the last element.<br>
	 * The member rem is set to 0. The member data points to the<br>
	 * last element.<br>
	 * Original signature : <code>xcb_generic_iterator_t xcb_font_end(xcb_font_iterator_t)</code><br>
	 * @param i <<br>
	 * <i>native declaration : xcb/xproto.h:3342</i>
	 */
	xcb.xcb_generic_iterator_t.ByValue xcb_font_end(xcb_font_iterator_t.ByValue i);
	/**
	 * Get the next element of the iterator<br>
	 * @param i Pointer to a xcb_gcontext_iterator_t<br>
	 * Get the next element in the iterator. The member rem is<br>
	 * decreased by one. The member data points to the next<br>
	 * element. The member index is increased by sizeof(xcb_gcontext_t)<br>
	 * Original signature : <code>void xcb_gcontext_next(xcb_gcontext_iterator_t*)</code><br>
	 * @param i <<br>
	 * <i>native declaration : xcb/xproto.h:3352</i>
	 */
	void xcb_gcontext_next(xcb_gcontext_iterator_t i);
	/**
	 * Return the iterator pointing to the last element<br>
	 * @param i An xcb_gcontext_iterator_t<br>
	 * @return  The iterator pointing to the last element<br>
	 * Set the current element in the iterator to the last element.<br>
	 * The member rem is set to 0. The member data points to the<br>
	 * last element.<br>
	 * Original signature : <code>xcb_generic_iterator_t xcb_gcontext_end(xcb_gcontext_iterator_t)</code><br>
	 * @param i <<br>
	 * <i>native declaration : xcb/xproto.h:3363</i>
	 */
	xcb.xcb_generic_iterator_t.ByValue xcb_gcontext_end(xcb_gcontext_iterator_t.ByValue i);
	/**
	 * Get the next element of the iterator<br>
	 * @param i Pointer to a xcb_colormap_iterator_t<br>
	 * Get the next element in the iterator. The member rem is<br>
	 * decreased by one. The member data points to the next<br>
	 * element. The member index is increased by sizeof(xcb_colormap_t)<br>
	 * Original signature : <code>void xcb_colormap_next(xcb_colormap_iterator_t*)</code><br>
	 * @param i <<br>
	 * <i>native declaration : xcb/xproto.h:3373</i>
	 */
	void xcb_colormap_next(xcb_colormap_iterator_t i);
	/**
	 * Return the iterator pointing to the last element<br>
	 * @param i An xcb_colormap_iterator_t<br>
	 * @return  The iterator pointing to the last element<br>
	 * Set the current element in the iterator to the last element.<br>
	 * The member rem is set to 0. The member data points to the<br>
	 * last element.<br>
	 * Original signature : <code>xcb_generic_iterator_t xcb_colormap_end(xcb_colormap_iterator_t)</code><br>
	 * @param i <<br>
	 * <i>native declaration : xcb/xproto.h:3384</i>
	 */
	xcb.xcb_generic_iterator_t.ByValue xcb_colormap_end(xcb_colormap_iterator_t.ByValue i);
	/**
	 * Get the next element of the iterator<br>
	 * @param i Pointer to a xcb_atom_iterator_t<br>
	 * Get the next element in the iterator. The member rem is<br>
	 * decreased by one. The member data points to the next<br>
	 * element. The member index is increased by sizeof(xcb_atom_t)<br>
	 * Original signature : <code>void xcb_atom_next(xcb_atom_iterator_t*)</code><br>
	 * @param i <<br>
	 * <i>native declaration : xcb/xproto.h:3394</i>
	 */
	void xcb_atom_next(xcb_atom_iterator_t i);
	/**
	 * Return the iterator pointing to the last element<br>
	 * @param i An xcb_atom_iterator_t<br>
	 * @return  The iterator pointing to the last element<br>
	 * Set the current element in the iterator to the last element.<br>
	 * The member rem is set to 0. The member data points to the<br>
	 * last element.<br>
	 * Original signature : <code>xcb_generic_iterator_t xcb_atom_end(xcb_atom_iterator_t)</code><br>
	 * @param i <<br>
	 * <i>native declaration : xcb/xproto.h:3405</i>
	 */
	xcb.xcb_generic_iterator_t.ByValue xcb_atom_end(xcb_atom_iterator_t.ByValue i);
	/**
	 * Get the next element of the iterator<br>
	 * @param i Pointer to a xcb_drawable_iterator_t<br>
	 * Get the next element in the iterator. The member rem is<br>
	 * decreased by one. The member data points to the next<br>
	 * element. The member index is increased by sizeof(xcb_drawable_t)<br>
	 * Original signature : <code>void xcb_drawable_next(xcb_drawable_iterator_t*)</code><br>
	 * @param i <<br>
	 * <i>native declaration : xcb/xproto.h:3415</i>
	 */
	void xcb_drawable_next(xcb_drawable_iterator_t i);
	/**
	 * Return the iterator pointing to the last element<br>
	 * @param i An xcb_drawable_iterator_t<br>
	 * @return  The iterator pointing to the last element<br>
	 * Set the current element in the iterator to the last element.<br>
	 * The member rem is set to 0. The member data points to the<br>
	 * last element.<br>
	 * Original signature : <code>xcb_generic_iterator_t xcb_drawable_end(xcb_drawable_iterator_t)</code><br>
	 * @param i <<br>
	 * <i>native declaration : xcb/xproto.h:3426</i>
	 */
	xcb.xcb_generic_iterator_t.ByValue xcb_drawable_end(xcb_drawable_iterator_t.ByValue i);
	/**
	 * Get the next element of the iterator<br>
	 * @param i Pointer to a xcb_fontable_iterator_t<br>
	 * Get the next element in the iterator. The member rem is<br>
	 * decreased by one. The member data points to the next<br>
	 * element. The member index is increased by sizeof(xcb_fontable_t)<br>
	 * Original signature : <code>void xcb_fontable_next(xcb_fontable_iterator_t*)</code><br>
	 * @param i <<br>
	 * <i>native declaration : xcb/xproto.h:3436</i>
	 */
	void xcb_fontable_next(xcb_fontable_iterator_t i);
	/**
	 * Return the iterator pointing to the last element<br>
	 * @param i An xcb_fontable_iterator_t<br>
	 * @return  The iterator pointing to the last element<br>
	 * Set the current element in the iterator to the last element.<br>
	 * The member rem is set to 0. The member data points to the<br>
	 * last element.<br>
	 * Original signature : <code>xcb_generic_iterator_t xcb_fontable_end(xcb_fontable_iterator_t)</code><br>
	 * @param i <<br>
	 * <i>native declaration : xcb/xproto.h:3447</i>
	 */
	xcb.xcb_generic_iterator_t.ByValue xcb_fontable_end(xcb_fontable_iterator_t.ByValue i);
	/**
	 * Get the next element of the iterator<br>
	 * @param i Pointer to a xcb_visualid_iterator_t<br>
	 * Get the next element in the iterator. The member rem is<br>
	 * decreased by one. The member data points to the next<br>
	 * element. The member index is increased by sizeof(xcb_visualid_t)<br>
	 * Original signature : <code>void xcb_visualid_next(xcb_visualid_iterator_t*)</code><br>
	 * @param i <<br>
	 * <i>native declaration : xcb/xproto.h:3457</i>
	 */
	void xcb_visualid_next(xcb_visualid_iterator_t i);
	/**
	 * Return the iterator pointing to the last element<br>
	 * @param i An xcb_visualid_iterator_t<br>
	 * @return  The iterator pointing to the last element<br>
	 * Set the current element in the iterator to the last element.<br>
	 * The member rem is set to 0. The member data points to the<br>
	 * last element.<br>
	 * Original signature : <code>xcb_generic_iterator_t xcb_visualid_end(xcb_visualid_iterator_t)</code><br>
	 * @param i <<br>
	 * <i>native declaration : xcb/xproto.h:3468</i>
	 */
	xcb.xcb_generic_iterator_t.ByValue xcb_visualid_end(xcb_visualid_iterator_t.ByValue i);
	/**
	 * Get the next element of the iterator<br>
	 * @param i Pointer to a xcb_timestamp_iterator_t<br>
	 * Get the next element in the iterator. The member rem is<br>
	 * decreased by one. The member data points to the next<br>
	 * element. The member index is increased by sizeof(xcb_timestamp_t)<br>
	 * Original signature : <code>void xcb_timestamp_next(xcb_timestamp_iterator_t*)</code><br>
	 * @param i <<br>
	 * <i>native declaration : xcb/xproto.h:3478</i>
	 */
	void xcb_timestamp_next(xcb_timestamp_iterator_t i);
	/**
	 * Return the iterator pointing to the last element<br>
	 * @param i An xcb_timestamp_iterator_t<br>
	 * @return  The iterator pointing to the last element<br>
	 * Set the current element in the iterator to the last element.<br>
	 * The member rem is set to 0. The member data points to the<br>
	 * last element.<br>
	 * Original signature : <code>xcb_generic_iterator_t xcb_timestamp_end(xcb_timestamp_iterator_t)</code><br>
	 * @param i <<br>
	 * <i>native declaration : xcb/xproto.h:3489</i>
	 */
	xcb.xcb_generic_iterator_t.ByValue xcb_timestamp_end(xcb_timestamp_iterator_t.ByValue i);
	/**
	 * Get the next element of the iterator<br>
	 * @param i Pointer to a xcb_keysym_iterator_t<br>
	 * Get the next element in the iterator. The member rem is<br>
	 * decreased by one. The member data points to the next<br>
	 * element. The member index is increased by sizeof(xcb_keysym_t)<br>
	 * Original signature : <code>void xcb_keysym_next(xcb_keysym_iterator_t*)</code><br>
	 * @param i <<br>
	 * <i>native declaration : xcb/xproto.h:3499</i>
	 */
	void xcb_keysym_next(xcb_keysym_iterator_t i);
	/**
	 * Return the iterator pointing to the last element<br>
	 * @param i An xcb_keysym_iterator_t<br>
	 * @return  The iterator pointing to the last element<br>
	 * Set the current element in the iterator to the last element.<br>
	 * The member rem is set to 0. The member data points to the<br>
	 * last element.<br>
	 * Original signature : <code>xcb_generic_iterator_t xcb_keysym_end(xcb_keysym_iterator_t)</code><br>
	 * @param i <<br>
	 * <i>native declaration : xcb/xproto.h:3510</i>
	 */
	xcb.xcb_generic_iterator_t.ByValue xcb_keysym_end(xcb_keysym_iterator_t.ByValue i);
	/**
	 * Get the next element of the iterator<br>
	 * @param i Pointer to a xcb_keycode_iterator_t<br>
	 * Get the next element in the iterator. The member rem is<br>
	 * decreased by one. The member data points to the next<br>
	 * element. The member index is increased by sizeof(xcb_keycode_t)<br>
	 * Original signature : <code>void xcb_keycode_next(xcb_keycode_iterator_t*)</code><br>
	 * @param i <<br>
	 * <i>native declaration : xcb/xproto.h:3520</i>
	 */
	void xcb_keycode_next(xcb_keycode_iterator_t i);
	/**
	 * Return the iterator pointing to the last element<br>
	 * @param i An xcb_keycode_iterator_t<br>
	 * @return  The iterator pointing to the last element<br>
	 * Set the current element in the iterator to the last element.<br>
	 * The member rem is set to 0. The member data points to the<br>
	 * last element.<br>
	 * Original signature : <code>xcb_generic_iterator_t xcb_keycode_end(xcb_keycode_iterator_t)</code><br>
	 * @param i <<br>
	 * <i>native declaration : xcb/xproto.h:3531</i>
	 */
	xcb.xcb_generic_iterator_t.ByValue xcb_keycode_end(xcb_keycode_iterator_t.ByValue i);
	/**
	 * Get the next element of the iterator<br>
	 * @param i Pointer to a xcb_button_iterator_t<br>
	 * Get the next element in the iterator. The member rem is<br>
	 * decreased by one. The member data points to the next<br>
	 * element. The member index is increased by sizeof(xcb_button_t)<br>
	 * Original signature : <code>void xcb_button_next(xcb_button_iterator_t*)</code><br>
	 * @param i <<br>
	 * <i>native declaration : xcb/xproto.h:3541</i>
	 */
	void xcb_button_next(xcb_button_iterator_t i);
	/**
	 * Return the iterator pointing to the last element<br>
	 * @param i An xcb_button_iterator_t<br>
	 * @return  The iterator pointing to the last element<br>
	 * Set the current element in the iterator to the last element.<br>
	 * The member rem is set to 0. The member data points to the<br>
	 * last element.<br>
	 * Original signature : <code>xcb_generic_iterator_t xcb_button_end(xcb_button_iterator_t)</code><br>
	 * @param i <<br>
	 * <i>native declaration : xcb/xproto.h:3552</i>
	 */
	xcb.xcb_generic_iterator_t.ByValue xcb_button_end(xcb_button_iterator_t.ByValue i);
	/**
	 * Get the next element of the iterator<br>
	 * @param i Pointer to a xcb_point_iterator_t<br>
	 * Get the next element in the iterator. The member rem is<br>
	 * decreased by one. The member data points to the next<br>
	 * element. The member index is increased by sizeof(xcb_point_t)<br>
	 * Original signature : <code>void xcb_point_next(xcb_point_iterator_t*)</code><br>
	 * @param i <<br>
	 * <i>native declaration : xcb/xproto.h:3562</i>
	 */
	void xcb_point_next(xcb_point_iterator_t i);
	/**
	 * Return the iterator pointing to the last element<br>
	 * @param i An xcb_point_iterator_t<br>
	 * @return  The iterator pointing to the last element<br>
	 * Set the current element in the iterator to the last element.<br>
	 * The member rem is set to 0. The member data points to the<br>
	 * last element.<br>
	 * Original signature : <code>xcb_generic_iterator_t xcb_point_end(xcb_point_iterator_t)</code><br>
	 * @param i <<br>
	 * <i>native declaration : xcb/xproto.h:3573</i>
	 */
	xcb.xcb_generic_iterator_t.ByValue xcb_point_end(xcb_point_iterator_t.ByValue i);
	/**
	 * Get the next element of the iterator<br>
	 * @param i Pointer to a xcb_rectangle_iterator_t<br>
	 * Get the next element in the iterator. The member rem is<br>
	 * decreased by one. The member data points to the next<br>
	 * element. The member index is increased by sizeof(xcb_rectangle_t)<br>
	 * Original signature : <code>void xcb_rectangle_next(xcb_rectangle_iterator_t*)</code><br>
	 * @param i <<br>
	 * <i>native declaration : xcb/xproto.h:3583</i>
	 */
	void xcb_rectangle_next(xcb_rectangle_iterator_t i);
	/**
	 * Return the iterator pointing to the last element<br>
	 * @param i An xcb_rectangle_iterator_t<br>
	 * @return  The iterator pointing to the last element<br>
	 * Set the current element in the iterator to the last element.<br>
	 * The member rem is set to 0. The member data points to the<br>
	 * last element.<br>
	 * Original signature : <code>xcb_generic_iterator_t xcb_rectangle_end(xcb_rectangle_iterator_t)</code><br>
	 * @param i <<br>
	 * <i>native declaration : xcb/xproto.h:3594</i>
	 */
	xcb.xcb_generic_iterator_t.ByValue xcb_rectangle_end(xcb_rectangle_iterator_t.ByValue i);
	/**
	 * Get the next element of the iterator<br>
	 * @param i Pointer to a xcb_arc_iterator_t<br>
	 * Get the next element in the iterator. The member rem is<br>
	 * decreased by one. The member data points to the next<br>
	 * element. The member index is increased by sizeof(xcb_arc_t)<br>
	 * Original signature : <code>void xcb_arc_next(xcb_arc_iterator_t*)</code><br>
	 * @param i <<br>
	 * <i>native declaration : xcb/xproto.h:3604</i>
	 */
	void xcb_arc_next(xcb_arc_iterator_t i);
	/**
	 * Return the iterator pointing to the last element<br>
	 * @param i An xcb_arc_iterator_t<br>
	 * @return  The iterator pointing to the last element<br>
	 * Set the current element in the iterator to the last element.<br>
	 * The member rem is set to 0. The member data points to the<br>
	 * last element.<br>
	 * Original signature : <code>xcb_generic_iterator_t xcb_arc_end(xcb_arc_iterator_t)</code><br>
	 * @param i <<br>
	 * <i>native declaration : xcb/xproto.h:3615</i>
	 */
	xcb.xcb_generic_iterator_t.ByValue xcb_arc_end(xcb_arc_iterator_t.ByValue i);
	/**
	 * Get the next element of the iterator<br>
	 * @param i Pointer to a xcb_format_iterator_t<br>
	 * Get the next element in the iterator. The member rem is<br>
	 * decreased by one. The member data points to the next<br>
	 * element. The member index is increased by sizeof(xcb_format_t)<br>
	 * Original signature : <code>void xcb_format_next(xcb_format_iterator_t*)</code><br>
	 * @param i <<br>
	 * <i>native declaration : xcb/xproto.h:3625</i>
	 */
	void xcb_format_next(xcb_format_iterator_t i);
	/**
	 * Return the iterator pointing to the last element<br>
	 * @param i An xcb_format_iterator_t<br>
	 * @return  The iterator pointing to the last element<br>
	 * Set the current element in the iterator to the last element.<br>
	 * The member rem is set to 0. The member data points to the<br>
	 * last element.<br>
	 * Original signature : <code>xcb_generic_iterator_t xcb_format_end(xcb_format_iterator_t)</code><br>
	 * @param i <<br>
	 * <i>native declaration : xcb/xproto.h:3636</i>
	 */
	xcb.xcb_generic_iterator_t.ByValue xcb_format_end(xcb_format_iterator_t.ByValue i);
	/**
	 * Get the next element of the iterator<br>
	 * @param i Pointer to a xcb_visualtype_iterator_t<br>
	 * Get the next element in the iterator. The member rem is<br>
	 * decreased by one. The member data points to the next<br>
	 * element. The member index is increased by sizeof(xcb_visualtype_t)<br>
	 * Original signature : <code>void xcb_visualtype_next(xcb_visualtype_iterator_t*)</code><br>
	 * @param i <<br>
	 * <i>native declaration : xcb/xproto.h:3646</i>
	 */
	void xcb_visualtype_next(xcb_visualtype_iterator_t i);
	/**
	 * Return the iterator pointing to the last element<br>
	 * @param i An xcb_visualtype_iterator_t<br>
	 * @return  The iterator pointing to the last element<br>
	 * Set the current element in the iterator to the last element.<br>
	 * The member rem is set to 0. The member data points to the<br>
	 * last element.<br>
	 * Original signature : <code>xcb_generic_iterator_t xcb_visualtype_end(xcb_visualtype_iterator_t)</code><br>
	 * @param i <<br>
	 * <i>native declaration : xcb/xproto.h:3657</i>
	 */
	xcb.xcb_generic_iterator_t.ByValue xcb_visualtype_end(xcb_visualtype_iterator_t.ByValue i);
	/**
	 * Original signature : <code>int xcb_depth_sizeof(const void*)</code><br>
	 * @param _buffer <<br>
	 * <i>native declaration : xcb/xproto.h:3662</i>
	 */
	int xcb_depth_sizeof(Pointer _buffer);
	/**
	 * Original signature : <code>xcb_visualtype_t* xcb_depth_visuals(const xcb_depth_t*)</code><br>
	 * @param R <<br>
	 * <i>native declaration : xcb/xproto.h:3667</i>
	 */
	xcb_visualtype_t xcb_depth_visuals(xcb_depth_t R);
	/**
	 * Original signature : <code>int xcb_depth_visuals_length(const xcb_depth_t*)</code><br>
	 * @param R <<br>
	 * <i>native declaration : xcb/xproto.h:3672</i>
	 */
	int xcb_depth_visuals_length(xcb_depth_t R);
	/**
	 * Original signature : <code>xcb_visualtype_iterator_t xcb_depth_visuals_iterator(const xcb_depth_t*)</code><br>
	 * @param R <<br>
	 * <i>native declaration : xcb/xproto.h:3677</i>
	 */
	xcb_visualtype_iterator_t.ByValue xcb_depth_visuals_iterator(xcb_depth_t R);
	/**
	 * Get the next element of the iterator<br>
	 * @param i Pointer to a xcb_depth_iterator_t<br>
	 * Get the next element in the iterator. The member rem is<br>
	 * decreased by one. The member data points to the next<br>
	 * element. The member index is increased by sizeof(xcb_depth_t)<br>
	 * Original signature : <code>void xcb_depth_next(xcb_depth_iterator_t*)</code><br>
	 * @param i <<br>
	 * <i>native declaration : xcb/xproto.h:3687</i>
	 */
	void xcb_depth_next(xcb_depth_iterator_t i);
	/**
	 * Return the iterator pointing to the last element<br>
	 * @param i An xcb_depth_iterator_t<br>
	 * @return  The iterator pointing to the last element<br>
	 * Set the current element in the iterator to the last element.<br>
	 * The member rem is set to 0. The member data points to the<br>
	 * last element.<br>
	 * Original signature : <code>xcb_generic_iterator_t xcb_depth_end(xcb_depth_iterator_t)</code><br>
	 * @param i <<br>
	 * <i>native declaration : xcb/xproto.h:3698</i>
	 */
	xcb.xcb_generic_iterator_t.ByValue xcb_depth_end(xcb_depth_iterator_t.ByValue i);
	/**
	 * Original signature : <code>int xcb_screen_sizeof(const void*)</code><br>
	 * @param _buffer <<br>
	 * <i>native declaration : xcb/xproto.h:3703</i>
	 */
	int xcb_screen_sizeof(Pointer _buffer);
	/**
	 * Original signature : <code>int xcb_screen_allowed_depths_length(const xcb_screen_t*)</code><br>
	 * @param R <<br>
	 * <i>native declaration : xcb/xproto.h:3708</i>
	 */
	int xcb_screen_allowed_depths_length(xcb_screen_t R);
	/**
	 * Original signature : <code>xcb_depth_iterator_t xcb_screen_allowed_depths_iterator(const xcb_screen_t*)</code><br>
	 * @param R <<br>
	 * <i>native declaration : xcb/xproto.h:3713</i>
	 */
	xcb_depth_iterator_t.ByValue xcb_screen_allowed_depths_iterator(xcb_screen_t R);
	/**
	 * Get the next element of the iterator<br>
	 * @param i Pointer to a xcb_screen_iterator_t<br>
	 * Get the next element in the iterator. The member rem is<br>
	 * decreased by one. The member data points to the next<br>
	 * element. The member index is increased by sizeof(xcb_screen_t)<br>
	 * Original signature : <code>void xcb_screen_next(xcb_screen_iterator_t*)</code><br>
	 * @param i <<br>
	 * <i>native declaration : xcb/xproto.h:3723</i>
	 */
	void xcb_screen_next(xcb_screen_iterator_t i);
	/**
	 * Return the iterator pointing to the last element<br>
	 * @param i An xcb_screen_iterator_t<br>
	 * @return  The iterator pointing to the last element<br>
	 * Set the current element in the iterator to the last element.<br>
	 * The member rem is set to 0. The member data points to the<br>
	 * last element.<br>
	 * Original signature : <code>xcb_generic_iterator_t xcb_screen_end(xcb_screen_iterator_t)</code><br>
	 * @param i <<br>
	 * <i>native declaration : xcb/xproto.h:3734</i>
	 */
	xcb.xcb_generic_iterator_t.ByValue xcb_screen_end(xcb_screen_iterator_t.ByValue i);
	/**
	 * Original signature : <code>int xcb_setup_request_sizeof(const void*)</code><br>
	 * @param _buffer <<br>
	 * <i>native declaration : xcb/xproto.h:3739</i>
	 */
	int xcb_setup_request_sizeof(Pointer _buffer);
	/**
	 * Original signature : <code>char* xcb_setup_request_authorization_protocol_name(const xcb_setup_request_t*)</code><br>
	 * @param R <<br>
	 * <i>native declaration : xcb/xproto.h:3744</i>
	 */
	Pointer xcb_setup_request_authorization_protocol_name(xcb_setup_request_t R);
	/**
	 * Original signature : <code>int xcb_setup_request_authorization_protocol_name_length(const xcb_setup_request_t*)</code><br>
	 * @param R <<br>
	 * <i>native declaration : xcb/xproto.h:3749</i>
	 */
	int xcb_setup_request_authorization_protocol_name_length(xcb_setup_request_t R);
	/**
	 * Original signature : <code>xcb_generic_iterator_t xcb_setup_request_authorization_protocol_name_end(const xcb_setup_request_t*)</code><br>
	 * @param R <<br>
	 * <i>native declaration : xcb/xproto.h:3754</i>
	 */
	xcb.xcb_generic_iterator_t.ByValue xcb_setup_request_authorization_protocol_name_end(xcb_setup_request_t R);
	/**
	 * Original signature : <code>char* xcb_setup_request_authorization_protocol_data(const xcb_setup_request_t*)</code><br>
	 * @param R <<br>
	 * <i>native declaration : xcb/xproto.h:3759</i>
	 */
	Pointer xcb_setup_request_authorization_protocol_data(xcb_setup_request_t R);
	/**
	 * Original signature : <code>int xcb_setup_request_authorization_protocol_data_length(const xcb_setup_request_t*)</code><br>
	 * @param R <<br>
	 * <i>native declaration : xcb/xproto.h:3764</i>
	 */
	int xcb_setup_request_authorization_protocol_data_length(xcb_setup_request_t R);
	/**
	 * Original signature : <code>xcb_generic_iterator_t xcb_setup_request_authorization_protocol_data_end(const xcb_setup_request_t*)</code><br>
	 * @param R <<br>
	 * <i>native declaration : xcb/xproto.h:3769</i>
	 */
	xcb.xcb_generic_iterator_t.ByValue xcb_setup_request_authorization_protocol_data_end(xcb_setup_request_t R);
	/**
	 * Get the next element of the iterator<br>
	 * @param i Pointer to a xcb_setup_request_iterator_t<br>
	 * Get the next element in the iterator. The member rem is<br>
	 * decreased by one. The member data points to the next<br>
	 * element. The member index is increased by sizeof(xcb_setup_request_t)<br>
	 * Original signature : <code>void xcb_setup_request_next(xcb_setup_request_iterator_t*)</code><br>
	 * @param i <<br>
	 * <i>native declaration : xcb/xproto.h:3779</i>
	 */
	void xcb_setup_request_next(xcb_setup_request_iterator_t i);
	/**
	 * Return the iterator pointing to the last element<br>
	 * @param i An xcb_setup_request_iterator_t<br>
	 * @return  The iterator pointing to the last element<br>
	 * Set the current element in the iterator to the last element.<br>
	 * The member rem is set to 0. The member data points to the<br>
	 * last element.<br>
	 * Original signature : <code>xcb_generic_iterator_t xcb_setup_request_end(xcb_setup_request_iterator_t)</code><br>
	 * @param i <<br>
	 * <i>native declaration : xcb/xproto.h:3790</i>
	 */
	xcb.xcb_generic_iterator_t.ByValue xcb_setup_request_end(xcb_setup_request_iterator_t.ByValue i);
	/**
	 * Original signature : <code>int xcb_setup_failed_sizeof(const void*)</code><br>
	 * @param _buffer <<br>
	 * <i>native declaration : xcb/xproto.h:3795</i>
	 */
	int xcb_setup_failed_sizeof(Pointer _buffer);
	/**
	 * Original signature : <code>char* xcb_setup_failed_reason(const xcb_setup_failed_t*)</code><br>
	 * @param R <<br>
	 * <i>native declaration : xcb/xproto.h:3800</i>
	 */
	Pointer xcb_setup_failed_reason(xcb_setup_failed_t R);
	/**
	 * Original signature : <code>int xcb_setup_failed_reason_length(const xcb_setup_failed_t*)</code><br>
	 * @param R <<br>
	 * <i>native declaration : xcb/xproto.h:3805</i>
	 */
	int xcb_setup_failed_reason_length(xcb_setup_failed_t R);
	/**
	 * Original signature : <code>xcb_generic_iterator_t xcb_setup_failed_reason_end(const xcb_setup_failed_t*)</code><br>
	 * @param R <<br>
	 * <i>native declaration : xcb/xproto.h:3810</i>
	 */
	xcb.xcb_generic_iterator_t.ByValue xcb_setup_failed_reason_end(xcb_setup_failed_t R);
	/**
	 * Get the next element of the iterator<br>
	 * @param i Pointer to a xcb_setup_failed_iterator_t<br>
	 * Get the next element in the iterator. The member rem is<br>
	 * decreased by one. The member data points to the next<br>
	 * element. The member index is increased by sizeof(xcb_setup_failed_t)<br>
	 * Original signature : <code>void xcb_setup_failed_next(xcb_setup_failed_iterator_t*)</code><br>
	 * @param i <<br>
	 * <i>native declaration : xcb/xproto.h:3820</i>
	 */
	void xcb_setup_failed_next(xcb_setup_failed_iterator_t i);
	/**
	 * Return the iterator pointing to the last element<br>
	 * @param i An xcb_setup_failed_iterator_t<br>
	 * @return  The iterator pointing to the last element<br>
	 * Set the current element in the iterator to the last element.<br>
	 * The member rem is set to 0. The member data points to the<br>
	 * last element.<br>
	 * Original signature : <code>xcb_generic_iterator_t xcb_setup_failed_end(xcb_setup_failed_iterator_t)</code><br>
	 * @param i <<br>
	 * <i>native declaration : xcb/xproto.h:3831</i>
	 */
	xcb.xcb_generic_iterator_t.ByValue xcb_setup_failed_end(xcb_setup_failed_iterator_t.ByValue i);
	/**
	 * Original signature : <code>int xcb_setup_authenticate_sizeof(const void*)</code><br>
	 * @param _buffer <<br>
	 * <i>native declaration : xcb/xproto.h:3836</i>
	 */
	int xcb_setup_authenticate_sizeof(Pointer _buffer);
	/**
	 * Original signature : <code>char* xcb_setup_authenticate_reason(const xcb_setup_authenticate_t*)</code><br>
	 * @param R <<br>
	 * <i>native declaration : xcb/xproto.h:3841</i>
	 */
	Pointer xcb_setup_authenticate_reason(xcb_setup_authenticate_t R);
	/**
	 * Original signature : <code>int xcb_setup_authenticate_reason_length(const xcb_setup_authenticate_t*)</code><br>
	 * @param R <<br>
	 * <i>native declaration : xcb/xproto.h:3846</i>
	 */
	int xcb_setup_authenticate_reason_length(xcb_setup_authenticate_t R);
	/**
	 * Original signature : <code>xcb_generic_iterator_t xcb_setup_authenticate_reason_end(const xcb_setup_authenticate_t*)</code><br>
	 * @param R <<br>
	 * <i>native declaration : xcb/xproto.h:3851</i>
	 */
	xcb.xcb_generic_iterator_t.ByValue xcb_setup_authenticate_reason_end(xcb_setup_authenticate_t R);
	/**
	 * Get the next element of the iterator<br>
	 * @param i Pointer to a xcb_setup_authenticate_iterator_t<br>
	 * Get the next element in the iterator. The member rem is<br>
	 * decreased by one. The member data points to the next<br>
	 * element. The member index is increased by sizeof(xcb_setup_authenticate_t)<br>
	 * Original signature : <code>void xcb_setup_authenticate_next(xcb_setup_authenticate_iterator_t*)</code><br>
	 * @param i <<br>
	 * <i>native declaration : xcb/xproto.h:3861</i>
	 */
	void xcb_setup_authenticate_next(xcb_setup_authenticate_iterator_t i);
	/**
	 * Return the iterator pointing to the last element<br>
	 * @param i An xcb_setup_authenticate_iterator_t<br>
	 * @return  The iterator pointing to the last element<br>
	 * Set the current element in the iterator to the last element.<br>
	 * The member rem is set to 0. The member data points to the<br>
	 * last element.<br>
	 * Original signature : <code>xcb_generic_iterator_t xcb_setup_authenticate_end(xcb_setup_authenticate_iterator_t)</code><br>
	 * @param i <<br>
	 * <i>native declaration : xcb/xproto.h:3872</i>
	 */
	xcb.xcb_generic_iterator_t.ByValue xcb_setup_authenticate_end(xcb_setup_authenticate_iterator_t.ByValue i);
	/**
	 * Original signature : <code>int xcb_setup_sizeof(const void*)</code><br>
	 * @param _buffer <<br>
	 * <i>native declaration : xcb/xproto.h:3877</i>
	 */
	int xcb_setup_sizeof(Pointer _buffer);
	/**
	 * Original signature : <code>char* xcb_setup_vendor(const xcb_setup_t*)</code><br>
	 * @param R <<br>
	 * <i>native declaration : xcb/xproto.h:3882</i>
	 */
	Pointer xcb_setup_vendor(xcb_setup_t R);
	/**
	 * Original signature : <code>int xcb_setup_vendor_length(const xcb_setup_t*)</code><br>
	 * @param R <<br>
	 * <i>native declaration : xcb/xproto.h:3887</i>
	 */
	int xcb_setup_vendor_length(xcb_setup_t R);
	/**
	 * Original signature : <code>xcb_generic_iterator_t xcb_setup_vendor_end(const xcb_setup_t*)</code><br>
	 * @param R <<br>
	 * <i>native declaration : xcb/xproto.h:3892</i>
	 */
	xcb.xcb_generic_iterator_t.ByValue xcb_setup_vendor_end(xcb_setup_t R);
	/**
	 * Original signature : <code>xcb_format_t* xcb_setup_pixmap_formats(const xcb_setup_t*)</code><br>
	 * @param R <<br>
	 * <i>native declaration : xcb/xproto.h:3897</i>
	 */
	xcb_format_t xcb_setup_pixmap_formats(xcb_setup_t R);
	/**
	 * Original signature : <code>int xcb_setup_pixmap_formats_length(const xcb_setup_t*)</code><br>
	 * @param R <<br>
	 * <i>native declaration : xcb/xproto.h:3902</i>
	 */
	int xcb_setup_pixmap_formats_length(xcb_setup_t R);
	/**
	 * Original signature : <code>xcb_format_iterator_t xcb_setup_pixmap_formats_iterator(const xcb_setup_t*)</code><br>
	 * @param R <<br>
	 * <i>native declaration : xcb/xproto.h:3907</i>
	 */
	xcb_format_iterator_t.ByValue xcb_setup_pixmap_formats_iterator(xcb_setup_t R);
	/**
	 * Original signature : <code>int xcb_setup_roots_length(const xcb_setup_t*)</code><br>
	 * @param R <<br>
	 * <i>native declaration : xcb/xproto.h:3912</i>
	 */
	int xcb_setup_roots_length(xcb_setup_t R);
	/**
	 * Original signature : <code>xcb_screen_iterator_t xcb_setup_roots_iterator(const xcb_setup_t*)</code><br>
	 * @param R <<br>
	 * <i>native declaration : xcb/xproto.h:3917</i>
	 */
	xcb_screen_iterator_t.ByValue xcb_setup_roots_iterator(xcb_setup_t R);
	/**
	 * Get the next element of the iterator<br>
	 * @param i Pointer to a xcb_setup_iterator_t<br>
	 * Get the next element in the iterator. The member rem is<br>
	 * decreased by one. The member data points to the next<br>
	 * element. The member index is increased by sizeof(xcb_setup_t)<br>
	 * Original signature : <code>void xcb_setup_next(xcb_setup_iterator_t*)</code><br>
	 * @param i <<br>
	 * <i>native declaration : xcb/xproto.h:3927</i>
	 */
	void xcb_setup_next(xcb_setup_iterator_t i);
	/**
	 * Return the iterator pointing to the last element<br>
	 * @param i An xcb_setup_iterator_t<br>
	 * @return  The iterator pointing to the last element<br>
	 * Set the current element in the iterator to the last element.<br>
	 * The member rem is set to 0. The member data points to the<br>
	 * last element.<br>
	 * Original signature : <code>xcb_generic_iterator_t xcb_setup_end(xcb_setup_iterator_t)</code><br>
	 * @param i <<br>
	 * <i>native declaration : xcb/xproto.h:3938</i>
	 */
	xcb.xcb_generic_iterator_t.ByValue xcb_setup_end(xcb_setup_iterator_t.ByValue i);
	/**
	 * Get the next element of the iterator<br>
	 * @param i Pointer to a xcb_client_message_data_iterator_t<br>
	 * Get the next element in the iterator. The member rem is<br>
	 * decreased by one. The member data points to the next<br>
	 * element. The member index is increased by sizeof(xcb_client_message_data_t)<br>
	 * Original signature : <code>void xcb_client_message_data_next(xcb_client_message_data_iterator_t*)</code><br>
	 * @param i <<br>
	 * <i>native declaration : xcb/xproto.h:3948</i>
	 */
	void xcb_client_message_data_next(xcb_client_message_data_iterator_t i);
	/**
	 * Return the iterator pointing to the last element<br>
	 * @param i An xcb_client_message_data_iterator_t<br>
	 * @return  The iterator pointing to the last element<br>
	 * Set the current element in the iterator to the last element.<br>
	 * The member rem is set to 0. The member data points to the<br>
	 * last element.<br>
	 * Original signature : <code>xcb_generic_iterator_t xcb_client_message_data_end(xcb_client_message_data_iterator_t)</code><br>
	 * @param i <<br>
	 * <i>native declaration : xcb/xproto.h:3959</i>
	 */
	xcb.xcb_generic_iterator_t.ByValue xcb_client_message_data_end(xcb_client_message_data_iterator_t.ByValue i);
	/**
	 * Original signature : <code>int xcb_create_window_sizeof(const void*)</code><br>
	 * @param _buffer <<br>
	 * <i>native declaration : xcb/xproto.h:3964</i>
	 */
	int xcb_create_window_sizeof(Pointer _buffer);
	/**
	 * @brief Creates a window<br>
	 * @param c The connection<br>
	 * @param depth Specifies the new window's depth (TODO: what unit?).<br>
	 * \n<br>
	 * The special value `XCB_COPY_FROM_PARENT` means the depth is taken from the<br>
	 * \a parent window.<br>
	 * @param wid The ID with which you will refer to the new window, created by<br>
	 * `xcb_generate_id`.<br>
	 * @param parent The parent window of the new window.<br>
	 * @param x The X coordinate of the new window.<br>
	 * @param y The Y coordinate of the new window.<br>
	 * @param width The width of the new window.<br>
	 * @param height The height of the new window.<br>
	 * @param border_width TODO:<br>
	 * \n<br>
	 * Must be zero if the `class` is `InputOnly` or a `xcb_match_error_t` occurs.<br>
	 * @param _class A bitmask of #xcb_window_class_t values.<br>
	 * @param _class \n<br>
	 * @param visual Specifies the id for the new window's visual.<br>
	 * \n<br>
	 * The special value `XCB_COPY_FROM_PARENT` means the visual is taken from the<br>
	 * \a parent window.<br>
	 * @param value_mask A bitmask of #xcb_cw_t values.<br>
	 * @return A cookie<br>
	 * Creates an unmapped window as child of the specified \a parent window. A<br>
	 * CreateNotify event will be generated. The new window is placed on top in the<br>
	 * stacking order with respect to siblings.<br>
	 * <br>
	 * The coordinate system has the X axis horizontal and the Y axis vertical with<br>
	 * the origin [0, 0] at the upper-left corner. Coordinates are integral, in terms<br>
	 * of pixels, and coincide with pixel centers. Each window and pixmap has its own<br>
	 * coordinate system. For a window, the origin is inside the border at the inside,<br>
	 * upper-left corner.<br>
	 * <br>
	 * The created window is not yet displayed (mapped), call `xcb_map_window` to<br>
	 * display it.<br>
	 * <br>
	 * The created window will initially use the same cursor as its parent.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_create_window_checked(xcb_connection_t*, uint8_t, xcb_window_t, xcb_window_t, int16_t, int16_t, uint16_t, uint16_t, uint16_t, uint16_t, xcb_visualid_t, uint32_t, const uint32_t*)</code><br>
	 * @param c <<br>
	 * @param depth <<br>
	 * @param wid <<br>
	 * @param parent <<br>
	 * @param x <<br>
	 * @param y <<br>
	 * @param width <<br>
	 * @param height <<br>
	 * @param border_width <<br>
	 * @param _class <<br>
	 * @param visual <<br>
	 * @param value_mask <<br>
	 * @param value_list <<br>
	 * <i>native declaration : xcb/xproto.h:4022</i><br>
	 * @deprecated use the safer methods {@link #xcb_create_window_checked(com.sun.jna.ptr.PointerByReference, byte, int, int, short, short, short, short, short, short, int, int, int[])} and {@link #xcb_create_window_checked(com.sun.jna.ptr.PointerByReference, byte, int, int, short, short, short, short, short, short, int, int, com.sun.jna.ptr.IntByReference)} instead
	 */
	@Deprecated 
	xcb.xcb_void_cookie_t.ByValue xcb_create_window_checked(Pointer c, byte depth, int wid, int parent, short x, short y, short width, short height, short border_width, short _class, int visual, int value_mask, IntByReference value_list);
	/**
	 * @brief Creates a window<br>
	 * @param c The connection<br>
	 * @param depth Specifies the new window's depth (TODO: what unit?).<br>
	 * \n<br>
	 * The special value `XCB_COPY_FROM_PARENT` means the depth is taken from the<br>
	 * \a parent window.<br>
	 * @param wid The ID with which you will refer to the new window, created by<br>
	 * `xcb_generate_id`.<br>
	 * @param parent The parent window of the new window.<br>
	 * @param x The X coordinate of the new window.<br>
	 * @param y The Y coordinate of the new window.<br>
	 * @param width The width of the new window.<br>
	 * @param height The height of the new window.<br>
	 * @param border_width TODO:<br>
	 * \n<br>
	 * Must be zero if the `class` is `InputOnly` or a `xcb_match_error_t` occurs.<br>
	 * @param _class A bitmask of #xcb_window_class_t values.<br>
	 * @param _class \n<br>
	 * @param visual Specifies the id for the new window's visual.<br>
	 * \n<br>
	 * The special value `XCB_COPY_FROM_PARENT` means the visual is taken from the<br>
	 * \a parent window.<br>
	 * @param value_mask A bitmask of #xcb_cw_t values.<br>
	 * @return A cookie<br>
	 * Creates an unmapped window as child of the specified \a parent window. A<br>
	 * CreateNotify event will be generated. The new window is placed on top in the<br>
	 * stacking order with respect to siblings.<br>
	 * <br>
	 * The coordinate system has the X axis horizontal and the Y axis vertical with<br>
	 * the origin [0, 0] at the upper-left corner. Coordinates are integral, in terms<br>
	 * of pixels, and coincide with pixel centers. Each window and pixmap has its own<br>
	 * coordinate system. For a window, the origin is inside the border at the inside,<br>
	 * upper-left corner.<br>
	 * <br>
	 * The created window is not yet displayed (mapped), call `xcb_map_window` to<br>
	 * display it.<br>
	 * <br>
	 * The created window will initially use the same cursor as its parent.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_create_window_checked(xcb_connection_t*, uint8_t, xcb_window_t, xcb_window_t, int16_t, int16_t, uint16_t, uint16_t, uint16_t, uint16_t, xcb_visualid_t, uint32_t, const uint32_t*)</code><br>
	 * @param c <<br>
	 * @param depth <<br>
	 * @param wid <<br>
	 * @param parent <<br>
	 * @param x <<br>
	 * @param y <<br>
	 * @param width <<br>
	 * @param height <<br>
	 * @param border_width <<br>
	 * @param _class <<br>
	 * @param visual <<br>
	 * @param value_mask <<br>
	 * @param value_list <<br>
	 * <i>native declaration : xcb/xproto.h:4022</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_create_window_checked(PointerByReference c, byte depth, int wid, int parent, short x, short y, short width, short height, short border_width, short _class, int visual, int value_mask, int value_list[]);
	/**
	 * @brief Creates a window<br>
	 * @param c The connection<br>
	 * @param depth Specifies the new window's depth (TODO: what unit?).<br>
	 * \n<br>
	 * The special value `XCB_COPY_FROM_PARENT` means the depth is taken from the<br>
	 * \a parent window.<br>
	 * @param wid The ID with which you will refer to the new window, created by<br>
	 * `xcb_generate_id`.<br>
	 * @param parent The parent window of the new window.<br>
	 * @param x The X coordinate of the new window.<br>
	 * @param y The Y coordinate of the new window.<br>
	 * @param width The width of the new window.<br>
	 * @param height The height of the new window.<br>
	 * @param border_width TODO:<br>
	 * \n<br>
	 * Must be zero if the `class` is `InputOnly` or a `xcb_match_error_t` occurs.<br>
	 * @param _class A bitmask of #xcb_window_class_t values.<br>
	 * @param _class \n<br>
	 * @param visual Specifies the id for the new window's visual.<br>
	 * \n<br>
	 * The special value `XCB_COPY_FROM_PARENT` means the visual is taken from the<br>
	 * \a parent window.<br>
	 * @param value_mask A bitmask of #xcb_cw_t values.<br>
	 * @return A cookie<br>
	 * Creates an unmapped window as child of the specified \a parent window. A<br>
	 * CreateNotify event will be generated. The new window is placed on top in the<br>
	 * stacking order with respect to siblings.<br>
	 * <br>
	 * The coordinate system has the X axis horizontal and the Y axis vertical with<br>
	 * the origin [0, 0] at the upper-left corner. Coordinates are integral, in terms<br>
	 * of pixels, and coincide with pixel centers. Each window and pixmap has its own<br>
	 * coordinate system. For a window, the origin is inside the border at the inside,<br>
	 * upper-left corner.<br>
	 * <br>
	 * The created window is not yet displayed (mapped), call `xcb_map_window` to<br>
	 * display it.<br>
	 * <br>
	 * The created window will initially use the same cursor as its parent.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_create_window_checked(xcb_connection_t*, uint8_t, xcb_window_t, xcb_window_t, int16_t, int16_t, uint16_t, uint16_t, uint16_t, uint16_t, xcb_visualid_t, uint32_t, const uint32_t*)</code><br>
	 * @param c <<br>
	 * @param depth <<br>
	 * @param wid <<br>
	 * @param parent <<br>
	 * @param x <<br>
	 * @param y <<br>
	 * @param width <<br>
	 * @param height <<br>
	 * @param border_width <<br>
	 * @param _class <<br>
	 * @param visual <<br>
	 * @param value_mask <<br>
	 * @param value_list <<br>
	 * <i>native declaration : xcb/xproto.h:4022</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_create_window_checked(PointerByReference c, byte depth, int wid, int parent, short x, short y, short width, short height, short border_width, short _class, int visual, int value_mask, IntByReference value_list);
	/**
	 * @brief Creates a window<br>
	 * @param c The connection<br>
	 * @param depth Specifies the new window's depth (TODO: what unit?).<br>
	 * \n<br>
	 * The special value `XCB_COPY_FROM_PARENT` means the depth is taken from the<br>
	 * \a parent window.<br>
	 * @param wid The ID with which you will refer to the new window, created by<br>
	 * `xcb_generate_id`.<br>
	 * @param parent The parent window of the new window.<br>
	 * @param x The X coordinate of the new window.<br>
	 * @param y The Y coordinate of the new window.<br>
	 * @param width The width of the new window.<br>
	 * @param height The height of the new window.<br>
	 * @param border_width TODO:<br>
	 * \n<br>
	 * Must be zero if the `class` is `InputOnly` or a `xcb_match_error_t` occurs.<br>
	 * @param _class A bitmask of #xcb_window_class_t values.<br>
	 * @param _class \n<br>
	 * @param visual Specifies the id for the new window's visual.<br>
	 * \n<br>
	 * The special value `XCB_COPY_FROM_PARENT` means the visual is taken from the<br>
	 * \a parent window.<br>
	 * @param value_mask A bitmask of #xcb_cw_t values.<br>
	 * @return A cookie<br>
	 * Creates an unmapped window as child of the specified \a parent window. A<br>
	 * CreateNotify event will be generated. The new window is placed on top in the<br>
	 * stacking order with respect to siblings.<br>
	 * <br>
	 * The coordinate system has the X axis horizontal and the Y axis vertical with<br>
	 * the origin [0, 0] at the upper-left corner. Coordinates are integral, in terms<br>
	 * of pixels, and coincide with pixel centers. Each window and pixmap has its own<br>
	 * coordinate system. For a window, the origin is inside the border at the inside,<br>
	 * upper-left corner.<br>
	 * <br>
	 * The created window is not yet displayed (mapped), call `xcb_map_window` to<br>
	 * display it.<br>
	 * <br>
	 * The created window will initially use the same cursor as its parent.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_create_window(xcb_connection_t*, uint8_t, xcb_window_t, xcb_window_t, int16_t, int16_t, uint16_t, uint16_t, uint16_t, uint16_t, xcb_visualid_t, uint32_t, const uint32_t*)</code><br>
	 * @param c <<br>
	 * @param depth <<br>
	 * @param wid <<br>
	 * @param parent <<br>
	 * @param x <<br>
	 * @param y <<br>
	 * @param width <<br>
	 * @param height <<br>
	 * @param border_width <<br>
	 * @param _class <<br>
	 * @param visual <<br>
	 * @param value_mask <<br>
	 * @param value_list <<br>
	 * <i>native declaration : xcb/xproto.h:4077</i><br>
	 * @deprecated use the safer methods {@link #xcb_create_window(com.sun.jna.ptr.PointerByReference, byte, int, int, short, short, short, short, short, short, int, int, int[])} and {@link #xcb_create_window(com.sun.jna.ptr.PointerByReference, byte, int, int, short, short, short, short, short, short, int, int, com.sun.jna.ptr.IntByReference)} instead
	 */
	@Deprecated 
	xcb.xcb_void_cookie_t.ByValue xcb_create_window(Pointer c, byte depth, int wid, int parent, short x, short y, short width, short height, short border_width, short _class, int visual, int value_mask, IntByReference value_list);
	/**
	 * @brief Creates a window<br>
	 * @param c The connection<br>
	 * @param depth Specifies the new window's depth (TODO: what unit?).<br>
	 * \n<br>
	 * The special value `XCB_COPY_FROM_PARENT` means the depth is taken from the<br>
	 * \a parent window.<br>
	 * @param wid The ID with which you will refer to the new window, created by<br>
	 * `xcb_generate_id`.<br>
	 * @param parent The parent window of the new window.<br>
	 * @param x The X coordinate of the new window.<br>
	 * @param y The Y coordinate of the new window.<br>
	 * @param width The width of the new window.<br>
	 * @param height The height of the new window.<br>
	 * @param border_width TODO:<br>
	 * \n<br>
	 * Must be zero if the `class` is `InputOnly` or a `xcb_match_error_t` occurs.<br>
	 * @param _class A bitmask of #xcb_window_class_t values.<br>
	 * @param _class \n<br>
	 * @param visual Specifies the id for the new window's visual.<br>
	 * \n<br>
	 * The special value `XCB_COPY_FROM_PARENT` means the visual is taken from the<br>
	 * \a parent window.<br>
	 * @param value_mask A bitmask of #xcb_cw_t values.<br>
	 * @return A cookie<br>
	 * Creates an unmapped window as child of the specified \a parent window. A<br>
	 * CreateNotify event will be generated. The new window is placed on top in the<br>
	 * stacking order with respect to siblings.<br>
	 * <br>
	 * The coordinate system has the X axis horizontal and the Y axis vertical with<br>
	 * the origin [0, 0] at the upper-left corner. Coordinates are integral, in terms<br>
	 * of pixels, and coincide with pixel centers. Each window and pixmap has its own<br>
	 * coordinate system. For a window, the origin is inside the border at the inside,<br>
	 * upper-left corner.<br>
	 * <br>
	 * The created window is not yet displayed (mapped), call `xcb_map_window` to<br>
	 * display it.<br>
	 * <br>
	 * The created window will initially use the same cursor as its parent.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_create_window(xcb_connection_t*, uint8_t, xcb_window_t, xcb_window_t, int16_t, int16_t, uint16_t, uint16_t, uint16_t, uint16_t, xcb_visualid_t, uint32_t, const uint32_t*)</code><br>
	 * @param c <<br>
	 * @param depth <<br>
	 * @param wid <<br>
	 * @param parent <<br>
	 * @param x <<br>
	 * @param y <<br>
	 * @param width <<br>
	 * @param height <<br>
	 * @param border_width <<br>
	 * @param _class <<br>
	 * @param visual <<br>
	 * @param value_mask <<br>
	 * @param value_list <<br>
	 * <i>native declaration : xcb/xproto.h:4077</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_create_window(PointerByReference c, byte depth, int wid, int parent, short x, short y, short width, short height, short border_width, short _class, int visual, int value_mask, int value_list[]);
	/**
	 * @brief Creates a window<br>
	 * @param c The connection<br>
	 * @param depth Specifies the new window's depth (TODO: what unit?).<br>
	 * \n<br>
	 * The special value `XCB_COPY_FROM_PARENT` means the depth is taken from the<br>
	 * \a parent window.<br>
	 * @param wid The ID with which you will refer to the new window, created by<br>
	 * `xcb_generate_id`.<br>
	 * @param parent The parent window of the new window.<br>
	 * @param x The X coordinate of the new window.<br>
	 * @param y The Y coordinate of the new window.<br>
	 * @param width The width of the new window.<br>
	 * @param height The height of the new window.<br>
	 * @param border_width TODO:<br>
	 * \n<br>
	 * Must be zero if the `class` is `InputOnly` or a `xcb_match_error_t` occurs.<br>
	 * @param _class A bitmask of #xcb_window_class_t values.<br>
	 * @param _class \n<br>
	 * @param visual Specifies the id for the new window's visual.<br>
	 * \n<br>
	 * The special value `XCB_COPY_FROM_PARENT` means the visual is taken from the<br>
	 * \a parent window.<br>
	 * @param value_mask A bitmask of #xcb_cw_t values.<br>
	 * @return A cookie<br>
	 * Creates an unmapped window as child of the specified \a parent window. A<br>
	 * CreateNotify event will be generated. The new window is placed on top in the<br>
	 * stacking order with respect to siblings.<br>
	 * <br>
	 * The coordinate system has the X axis horizontal and the Y axis vertical with<br>
	 * the origin [0, 0] at the upper-left corner. Coordinates are integral, in terms<br>
	 * of pixels, and coincide with pixel centers. Each window and pixmap has its own<br>
	 * coordinate system. For a window, the origin is inside the border at the inside,<br>
	 * upper-left corner.<br>
	 * <br>
	 * The created window is not yet displayed (mapped), call `xcb_map_window` to<br>
	 * display it.<br>
	 * <br>
	 * The created window will initially use the same cursor as its parent.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_create_window(xcb_connection_t*, uint8_t, xcb_window_t, xcb_window_t, int16_t, int16_t, uint16_t, uint16_t, uint16_t, uint16_t, xcb_visualid_t, uint32_t, const uint32_t*)</code><br>
	 * @param c <<br>
	 * @param depth <<br>
	 * @param wid <<br>
	 * @param parent <<br>
	 * @param x <<br>
	 * @param y <<br>
	 * @param width <<br>
	 * @param height <<br>
	 * @param border_width <<br>
	 * @param _class <<br>
	 * @param visual <<br>
	 * @param value_mask <<br>
	 * @param value_list <<br>
	 * <i>native declaration : xcb/xproto.h:4077</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_create_window(PointerByReference c, byte depth, int wid, int parent, short x, short y, short width, short height, short border_width, short _class, int visual, int value_mask, IntByReference value_list);
	/**
	 * Original signature : <code>int xcb_change_window_attributes_sizeof(const void*)</code><br>
	 * @param _buffer <<br>
	 * <i>native declaration : xcb/xproto.h:4082</i>
	 */
	int xcb_change_window_attributes_sizeof(Pointer _buffer);
	/**
	 * @brief change window attributes<br>
	 * @param c The connection<br>
	 * @param window The window to change.<br>
	 * @param value_mask A bitmask of #xcb_cw_t values.<br>
	 * @param value_mask \n<br>
	 * @param value_list Values for each of the attributes specified in the bitmask \a value_mask. The<br>
	 * order has to correspond to the order of possible \a value_mask bits. See the<br>
	 * example.<br>
	 * @return A cookie<br>
	 * Changes the attributes specified by \a value_mask for the specified \a window.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_change_window_attributes_checked(xcb_connection_t*, xcb_window_t, uint32_t, const uint32_t*)</code><br>
	 * @param c <<br>
	 * @param window <<br>
	 * @param value_mask <<br>
	 * @param value_list <<br>
	 * <i>native declaration : xcb/xproto.h:4103</i><br>
	 * @deprecated use the safer methods {@link #xcb_change_window_attributes_checked(com.sun.jna.ptr.PointerByReference, int, int, int[])} and {@link #xcb_change_window_attributes_checked(com.sun.jna.ptr.PointerByReference, int, int, com.sun.jna.ptr.IntByReference)} instead
	 */
	@Deprecated 
	xcb.xcb_void_cookie_t.ByValue xcb_change_window_attributes_checked(Pointer c, int window, int value_mask, IntByReference value_list);
	/**
	 * @brief change window attributes<br>
	 * @param c The connection<br>
	 * @param window The window to change.<br>
	 * @param value_mask A bitmask of #xcb_cw_t values.<br>
	 * @param value_mask \n<br>
	 * @param value_list Values for each of the attributes specified in the bitmask \a value_mask. The<br>
	 * order has to correspond to the order of possible \a value_mask bits. See the<br>
	 * example.<br>
	 * @return A cookie<br>
	 * Changes the attributes specified by \a value_mask for the specified \a window.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_change_window_attributes_checked(xcb_connection_t*, xcb_window_t, uint32_t, const uint32_t*)</code><br>
	 * @param c <<br>
	 * @param window <<br>
	 * @param value_mask <<br>
	 * @param value_list <<br>
	 * <i>native declaration : xcb/xproto.h:4103</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_change_window_attributes_checked(PointerByReference c, int window, int value_mask, int value_list[]);
	/**
	 * @brief change window attributes<br>
	 * @param c The connection<br>
	 * @param window The window to change.<br>
	 * @param value_mask A bitmask of #xcb_cw_t values.<br>
	 * @param value_mask \n<br>
	 * @param value_list Values for each of the attributes specified in the bitmask \a value_mask. The<br>
	 * order has to correspond to the order of possible \a value_mask bits. See the<br>
	 * example.<br>
	 * @return A cookie<br>
	 * Changes the attributes specified by \a value_mask for the specified \a window.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_change_window_attributes_checked(xcb_connection_t*, xcb_window_t, uint32_t, const uint32_t*)</code><br>
	 * @param c <<br>
	 * @param window <<br>
	 * @param value_mask <<br>
	 * @param value_list <<br>
	 * <i>native declaration : xcb/xproto.h:4103</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_change_window_attributes_checked(PointerByReference c, int window, int value_mask, IntByReference value_list);
	/**
	 * @brief change window attributes<br>
	 * @param c The connection<br>
	 * @param window The window to change.<br>
	 * @param value_mask A bitmask of #xcb_cw_t values.<br>
	 * @param value_mask \n<br>
	 * @param value_list Values for each of the attributes specified in the bitmask \a value_mask. The<br>
	 * order has to correspond to the order of possible \a value_mask bits. See the<br>
	 * example.<br>
	 * @return A cookie<br>
	 * Changes the attributes specified by \a value_mask for the specified \a window.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_change_window_attributes(xcb_connection_t*, xcb_window_t, uint32_t, const uint32_t*)</code><br>
	 * @param c <<br>
	 * @param window <<br>
	 * @param value_mask <<br>
	 * @param value_list <<br>
	 * <i>native declaration : xcb/xproto.h:4121</i><br>
	 * @deprecated use the safer methods {@link #xcb_change_window_attributes(com.sun.jna.ptr.PointerByReference, int, int, int[])} and {@link #xcb_change_window_attributes(com.sun.jna.ptr.PointerByReference, int, int, com.sun.jna.ptr.IntByReference)} instead
	 */
	@Deprecated 
	xcb.xcb_void_cookie_t.ByValue xcb_change_window_attributes(Pointer c, int window, int value_mask, IntByReference value_list);
	/**
	 * @brief change window attributes<br>
	 * @param c The connection<br>
	 * @param window The window to change.<br>
	 * @param value_mask A bitmask of #xcb_cw_t values.<br>
	 * @param value_mask \n<br>
	 * @param value_list Values for each of the attributes specified in the bitmask \a value_mask. The<br>
	 * order has to correspond to the order of possible \a value_mask bits. See the<br>
	 * example.<br>
	 * @return A cookie<br>
	 * Changes the attributes specified by \a value_mask for the specified \a window.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_change_window_attributes(xcb_connection_t*, xcb_window_t, uint32_t, const uint32_t*)</code><br>
	 * @param c <<br>
	 * @param window <<br>
	 * @param value_mask <<br>
	 * @param value_list <<br>
	 * <i>native declaration : xcb/xproto.h:4121</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_change_window_attributes(PointerByReference c, int window, int value_mask, int value_list[]);
	/**
	 * @brief change window attributes<br>
	 * @param c The connection<br>
	 * @param window The window to change.<br>
	 * @param value_mask A bitmask of #xcb_cw_t values.<br>
	 * @param value_mask \n<br>
	 * @param value_list Values for each of the attributes specified in the bitmask \a value_mask. The<br>
	 * order has to correspond to the order of possible \a value_mask bits. See the<br>
	 * example.<br>
	 * @return A cookie<br>
	 * Changes the attributes specified by \a value_mask for the specified \a window.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_change_window_attributes(xcb_connection_t*, xcb_window_t, uint32_t, const uint32_t*)</code><br>
	 * @param c <<br>
	 * @param window <<br>
	 * @param value_mask <<br>
	 * @param value_list <<br>
	 * <i>native declaration : xcb/xproto.h:4121</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_change_window_attributes(PointerByReference c, int window, int value_mask, IntByReference value_list);
	/**
	 * @brief Gets window attributes<br>
	 * @param c The connection<br>
	 * @param window The window to get the attributes from.<br>
	 * @return A cookie<br>
	 * Gets the current attributes for the specified \a window.<br>
	 * Original signature : <code>xcb_get_window_attributes_cookie_t xcb_get_window_attributes(xcb_connection_t*, xcb_window_t)</code><br>
	 * @param c <<br>
	 * @param window <<br>
	 * <i>native declaration : xcb/xproto.h:4132</i><br>
	 * @deprecated use the safer method {@link #xcb_get_window_attributes(com.sun.jna.ptr.PointerByReference, int)} instead
	 */
	@Deprecated 
	xcb.xcb_get_window_attributes_cookie_t.ByValue xcb_get_window_attributes(Pointer c, int window);
	/**
	 * @brief Gets window attributes<br>
	 * @param c The connection<br>
	 * @param window The window to get the attributes from.<br>
	 * @return A cookie<br>
	 * Gets the current attributes for the specified \a window.<br>
	 * Original signature : <code>xcb_get_window_attributes_cookie_t xcb_get_window_attributes(xcb_connection_t*, xcb_window_t)</code><br>
	 * @param c <<br>
	 * @param window <<br>
	 * <i>native declaration : xcb/xproto.h:4132</i>
	 */
	xcb.xcb_get_window_attributes_cookie_t.ByValue xcb_get_window_attributes(PointerByReference c, int window);
	/**
	 * @brief Gets window attributes<br>
	 * @param c The connection<br>
	 * @param window The window to get the attributes from.<br>
	 * @return A cookie<br>
	 * Gets the current attributes for the specified \a window.<br>
	 * This form can be used only if the request will cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * placed in the event queue.<br>
	 * Original signature : <code>xcb_get_window_attributes_cookie_t xcb_get_window_attributes_unchecked(xcb_connection_t*, xcb_window_t)</code><br>
	 * @param c <<br>
	 * @param window <<br>
	 * <i>native declaration : xcb/xproto.h:4146</i><br>
	 * @deprecated use the safer method {@link #xcb_get_window_attributes_unchecked(com.sun.jna.ptr.PointerByReference, int)} instead
	 */
	@Deprecated 
	xcb.xcb_get_window_attributes_cookie_t.ByValue xcb_get_window_attributes_unchecked(Pointer c, int window);
	/**
	 * @brief Gets window attributes<br>
	 * @param c The connection<br>
	 * @param window The window to get the attributes from.<br>
	 * @return A cookie<br>
	 * Gets the current attributes for the specified \a window.<br>
	 * This form can be used only if the request will cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * placed in the event queue.<br>
	 * Original signature : <code>xcb_get_window_attributes_cookie_t xcb_get_window_attributes_unchecked(xcb_connection_t*, xcb_window_t)</code><br>
	 * @param c <<br>
	 * @param window <<br>
	 * <i>native declaration : xcb/xproto.h:4146</i>
	 */
	xcb.xcb_get_window_attributes_cookie_t.ByValue xcb_get_window_attributes_unchecked(PointerByReference c, int window);
	/**
	 * Return the reply<br>
	 * @param c      The connection<br>
	 * @param cookie The cookie<br>
	 * @param e      The xcb_generic_error_t supplied<br>
	 * Returns the reply of the request asked by<br>
	 * The parameter @p e supplied to this function must be NULL if<br>
	 * xcb_get_window_attributes_unchecked(). is used.<br>
	 * Otherwise, it stores the error if any.<br>
	 * The returned value must be freed by the caller using free().<br>
	 * Original signature : <code>xcb_get_window_attributes_reply_t* xcb_get_window_attributes_reply(xcb_connection_t*, xcb_get_window_attributes_cookie_t, xcb_generic_error_t**)</code><br>
	 * @param c <<br>
	 * @param cookie <<br>
	 * @param e <<br>
	 * <i>native declaration : xcb/xproto.h:4162</i><br>
	 * @deprecated use the safer method {@link #xcb_get_window_attributes_reply(com.sun.jna.ptr.PointerByReference, xcb.xcb_get_window_attributes_cookie_t.ByValue, xcb.xcb_generic_error_t.ByReference[])} instead
	 */
	@Deprecated 
	xcb_get_window_attributes_reply_t xcb_get_window_attributes_reply(Pointer c, xcb.xcb_get_window_attributes_cookie_t.ByValue cookie, PointerByReference e);
	/**
	 * Return the reply<br>
	 * @param c      The connection<br>
	 * @param cookie The cookie<br>
	 * @param e      The xcb_generic_error_t supplied<br>
	 * Returns the reply of the request asked by<br>
	 * The parameter @p e supplied to this function must be NULL if<br>
	 * xcb_get_window_attributes_unchecked(). is used.<br>
	 * Otherwise, it stores the error if any.<br>
	 * The returned value must be freed by the caller using free().<br>
	 * Original signature : <code>xcb_get_window_attributes_reply_t* xcb_get_window_attributes_reply(xcb_connection_t*, xcb_get_window_attributes_cookie_t, xcb_generic_error_t**)</code><br>
	 * @param c <<br>
	 * @param cookie <<br>
	 * @param e <<br>
	 * <i>native declaration : xcb/xproto.h:4162</i>
	 */
	xcb_get_window_attributes_reply_t xcb_get_window_attributes_reply(PointerByReference c, xcb.xcb_get_window_attributes_cookie_t.ByValue cookie, xcb_generic_error_t.ByReference e[]);
	/**
	 * @brief Destroys a window<br>
	 * @param c The connection<br>
	 * @param window The window to destroy.<br>
	 * @return A cookie<br>
	 * Destroys the specified window and all of its subwindows. A DestroyNotify event<br>
	 * is generated for each destroyed window (a DestroyNotify event is first generated<br>
	 * for any given window's inferiors). If the window was mapped, it will be<br>
	 * automatically unmapped before destroying.<br>
	 * <br>
	 * Calling DestroyWindow on the root window will do nothing.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_destroy_window_checked(xcb_connection_t*, xcb_window_t)</code><br>
	 * @param c <<br>
	 * @param window <<br>
	 * <i>native declaration : xcb/xproto.h:4181</i><br>
	 * @deprecated use the safer method {@link #xcb_destroy_window_checked(com.sun.jna.ptr.PointerByReference, int)} instead
	 */
	@Deprecated 
	xcb.xcb_void_cookie_t.ByValue xcb_destroy_window_checked(Pointer c, int window);
	/**
	 * @brief Destroys a window<br>
	 * @param c The connection<br>
	 * @param window The window to destroy.<br>
	 * @return A cookie<br>
	 * Destroys the specified window and all of its subwindows. A DestroyNotify event<br>
	 * is generated for each destroyed window (a DestroyNotify event is first generated<br>
	 * for any given window's inferiors). If the window was mapped, it will be<br>
	 * automatically unmapped before destroying.<br>
	 * <br>
	 * Calling DestroyWindow on the root window will do nothing.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_destroy_window_checked(xcb_connection_t*, xcb_window_t)</code><br>
	 * @param c <<br>
	 * @param window <<br>
	 * <i>native declaration : xcb/xproto.h:4181</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_destroy_window_checked(PointerByReference c, int window);
	/**
	 * @brief Destroys a window<br>
	 * @param c The connection<br>
	 * @param window The window to destroy.<br>
	 * @return A cookie<br>
	 * Destroys the specified window and all of its subwindows. A DestroyNotify event<br>
	 * is generated for each destroyed window (a DestroyNotify event is first generated<br>
	 * for any given window's inferiors). If the window was mapped, it will be<br>
	 * automatically unmapped before destroying.<br>
	 * <br>
	 * Calling DestroyWindow on the root window will do nothing.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_destroy_window(xcb_connection_t*, xcb_window_t)</code><br>
	 * @param c <<br>
	 * @param window <<br>
	 * <i>native declaration : xcb/xproto.h:4197</i><br>
	 * @deprecated use the safer method {@link #xcb_destroy_window(com.sun.jna.ptr.PointerByReference, int)} instead
	 */
	@Deprecated 
	xcb.xcb_void_cookie_t.ByValue xcb_destroy_window(Pointer c, int window);
	/**
	 * @brief Destroys a window<br>
	 * @param c The connection<br>
	 * @param window The window to destroy.<br>
	 * @return A cookie<br>
	 * Destroys the specified window and all of its subwindows. A DestroyNotify event<br>
	 * is generated for each destroyed window (a DestroyNotify event is first generated<br>
	 * for any given window's inferiors). If the window was mapped, it will be<br>
	 * automatically unmapped before destroying.<br>
	 * <br>
	 * Calling DestroyWindow on the root window will do nothing.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_destroy_window(xcb_connection_t*, xcb_window_t)</code><br>
	 * @param c <<br>
	 * @param window <<br>
	 * <i>native declaration : xcb/xproto.h:4197</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_destroy_window(PointerByReference c, int window);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_destroy_subwindows_checked(xcb_connection_t*, xcb_window_t)</code><br>
	 * @param c <<br>
	 * @param window <<br>
	 * <i>native declaration : xcb/xproto.h:4209</i><br>
	 * @deprecated use the safer method {@link #xcb_destroy_subwindows_checked(com.sun.jna.ptr.PointerByReference, int)} instead
	 */
	@Deprecated 
	xcb.xcb_void_cookie_t.ByValue xcb_destroy_subwindows_checked(Pointer c, int window);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_destroy_subwindows_checked(xcb_connection_t*, xcb_window_t)</code><br>
	 * @param c <<br>
	 * @param window <<br>
	 * <i>native declaration : xcb/xproto.h:4209</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_destroy_subwindows_checked(PointerByReference c, int window);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_destroy_subwindows(xcb_connection_t*, xcb_window_t)</code><br>
	 * @param c <<br>
	 * @param window <<br>
	 * <i>native declaration : xcb/xproto.h:4218</i><br>
	 * @deprecated use the safer method {@link #xcb_destroy_subwindows(com.sun.jna.ptr.PointerByReference, int)} instead
	 */
	@Deprecated 
	xcb.xcb_void_cookie_t.ByValue xcb_destroy_subwindows(Pointer c, int window);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_destroy_subwindows(xcb_connection_t*, xcb_window_t)</code><br>
	 * @param c <<br>
	 * @param window <<br>
	 * <i>native declaration : xcb/xproto.h:4218</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_destroy_subwindows(PointerByReference c, int window);
	/**
	 * @brief Changes a client's save set<br>
	 * @param c The connection<br>
	 * @param mode A bitmask of #xcb_set_mode_t values.<br>
	 * @param mode Insert to add the specified window to the save set or Delete to delete it from the save set.<br>
	 * @param window The window to add or delete to/from your save set.<br>
	 * @return A cookie<br>
	 * TODO: explain what the save set is for.<br>
	 * <br>
	 * This function either adds or removes the specified window to the client's (your<br>
	 * application's) save set.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_change_save_set_checked(xcb_connection_t*, uint8_t, xcb_window_t)</code><br>
	 * @param c <<br>
	 * @param mode <<br>
	 * @param window <<br>
	 * <i>native declaration : xcb/xproto.h:4238</i><br>
	 * @deprecated use the safer method {@link #xcb_change_save_set_checked(com.sun.jna.ptr.PointerByReference, byte, int)} instead
	 */
	@Deprecated 
	xcb.xcb_void_cookie_t.ByValue xcb_change_save_set_checked(Pointer c, byte mode, int window);
	/**
	 * @brief Changes a client's save set<br>
	 * @param c The connection<br>
	 * @param mode A bitmask of #xcb_set_mode_t values.<br>
	 * @param mode Insert to add the specified window to the save set or Delete to delete it from the save set.<br>
	 * @param window The window to add or delete to/from your save set.<br>
	 * @return A cookie<br>
	 * TODO: explain what the save set is for.<br>
	 * <br>
	 * This function either adds or removes the specified window to the client's (your<br>
	 * application's) save set.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_change_save_set_checked(xcb_connection_t*, uint8_t, xcb_window_t)</code><br>
	 * @param c <<br>
	 * @param mode <<br>
	 * @param window <<br>
	 * <i>native declaration : xcb/xproto.h:4238</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_change_save_set_checked(PointerByReference c, byte mode, int window);
	/**
	 * @brief Changes a client's save set<br>
	 * @param c The connection<br>
	 * @param mode A bitmask of #xcb_set_mode_t values.<br>
	 * @param mode Insert to add the specified window to the save set or Delete to delete it from the save set.<br>
	 * @param window The window to add or delete to/from your save set.<br>
	 * @return A cookie<br>
	 * TODO: explain what the save set is for.<br>
	 * <br>
	 * This function either adds or removes the specified window to the client's (your<br>
	 * application's) save set.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_change_save_set(xcb_connection_t*, uint8_t, xcb_window_t)</code><br>
	 * @param c <<br>
	 * @param mode <<br>
	 * @param window <<br>
	 * <i>native declaration : xcb/xproto.h:4255</i><br>
	 * @deprecated use the safer method {@link #xcb_change_save_set(com.sun.jna.ptr.PointerByReference, byte, int)} instead
	 */
	@Deprecated 
	xcb.xcb_void_cookie_t.ByValue xcb_change_save_set(Pointer c, byte mode, int window);
	/**
	 * @brief Changes a client's save set<br>
	 * @param c The connection<br>
	 * @param mode A bitmask of #xcb_set_mode_t values.<br>
	 * @param mode Insert to add the specified window to the save set or Delete to delete it from the save set.<br>
	 * @param window The window to add or delete to/from your save set.<br>
	 * @return A cookie<br>
	 * TODO: explain what the save set is for.<br>
	 * <br>
	 * This function either adds or removes the specified window to the client's (your<br>
	 * application's) save set.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_change_save_set(xcb_connection_t*, uint8_t, xcb_window_t)</code><br>
	 * @param c <<br>
	 * @param mode <<br>
	 * @param window <<br>
	 * <i>native declaration : xcb/xproto.h:4255</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_change_save_set(PointerByReference c, byte mode, int window);
	/**
	 * @brief Reparents a window<br>
	 * @param c The connection<br>
	 * @param window The window to reparent.<br>
	 * @param parent The new parent of the window.<br>
	 * @param x The X position of the window within its new parent.<br>
	 * @param y The Y position of the window within its new parent.<br>
	 * @return A cookie<br>
	 * Makes the specified window a child of the specified parent window. If the<br>
	 * window is mapped, it will automatically be unmapped before reparenting and<br>
	 * re-mapped after reparenting. The window is placed in the stacking order on top<br>
	 * with respect to sibling windows.<br>
	 * <br>
	 * After reparenting, a ReparentNotify event is generated.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_reparent_window_checked(xcb_connection_t*, xcb_window_t, xcb_window_t, int16_t, int16_t)</code><br>
	 * @param c <<br>
	 * @param window <<br>
	 * @param parent <<br>
	 * @param x <<br>
	 * @param y <<br>
	 * <i>native declaration : xcb/xproto.h:4280</i><br>
	 * @deprecated use the safer method {@link #xcb_reparent_window_checked(com.sun.jna.ptr.PointerByReference, int, int, short, short)} instead
	 */
	@Deprecated 
	xcb.xcb_void_cookie_t.ByValue xcb_reparent_window_checked(Pointer c, int window, int parent, short x, short y);
	/**
	 * @brief Reparents a window<br>
	 * @param c The connection<br>
	 * @param window The window to reparent.<br>
	 * @param parent The new parent of the window.<br>
	 * @param x The X position of the window within its new parent.<br>
	 * @param y The Y position of the window within its new parent.<br>
	 * @return A cookie<br>
	 * Makes the specified window a child of the specified parent window. If the<br>
	 * window is mapped, it will automatically be unmapped before reparenting and<br>
	 * re-mapped after reparenting. The window is placed in the stacking order on top<br>
	 * with respect to sibling windows.<br>
	 * <br>
	 * After reparenting, a ReparentNotify event is generated.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_reparent_window_checked(xcb_connection_t*, xcb_window_t, xcb_window_t, int16_t, int16_t)</code><br>
	 * @param c <<br>
	 * @param window <<br>
	 * @param parent <<br>
	 * @param x <<br>
	 * @param y <<br>
	 * <i>native declaration : xcb/xproto.h:4280</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_reparent_window_checked(PointerByReference c, int window, int parent, short x, short y);
	/**
	 * @brief Reparents a window<br>
	 * @param c The connection<br>
	 * @param window The window to reparent.<br>
	 * @param parent The new parent of the window.<br>
	 * @param x The X position of the window within its new parent.<br>
	 * @param y The Y position of the window within its new parent.<br>
	 * @return A cookie<br>
	 * Makes the specified window a child of the specified parent window. If the<br>
	 * window is mapped, it will automatically be unmapped before reparenting and<br>
	 * re-mapped after reparenting. The window is placed in the stacking order on top<br>
	 * with respect to sibling windows.<br>
	 * <br>
	 * After reparenting, a ReparentNotify event is generated.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_reparent_window(xcb_connection_t*, xcb_window_t, xcb_window_t, int16_t, int16_t)</code><br>
	 * @param c <<br>
	 * @param window <<br>
	 * @param parent <<br>
	 * @param x <<br>
	 * @param y <<br>
	 * <i>native declaration : xcb/xproto.h:4302</i><br>
	 * @deprecated use the safer method {@link #xcb_reparent_window(com.sun.jna.ptr.PointerByReference, int, int, short, short)} instead
	 */
	@Deprecated 
	xcb.xcb_void_cookie_t.ByValue xcb_reparent_window(Pointer c, int window, int parent, short x, short y);
	/**
	 * @brief Reparents a window<br>
	 * @param c The connection<br>
	 * @param window The window to reparent.<br>
	 * @param parent The new parent of the window.<br>
	 * @param x The X position of the window within its new parent.<br>
	 * @param y The Y position of the window within its new parent.<br>
	 * @return A cookie<br>
	 * Makes the specified window a child of the specified parent window. If the<br>
	 * window is mapped, it will automatically be unmapped before reparenting and<br>
	 * re-mapped after reparenting. The window is placed in the stacking order on top<br>
	 * with respect to sibling windows.<br>
	 * <br>
	 * After reparenting, a ReparentNotify event is generated.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_reparent_window(xcb_connection_t*, xcb_window_t, xcb_window_t, int16_t, int16_t)</code><br>
	 * @param c <<br>
	 * @param window <<br>
	 * @param parent <<br>
	 * @param x <<br>
	 * @param y <<br>
	 * <i>native declaration : xcb/xproto.h:4302</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_reparent_window(PointerByReference c, int window, int parent, short x, short y);
	/**
	 * @brief Makes a window visible<br>
	 * @param c The connection<br>
	 * @param window The window to make visible.<br>
	 * @return A cookie<br>
	 * Maps the specified window. This means making the window visible (as long as its<br>
	 * parent is visible).<br>
	 * <br>
	 * This MapWindow request will be translated to a MapRequest request if a window<br>
	 * manager is running. The window manager then decides to either map the window or<br>
	 * not. Set the override-redirect window attribute to true if you want to bypass<br>
	 * this mechanism.<br>
	 * <br>
	 * If the window manager decides to map the window (or if no window manager is<br>
	 * running), a MapNotify event is generated.<br>
	 * <br>
	 * If the window becomes viewable and no earlier contents for it are remembered,<br>
	 * the X server tiles the window with its background. If the window's background<br>
	 * is undefined, the existing screen contents are not altered, and the X server<br>
	 * generates zero or more Expose events.<br>
	 * <br>
	 * If the window type is InputOutput, an Expose event will be generated when the<br>
	 * window becomes visible. The normal response to an Expose event should be to<br>
	 * repaint the window.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_map_window_checked(xcb_connection_t*, xcb_window_t)</code><br>
	 * @param c <<br>
	 * @param window <<br>
	 * <i>native declaration : xcb/xproto.h:4334</i><br>
	 * @deprecated use the safer method {@link #xcb_map_window_checked(com.sun.jna.ptr.PointerByReference, int)} instead
	 */
	@Deprecated 
	xcb.xcb_void_cookie_t.ByValue xcb_map_window_checked(Pointer c, int window);
	/**
	 * @brief Makes a window visible<br>
	 * @param c The connection<br>
	 * @param window The window to make visible.<br>
	 * @return A cookie<br>
	 * Maps the specified window. This means making the window visible (as long as its<br>
	 * parent is visible).<br>
	 * <br>
	 * This MapWindow request will be translated to a MapRequest request if a window<br>
	 * manager is running. The window manager then decides to either map the window or<br>
	 * not. Set the override-redirect window attribute to true if you want to bypass<br>
	 * this mechanism.<br>
	 * <br>
	 * If the window manager decides to map the window (or if no window manager is<br>
	 * running), a MapNotify event is generated.<br>
	 * <br>
	 * If the window becomes viewable and no earlier contents for it are remembered,<br>
	 * the X server tiles the window with its background. If the window's background<br>
	 * is undefined, the existing screen contents are not altered, and the X server<br>
	 * generates zero or more Expose events.<br>
	 * <br>
	 * If the window type is InputOutput, an Expose event will be generated when the<br>
	 * window becomes visible. The normal response to an Expose event should be to<br>
	 * repaint the window.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_map_window_checked(xcb_connection_t*, xcb_window_t)</code><br>
	 * @param c <<br>
	 * @param window <<br>
	 * <i>native declaration : xcb/xproto.h:4334</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_map_window_checked(PointerByReference c, int window);
	/**
	 * @brief Makes a window visible<br>
	 * @param c The connection<br>
	 * @param window The window to make visible.<br>
	 * @return A cookie<br>
	 * Maps the specified window. This means making the window visible (as long as its<br>
	 * parent is visible).<br>
	 * <br>
	 * This MapWindow request will be translated to a MapRequest request if a window<br>
	 * manager is running. The window manager then decides to either map the window or<br>
	 * not. Set the override-redirect window attribute to true if you want to bypass<br>
	 * this mechanism.<br>
	 * <br>
	 * If the window manager decides to map the window (or if no window manager is<br>
	 * running), a MapNotify event is generated.<br>
	 * <br>
	 * If the window becomes viewable and no earlier contents for it are remembered,<br>
	 * the X server tiles the window with its background. If the window's background<br>
	 * is undefined, the existing screen contents are not altered, and the X server<br>
	 * generates zero or more Expose events.<br>
	 * <br>
	 * If the window type is InputOutput, an Expose event will be generated when the<br>
	 * window becomes visible. The normal response to an Expose event should be to<br>
	 * repaint the window.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_map_window(xcb_connection_t*, xcb_window_t)</code><br>
	 * @param c <<br>
	 * @param window <<br>
	 * <i>native declaration : xcb/xproto.h:4363</i><br>
	 * @deprecated use the safer method {@link #xcb_map_window(com.sun.jna.ptr.PointerByReference, int)} instead
	 */
	@Deprecated 
	xcb.xcb_void_cookie_t.ByValue xcb_map_window(Pointer c, int window);
	/**
	 * @brief Makes a window visible<br>
	 * @param c The connection<br>
	 * @param window The window to make visible.<br>
	 * @return A cookie<br>
	 * Maps the specified window. This means making the window visible (as long as its<br>
	 * parent is visible).<br>
	 * <br>
	 * This MapWindow request will be translated to a MapRequest request if a window<br>
	 * manager is running. The window manager then decides to either map the window or<br>
	 * not. Set the override-redirect window attribute to true if you want to bypass<br>
	 * this mechanism.<br>
	 * <br>
	 * If the window manager decides to map the window (or if no window manager is<br>
	 * running), a MapNotify event is generated.<br>
	 * <br>
	 * If the window becomes viewable and no earlier contents for it are remembered,<br>
	 * the X server tiles the window with its background. If the window's background<br>
	 * is undefined, the existing screen contents are not altered, and the X server<br>
	 * generates zero or more Expose events.<br>
	 * <br>
	 * If the window type is InputOutput, an Expose event will be generated when the<br>
	 * window becomes visible. The normal response to an Expose event should be to<br>
	 * repaint the window.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_map_window(xcb_connection_t*, xcb_window_t)</code><br>
	 * @param c <<br>
	 * @param window <<br>
	 * <i>native declaration : xcb/xproto.h:4363</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_map_window(PointerByReference c, int window);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_map_subwindows_checked(xcb_connection_t*, xcb_window_t)</code><br>
	 * @param c <<br>
	 * @param window <<br>
	 * <i>native declaration : xcb/xproto.h:4375</i><br>
	 * @deprecated use the safer method {@link #xcb_map_subwindows_checked(com.sun.jna.ptr.PointerByReference, int)} instead
	 */
	@Deprecated 
	xcb.xcb_void_cookie_t.ByValue xcb_map_subwindows_checked(Pointer c, int window);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_map_subwindows_checked(xcb_connection_t*, xcb_window_t)</code><br>
	 * @param c <<br>
	 * @param window <<br>
	 * <i>native declaration : xcb/xproto.h:4375</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_map_subwindows_checked(PointerByReference c, int window);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_map_subwindows(xcb_connection_t*, xcb_window_t)</code><br>
	 * @param c <<br>
	 * @param window <<br>
	 * <i>native declaration : xcb/xproto.h:4384</i><br>
	 * @deprecated use the safer method {@link #xcb_map_subwindows(com.sun.jna.ptr.PointerByReference, int)} instead
	 */
	@Deprecated 
	xcb.xcb_void_cookie_t.ByValue xcb_map_subwindows(Pointer c, int window);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_map_subwindows(xcb_connection_t*, xcb_window_t)</code><br>
	 * @param c <<br>
	 * @param window <<br>
	 * <i>native declaration : xcb/xproto.h:4384</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_map_subwindows(PointerByReference c, int window);
	/**
	 * @brief Makes a window invisible<br>
	 * @param c The connection<br>
	 * @param window The window to make invisible.<br>
	 * @return A cookie<br>
	 * Unmaps the specified window. This means making the window invisible (and all<br>
	 * its child windows).<br>
	 * <br>
	 * Unmapping a window leads to the `UnmapNotify` event being generated. Also,<br>
	 * `Expose` events are generated for formerly obscured windows.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_unmap_window_checked(xcb_connection_t*, xcb_window_t)</code><br>
	 * @param c <<br>
	 * @param window <<br>
	 * <i>native declaration : xcb/xproto.h:4402</i><br>
	 * @deprecated use the safer method {@link #xcb_unmap_window_checked(com.sun.jna.ptr.PointerByReference, int)} instead
	 */
	@Deprecated 
	xcb.xcb_void_cookie_t.ByValue xcb_unmap_window_checked(Pointer c, int window);
	/**
	 * @brief Makes a window invisible<br>
	 * @param c The connection<br>
	 * @param window The window to make invisible.<br>
	 * @return A cookie<br>
	 * Unmaps the specified window. This means making the window invisible (and all<br>
	 * its child windows).<br>
	 * <br>
	 * Unmapping a window leads to the `UnmapNotify` event being generated. Also,<br>
	 * `Expose` events are generated for formerly obscured windows.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_unmap_window_checked(xcb_connection_t*, xcb_window_t)</code><br>
	 * @param c <<br>
	 * @param window <<br>
	 * <i>native declaration : xcb/xproto.h:4402</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_unmap_window_checked(PointerByReference c, int window);
	/**
	 * @brief Makes a window invisible<br>
	 * @param c The connection<br>
	 * @param window The window to make invisible.<br>
	 * @return A cookie<br>
	 * Unmaps the specified window. This means making the window invisible (and all<br>
	 * its child windows).<br>
	 * <br>
	 * Unmapping a window leads to the `UnmapNotify` event being generated. Also,<br>
	 * `Expose` events are generated for formerly obscured windows.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_unmap_window(xcb_connection_t*, xcb_window_t)</code><br>
	 * @param c <<br>
	 * @param window <<br>
	 * <i>native declaration : xcb/xproto.h:4417</i><br>
	 * @deprecated use the safer method {@link #xcb_unmap_window(com.sun.jna.ptr.PointerByReference, int)} instead
	 */
	@Deprecated 
	xcb.xcb_void_cookie_t.ByValue xcb_unmap_window(Pointer c, int window);
	/**
	 * @brief Makes a window invisible<br>
	 * @param c The connection<br>
	 * @param window The window to make invisible.<br>
	 * @return A cookie<br>
	 * Unmaps the specified window. This means making the window invisible (and all<br>
	 * its child windows).<br>
	 * <br>
	 * Unmapping a window leads to the `UnmapNotify` event being generated. Also,<br>
	 * `Expose` events are generated for formerly obscured windows.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_unmap_window(xcb_connection_t*, xcb_window_t)</code><br>
	 * @param c <<br>
	 * @param window <<br>
	 * <i>native declaration : xcb/xproto.h:4417</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_unmap_window(PointerByReference c, int window);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_unmap_subwindows_checked(xcb_connection_t*, xcb_window_t)</code><br>
	 * @param c <<br>
	 * @param window <<br>
	 * <i>native declaration : xcb/xproto.h:4429</i><br>
	 * @deprecated use the safer method {@link #xcb_unmap_subwindows_checked(com.sun.jna.ptr.PointerByReference, int)} instead
	 */
	@Deprecated 
	xcb.xcb_void_cookie_t.ByValue xcb_unmap_subwindows_checked(Pointer c, int window);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_unmap_subwindows_checked(xcb_connection_t*, xcb_window_t)</code><br>
	 * @param c <<br>
	 * @param window <<br>
	 * <i>native declaration : xcb/xproto.h:4429</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_unmap_subwindows_checked(PointerByReference c, int window);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_unmap_subwindows(xcb_connection_t*, xcb_window_t)</code><br>
	 * @param c <<br>
	 * @param window <<br>
	 * <i>native declaration : xcb/xproto.h:4438</i><br>
	 * @deprecated use the safer method {@link #xcb_unmap_subwindows(com.sun.jna.ptr.PointerByReference, int)} instead
	 */
	@Deprecated 
	xcb.xcb_void_cookie_t.ByValue xcb_unmap_subwindows(Pointer c, int window);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_unmap_subwindows(xcb_connection_t*, xcb_window_t)</code><br>
	 * @param c <<br>
	 * @param window <<br>
	 * <i>native declaration : xcb/xproto.h:4438</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_unmap_subwindows(PointerByReference c, int window);
	/**
	 * Original signature : <code>int xcb_configure_window_sizeof(const void*)</code><br>
	 * @param _buffer <<br>
	 * <i>native declaration : xcb/xproto.h:4443</i>
	 */
	int xcb_configure_window_sizeof(Pointer _buffer);
	/**
	 * @brief Configures window attributes<br>
	 * @param c The connection<br>
	 * @param window The window to configure.<br>
	 * @param value_mask Bitmask of attributes to change.<br>
	 * @param value_list New values, corresponding to the attributes in value_mask. The order has to<br>
	 * correspond to the order of possible \a value_mask bits. See the example.<br>
	 * @return A cookie<br>
	 * Configures a window's size, position, border width and stacking order.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_configure_window_checked(xcb_connection_t*, xcb_window_t, uint16_t, const uint32_t*)</code><br>
	 * @param c <<br>
	 * @param window <<br>
	 * @param value_mask <<br>
	 * @param value_list <<br>
	 * <i>native declaration : xcb/xproto.h:4462</i><br>
	 * @deprecated use the safer methods {@link #xcb_configure_window_checked(com.sun.jna.ptr.PointerByReference, int, short, int[])} and {@link #xcb_configure_window_checked(com.sun.jna.ptr.PointerByReference, int, short, com.sun.jna.ptr.IntByReference)} instead
	 */
	@Deprecated 
	xcb.xcb_void_cookie_t.ByValue xcb_configure_window_checked(Pointer c, int window, short value_mask, IntByReference value_list);
	/**
	 * @brief Configures window attributes<br>
	 * @param c The connection<br>
	 * @param window The window to configure.<br>
	 * @param value_mask Bitmask of attributes to change.<br>
	 * @param value_list New values, corresponding to the attributes in value_mask. The order has to<br>
	 * correspond to the order of possible \a value_mask bits. See the example.<br>
	 * @return A cookie<br>
	 * Configures a window's size, position, border width and stacking order.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_configure_window_checked(xcb_connection_t*, xcb_window_t, uint16_t, const uint32_t*)</code><br>
	 * @param c <<br>
	 * @param window <<br>
	 * @param value_mask <<br>
	 * @param value_list <<br>
	 * <i>native declaration : xcb/xproto.h:4462</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_configure_window_checked(PointerByReference c, int window, short value_mask, int value_list[]);
	/**
	 * @brief Configures window attributes<br>
	 * @param c The connection<br>
	 * @param window The window to configure.<br>
	 * @param value_mask Bitmask of attributes to change.<br>
	 * @param value_list New values, corresponding to the attributes in value_mask. The order has to<br>
	 * correspond to the order of possible \a value_mask bits. See the example.<br>
	 * @return A cookie<br>
	 * Configures a window's size, position, border width and stacking order.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_configure_window_checked(xcb_connection_t*, xcb_window_t, uint16_t, const uint32_t*)</code><br>
	 * @param c <<br>
	 * @param window <<br>
	 * @param value_mask <<br>
	 * @param value_list <<br>
	 * <i>native declaration : xcb/xproto.h:4462</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_configure_window_checked(PointerByReference c, int window, short value_mask, IntByReference value_list);
	/**
	 * @brief Configures window attributes<br>
	 * @param c The connection<br>
	 * @param window The window to configure.<br>
	 * @param value_mask Bitmask of attributes to change.<br>
	 * @param value_list New values, corresponding to the attributes in value_mask. The order has to<br>
	 * correspond to the order of possible \a value_mask bits. See the example.<br>
	 * @return A cookie<br>
	 * Configures a window's size, position, border width and stacking order.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_configure_window(xcb_connection_t*, xcb_window_t, uint16_t, const uint32_t*)</code><br>
	 * @param c <<br>
	 * @param window <<br>
	 * @param value_mask <<br>
	 * @param value_list <<br>
	 * <i>native declaration : xcb/xproto.h:4478</i><br>
	 * @deprecated use the safer methods {@link #xcb_configure_window(com.sun.jna.ptr.PointerByReference, int, short, int[])} and {@link #xcb_configure_window(com.sun.jna.ptr.PointerByReference, int, short, com.sun.jna.ptr.IntByReference)} instead
	 */
	@Deprecated 
	xcb.xcb_void_cookie_t.ByValue xcb_configure_window(Pointer c, int window, short value_mask, IntByReference value_list);
	/**
	 * @brief Configures window attributes<br>
	 * @param c The connection<br>
	 * @param window The window to configure.<br>
	 * @param value_mask Bitmask of attributes to change.<br>
	 * @param value_list New values, corresponding to the attributes in value_mask. The order has to<br>
	 * correspond to the order of possible \a value_mask bits. See the example.<br>
	 * @return A cookie<br>
	 * Configures a window's size, position, border width and stacking order.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_configure_window(xcb_connection_t*, xcb_window_t, uint16_t, const uint32_t*)</code><br>
	 * @param c <<br>
	 * @param window <<br>
	 * @param value_mask <<br>
	 * @param value_list <<br>
	 * <i>native declaration : xcb/xproto.h:4478</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_configure_window(PointerByReference c, int window, short value_mask, int value_list[]);
	/**
	 * @brief Configures window attributes<br>
	 * @param c The connection<br>
	 * @param window The window to configure.<br>
	 * @param value_mask Bitmask of attributes to change.<br>
	 * @param value_list New values, corresponding to the attributes in value_mask. The order has to<br>
	 * correspond to the order of possible \a value_mask bits. See the example.<br>
	 * @return A cookie<br>
	 * Configures a window's size, position, border width and stacking order.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_configure_window(xcb_connection_t*, xcb_window_t, uint16_t, const uint32_t*)</code><br>
	 * @param c <<br>
	 * @param window <<br>
	 * @param value_mask <<br>
	 * @param value_list <<br>
	 * <i>native declaration : xcb/xproto.h:4478</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_configure_window(PointerByReference c, int window, short value_mask, IntByReference value_list);
	/**
	 * @brief Change window stacking order<br>
	 * @param c The connection<br>
	 * @param direction A bitmask of #xcb_circulate_t values.<br>
	 * @param direction \n<br>
	 * @param window The window to raise/lower (depending on \a direction).<br>
	 * @return A cookie<br>
	 * If \a direction is `XCB_CIRCULATE_RAISE_LOWEST`, the lowest mapped child (if<br>
	 * any) will be raised to the top of the stack.<br>
	 * <br>
	 * If \a direction is `XCB_CIRCULATE_LOWER_HIGHEST`, the highest mapped child will<br>
	 * be lowered to the bottom of the stack.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_circulate_window_checked(xcb_connection_t*, uint8_t, xcb_window_t)</code><br>
	 * @param c <<br>
	 * @param direction <<br>
	 * @param window <<br>
	 * <i>native declaration : xcb/xproto.h:4499</i><br>
	 * @deprecated use the safer method {@link #xcb_circulate_window_checked(com.sun.jna.ptr.PointerByReference, byte, int)} instead
	 */
	@Deprecated 
	xcb.xcb_void_cookie_t.ByValue xcb_circulate_window_checked(Pointer c, byte direction, int window);
	/**
	 * @brief Change window stacking order<br>
	 * @param c The connection<br>
	 * @param direction A bitmask of #xcb_circulate_t values.<br>
	 * @param direction \n<br>
	 * @param window The window to raise/lower (depending on \a direction).<br>
	 * @return A cookie<br>
	 * If \a direction is `XCB_CIRCULATE_RAISE_LOWEST`, the lowest mapped child (if<br>
	 * any) will be raised to the top of the stack.<br>
	 * <br>
	 * If \a direction is `XCB_CIRCULATE_LOWER_HIGHEST`, the highest mapped child will<br>
	 * be lowered to the bottom of the stack.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_circulate_window_checked(xcb_connection_t*, uint8_t, xcb_window_t)</code><br>
	 * @param c <<br>
	 * @param direction <<br>
	 * @param window <<br>
	 * <i>native declaration : xcb/xproto.h:4499</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_circulate_window_checked(PointerByReference c, byte direction, int window);
	/**
	 * @brief Change window stacking order<br>
	 * @param c The connection<br>
	 * @param direction A bitmask of #xcb_circulate_t values.<br>
	 * @param direction \n<br>
	 * @param window The window to raise/lower (depending on \a direction).<br>
	 * @return A cookie<br>
	 * If \a direction is `XCB_CIRCULATE_RAISE_LOWEST`, the lowest mapped child (if<br>
	 * any) will be raised to the top of the stack.<br>
	 * <br>
	 * If \a direction is `XCB_CIRCULATE_LOWER_HIGHEST`, the highest mapped child will<br>
	 * be lowered to the bottom of the stack.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_circulate_window(xcb_connection_t*, uint8_t, xcb_window_t)</code><br>
	 * @param c <<br>
	 * @param direction <<br>
	 * @param window <<br>
	 * <i>native declaration : xcb/xproto.h:4517</i><br>
	 * @deprecated use the safer method {@link #xcb_circulate_window(com.sun.jna.ptr.PointerByReference, byte, int)} instead
	 */
	@Deprecated 
	xcb.xcb_void_cookie_t.ByValue xcb_circulate_window(Pointer c, byte direction, int window);
	/**
	 * @brief Change window stacking order<br>
	 * @param c The connection<br>
	 * @param direction A bitmask of #xcb_circulate_t values.<br>
	 * @param direction \n<br>
	 * @param window The window to raise/lower (depending on \a direction).<br>
	 * @return A cookie<br>
	 * If \a direction is `XCB_CIRCULATE_RAISE_LOWEST`, the lowest mapped child (if<br>
	 * any) will be raised to the top of the stack.<br>
	 * <br>
	 * If \a direction is `XCB_CIRCULATE_LOWER_HIGHEST`, the highest mapped child will<br>
	 * be lowered to the bottom of the stack.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_circulate_window(xcb_connection_t*, uint8_t, xcb_window_t)</code><br>
	 * @param c <<br>
	 * @param direction <<br>
	 * @param window <<br>
	 * <i>native declaration : xcb/xproto.h:4517</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_circulate_window(PointerByReference c, byte direction, int window);
	/**
	 * @brief Get current window geometry<br>
	 * @param c The connection<br>
	 * @param drawable The drawable (`Window` or `Pixmap`) of which the geometry will be received.<br>
	 * @return A cookie<br>
	 * Gets the current geometry of the specified drawable (either `Window` or `Pixmap`).<br>
	 * Original signature : <code>xcb_get_geometry_cookie_t xcb_get_geometry(xcb_connection_t*, xcb_drawable_t)</code><br>
	 * @param c <<br>
	 * @param drawable <<br>
	 * <i>native declaration : xcb/xproto.h:4528</i><br>
	 * @deprecated use the safer method {@link #xcb_get_geometry(com.sun.jna.ptr.PointerByReference, int)} instead
	 */
	@Deprecated 
	xcb.xcb_get_geometry_cookie_t.ByValue xcb_get_geometry(Pointer c, int drawable);
	/**
	 * @brief Get current window geometry<br>
	 * @param c The connection<br>
	 * @param drawable The drawable (`Window` or `Pixmap`) of which the geometry will be received.<br>
	 * @return A cookie<br>
	 * Gets the current geometry of the specified drawable (either `Window` or `Pixmap`).<br>
	 * Original signature : <code>xcb_get_geometry_cookie_t xcb_get_geometry(xcb_connection_t*, xcb_drawable_t)</code><br>
	 * @param c <<br>
	 * @param drawable <<br>
	 * <i>native declaration : xcb/xproto.h:4528</i>
	 */
	xcb.xcb_get_geometry_cookie_t.ByValue xcb_get_geometry(PointerByReference c, int drawable);
	/**
	 * @brief Get current window geometry<br>
	 * @param c The connection<br>
	 * @param drawable The drawable (`Window` or `Pixmap`) of which the geometry will be received.<br>
	 * @return A cookie<br>
	 * Gets the current geometry of the specified drawable (either `Window` or `Pixmap`).<br>
	 * This form can be used only if the request will cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * placed in the event queue.<br>
	 * Original signature : <code>xcb_get_geometry_cookie_t xcb_get_geometry_unchecked(xcb_connection_t*, xcb_drawable_t)</code><br>
	 * @param c <<br>
	 * @param drawable <<br>
	 * <i>native declaration : xcb/xproto.h:4542</i><br>
	 * @deprecated use the safer method {@link #xcb_get_geometry_unchecked(com.sun.jna.ptr.PointerByReference, int)} instead
	 */
	@Deprecated 
	xcb.xcb_get_geometry_cookie_t.ByValue xcb_get_geometry_unchecked(Pointer c, int drawable);
	/**
	 * @brief Get current window geometry<br>
	 * @param c The connection<br>
	 * @param drawable The drawable (`Window` or `Pixmap`) of which the geometry will be received.<br>
	 * @return A cookie<br>
	 * Gets the current geometry of the specified drawable (either `Window` or `Pixmap`).<br>
	 * This form can be used only if the request will cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * placed in the event queue.<br>
	 * Original signature : <code>xcb_get_geometry_cookie_t xcb_get_geometry_unchecked(xcb_connection_t*, xcb_drawable_t)</code><br>
	 * @param c <<br>
	 * @param drawable <<br>
	 * <i>native declaration : xcb/xproto.h:4542</i>
	 */
	xcb.xcb_get_geometry_cookie_t.ByValue xcb_get_geometry_unchecked(PointerByReference c, int drawable);
	/**
	 * Return the reply<br>
	 * @param c      The connection<br>
	 * @param cookie The cookie<br>
	 * @param e      The xcb_generic_error_t supplied<br>
	 * Returns the reply of the request asked by<br>
	 * The parameter @p e supplied to this function must be NULL if<br>
	 * xcb_get_geometry_unchecked(). is used.<br>
	 * Otherwise, it stores the error if any.<br>
	 * The returned value must be freed by the caller using free().<br>
	 * Original signature : <code>xcb_get_geometry_reply_t* xcb_get_geometry_reply(xcb_connection_t*, xcb_get_geometry_cookie_t, xcb_generic_error_t**)</code><br>
	 * @param c <<br>
	 * @param cookie <<br>
	 * @param e <<br>
	 * <i>native declaration : xcb/xproto.h:4558</i><br>
	 * @deprecated use the safer method {@link #xcb_get_geometry_reply(com.sun.jna.ptr.PointerByReference, xcb.xcb_get_geometry_cookie_t.ByValue, xcb.xcb_generic_error_t.ByReference[])} instead
	 */
	@Deprecated 
	xcb_get_geometry_reply_t xcb_get_geometry_reply(Pointer c, xcb.xcb_get_geometry_cookie_t.ByValue cookie, PointerByReference e);
	/**
	 * Return the reply<br>
	 * @param c      The connection<br>
	 * @param cookie The cookie<br>
	 * @param e      The xcb_generic_error_t supplied<br>
	 * Returns the reply of the request asked by<br>
	 * The parameter @p e supplied to this function must be NULL if<br>
	 * xcb_get_geometry_unchecked(). is used.<br>
	 * Otherwise, it stores the error if any.<br>
	 * The returned value must be freed by the caller using free().<br>
	 * Original signature : <code>xcb_get_geometry_reply_t* xcb_get_geometry_reply(xcb_connection_t*, xcb_get_geometry_cookie_t, xcb_generic_error_t**)</code><br>
	 * @param c <<br>
	 * @param cookie <<br>
	 * @param e <<br>
	 * <i>native declaration : xcb/xproto.h:4558</i>
	 */
	xcb_get_geometry_reply_t xcb_get_geometry_reply(PointerByReference c, xcb.xcb_get_geometry_cookie_t.ByValue cookie, xcb_generic_error_t.ByReference e[]);
	/**
	 * Original signature : <code>int xcb_query_tree_sizeof(const void*)</code><br>
	 * @param _buffer <<br>
	 * <i>native declaration : xcb/xproto.h:4563</i>
	 */
	int xcb_query_tree_sizeof(Pointer _buffer);
	/**
	 * @brief query the window tree<br>
	 * @param c The connection<br>
	 * @param window The \a window to query.<br>
	 * @return A cookie<br>
	 * Gets the root window ID, parent window ID and list of children windows for the<br>
	 * specified \a window. The children are listed in bottom-to-top stacking order.<br>
	 * Original signature : <code>xcb_query_tree_cookie_t xcb_query_tree(xcb_connection_t*, xcb_window_t)</code><br>
	 * @param c <<br>
	 * @param window <<br>
	 * <i>native declaration : xcb/xproto.h:4575</i><br>
	 * @deprecated use the safer method {@link #xcb_query_tree(com.sun.jna.ptr.PointerByReference, int)} instead
	 */
	@Deprecated 
	xcb.xcb_query_tree_cookie_t.ByValue xcb_query_tree(Pointer c, int window);
	/**
	 * @brief query the window tree<br>
	 * @param c The connection<br>
	 * @param window The \a window to query.<br>
	 * @return A cookie<br>
	 * Gets the root window ID, parent window ID and list of children windows for the<br>
	 * specified \a window. The children are listed in bottom-to-top stacking order.<br>
	 * Original signature : <code>xcb_query_tree_cookie_t xcb_query_tree(xcb_connection_t*, xcb_window_t)</code><br>
	 * @param c <<br>
	 * @param window <<br>
	 * <i>native declaration : xcb/xproto.h:4575</i>
	 */
	xcb.xcb_query_tree_cookie_t.ByValue xcb_query_tree(PointerByReference c, int window);
	/**
	 * @brief query the window tree<br>
	 * @param c The connection<br>
	 * @param window The \a window to query.<br>
	 * @return A cookie<br>
	 * Gets the root window ID, parent window ID and list of children windows for the<br>
	 * specified \a window. The children are listed in bottom-to-top stacking order.<br>
	 * This form can be used only if the request will cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * placed in the event queue.<br>
	 * Original signature : <code>xcb_query_tree_cookie_t xcb_query_tree_unchecked(xcb_connection_t*, xcb_window_t)</code><br>
	 * @param c <<br>
	 * @param window <<br>
	 * <i>native declaration : xcb/xproto.h:4590</i><br>
	 * @deprecated use the safer method {@link #xcb_query_tree_unchecked(com.sun.jna.ptr.PointerByReference, int)} instead
	 */
	@Deprecated 
	xcb.xcb_query_tree_cookie_t.ByValue xcb_query_tree_unchecked(Pointer c, int window);
	/**
	 * @brief query the window tree<br>
	 * @param c The connection<br>
	 * @param window The \a window to query.<br>
	 * @return A cookie<br>
	 * Gets the root window ID, parent window ID and list of children windows for the<br>
	 * specified \a window. The children are listed in bottom-to-top stacking order.<br>
	 * This form can be used only if the request will cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * placed in the event queue.<br>
	 * Original signature : <code>xcb_query_tree_cookie_t xcb_query_tree_unchecked(xcb_connection_t*, xcb_window_t)</code><br>
	 * @param c <<br>
	 * @param window <<br>
	 * <i>native declaration : xcb/xproto.h:4590</i>
	 */
	xcb.xcb_query_tree_cookie_t.ByValue xcb_query_tree_unchecked(PointerByReference c, int window);
	/**
	 * Original signature : <code>xcb_window_t* xcb_query_tree_children(const xcb_query_tree_reply_t*)</code><br>
	 * @param R <<br>
	 * <i>native declaration : xcb/xproto.h:4595</i>
	 */
	IntByReference xcb_query_tree_children(xcb_query_tree_reply_t R);
	/**
	 * Original signature : <code>int xcb_query_tree_children_length(const xcb_query_tree_reply_t*)</code><br>
	 * @param R <<br>
	 * <i>native declaration : xcb/xproto.h:4600</i>
	 */
	int xcb_query_tree_children_length(xcb_query_tree_reply_t R);
	/**
	 * Original signature : <code>xcb_generic_iterator_t xcb_query_tree_children_end(const xcb_query_tree_reply_t*)</code><br>
	 * @param R <<br>
	 * <i>native declaration : xcb/xproto.h:4605</i>
	 */
	xcb.xcb_generic_iterator_t.ByValue xcb_query_tree_children_end(xcb_query_tree_reply_t R);
	/**
	 * Return the reply<br>
	 * @param c      The connection<br>
	 * @param cookie The cookie<br>
	 * @param e      The xcb_generic_error_t supplied<br>
	 * Returns the reply of the request asked by<br>
	 * The parameter @p e supplied to this function must be NULL if<br>
	 * xcb_query_tree_unchecked(). is used.<br>
	 * Otherwise, it stores the error if any.<br>
	 * The returned value must be freed by the caller using free().<br>
	 * Original signature : <code>xcb_query_tree_reply_t* xcb_query_tree_reply(xcb_connection_t*, xcb_query_tree_cookie_t, xcb_generic_error_t**)</code><br>
	 * @param c <<br>
	 * @param cookie <<br>
	 * @param e <<br>
	 * <i>native declaration : xcb/xproto.h:4621</i><br>
	 * @deprecated use the safer method {@link #xcb_query_tree_reply(com.sun.jna.ptr.PointerByReference, xcb.xcb_query_tree_cookie_t.ByValue, xcb.xcb_generic_error_t.ByReference[])} instead
	 */
	@Deprecated 
	xcb_query_tree_reply_t xcb_query_tree_reply(Pointer c, xcb.xcb_query_tree_cookie_t.ByValue cookie, PointerByReference e);
	/**
	 * Return the reply<br>
	 * @param c      The connection<br>
	 * @param cookie The cookie<br>
	 * @param e      The xcb_generic_error_t supplied<br>
	 * Returns the reply of the request asked by<br>
	 * The parameter @p e supplied to this function must be NULL if<br>
	 * xcb_query_tree_unchecked(). is used.<br>
	 * Otherwise, it stores the error if any.<br>
	 * The returned value must be freed by the caller using free().<br>
	 * Original signature : <code>xcb_query_tree_reply_t* xcb_query_tree_reply(xcb_connection_t*, xcb_query_tree_cookie_t, xcb_generic_error_t**)</code><br>
	 * @param c <<br>
	 * @param cookie <<br>
	 * @param e <<br>
	 * <i>native declaration : xcb/xproto.h:4621</i>
	 */
	xcb_query_tree_reply_t xcb_query_tree_reply(PointerByReference c, xcb.xcb_query_tree_cookie_t.ByValue cookie, xcb_generic_error_t.ByReference e[]);
	/**
	 * Original signature : <code>int xcb_intern_atom_sizeof(const void*)</code><br>
	 * @param _buffer <<br>
	 * <i>native declaration : xcb/xproto.h:4626</i>
	 */
	int xcb_intern_atom_sizeof(Pointer _buffer);
	/**
	 * @brief Get atom identifier by name<br>
	 * @param c The connection<br>
	 * @param only_if_exists Return a valid atom id only if the atom already exists.<br>
	 * @param name_len The length of the following \a name.<br>
	 * @param name The name of the atom.<br>
	 * @return A cookie<br>
	 * Retrieves the identifier (xcb_atom_t TODO) for the atom with the specified<br>
	 * name. Atoms are used in protocols like EWMH, for example to store window titles<br>
	 * (`_NET_WM_NAME` atom) as property of a window.<br>
	 * <br>
	 * If \a only_if_exists is 0, the atom will be created if it does not already exist.<br>
	 * If \a only_if_exists is 1, `XCB_ATOM_NONE` will be returned if the atom does<br>
	 * not yet exist.<br>
	 * Original signature : <code>xcb_intern_atom_cookie_t xcb_intern_atom(xcb_connection_t*, uint8_t, uint16_t, const char*)</code><br>
	 * @param c <<br>
	 * @param only_if_exists <<br>
	 * @param name_len <<br>
	 * @param name <<br>
	 * <i>native declaration : xcb/xproto.h:4647</i><br>
	 * @deprecated use the safer methods {@link #xcb_intern_atom(com.sun.jna.ptr.PointerByReference, byte, short, java.lang.String)} and {@link #xcb_intern_atom(com.sun.jna.ptr.PointerByReference, byte, short, com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	xcb.xcb_intern_atom_cookie_t.ByValue xcb_intern_atom(Pointer c, byte only_if_exists, short name_len, Pointer name);
	/**
	 * @brief Get atom identifier by name<br>
	 * @param c The connection<br>
	 * @param only_if_exists Return a valid atom id only if the atom already exists.<br>
	 * @param name_len The length of the following \a name.<br>
	 * @param name The name of the atom.<br>
	 * @return A cookie<br>
	 * Retrieves the identifier (xcb_atom_t TODO) for the atom with the specified<br>
	 * name. Atoms are used in protocols like EWMH, for example to store window titles<br>
	 * (`_NET_WM_NAME` atom) as property of a window.<br>
	 * <br>
	 * If \a only_if_exists is 0, the atom will be created if it does not already exist.<br>
	 * If \a only_if_exists is 1, `XCB_ATOM_NONE` will be returned if the atom does<br>
	 * not yet exist.<br>
	 * Original signature : <code>xcb_intern_atom_cookie_t xcb_intern_atom(xcb_connection_t*, uint8_t, uint16_t, const char*)</code><br>
	 * @param c <<br>
	 * @param only_if_exists <<br>
	 * @param name_len <<br>
	 * @param name <<br>
	 * <i>native declaration : xcb/xproto.h:4647</i>
	 */
	xcb.xcb_intern_atom_cookie_t.ByValue xcb_intern_atom(PointerByReference c, byte only_if_exists, short name_len, String name);
	/**
	 * @brief Get atom identifier by name<br>
	 * @param c The connection<br>
	 * @param only_if_exists Return a valid atom id only if the atom already exists.<br>
	 * @param name_len The length of the following \a name.<br>
	 * @param name The name of the atom.<br>
	 * @return A cookie<br>
	 * Retrieves the identifier (xcb_atom_t TODO) for the atom with the specified<br>
	 * name. Atoms are used in protocols like EWMH, for example to store window titles<br>
	 * (`_NET_WM_NAME` atom) as property of a window.<br>
	 * <br>
	 * If \a only_if_exists is 0, the atom will be created if it does not already exist.<br>
	 * If \a only_if_exists is 1, `XCB_ATOM_NONE` will be returned if the atom does<br>
	 * not yet exist.<br>
	 * Original signature : <code>xcb_intern_atom_cookie_t xcb_intern_atom(xcb_connection_t*, uint8_t, uint16_t, const char*)</code><br>
	 * @param c <<br>
	 * @param only_if_exists <<br>
	 * @param name_len <<br>
	 * @param name <<br>
	 * <i>native declaration : xcb/xproto.h:4647</i>
	 */
	xcb.xcb_intern_atom_cookie_t.ByValue xcb_intern_atom(PointerByReference c, byte only_if_exists, short name_len, Pointer name);
	/**
	 * @brief Get atom identifier by name<br>
	 * @param c The connection<br>
	 * @param only_if_exists Return a valid atom id only if the atom already exists.<br>
	 * @param name_len The length of the following \a name.<br>
	 * @param name The name of the atom.<br>
	 * @return A cookie<br>
	 * Retrieves the identifier (xcb_atom_t TODO) for the atom with the specified<br>
	 * name. Atoms are used in protocols like EWMH, for example to store window titles<br>
	 * (`_NET_WM_NAME` atom) as property of a window.<br>
	 * <br>
	 * If \a only_if_exists is 0, the atom will be created if it does not already exist.<br>
	 * If \a only_if_exists is 1, `XCB_ATOM_NONE` will be returned if the atom does<br>
	 * not yet exist.<br>
	 * This form can be used only if the request will cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * placed in the event queue.<br>
	 * Original signature : <code>xcb_intern_atom_cookie_t xcb_intern_atom_unchecked(xcb_connection_t*, uint8_t, uint16_t, const char*)</code><br>
	 * @param c <<br>
	 * @param only_if_exists <<br>
	 * @param name_len <<br>
	 * @param name <<br>
	 * <i>native declaration : xcb/xproto.h:4671</i><br>
	 * @deprecated use the safer methods {@link #xcb_intern_atom_unchecked(com.sun.jna.ptr.PointerByReference, byte, short, java.lang.String)} and {@link #xcb_intern_atom_unchecked(com.sun.jna.ptr.PointerByReference, byte, short, com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	xcb.xcb_intern_atom_cookie_t.ByValue xcb_intern_atom_unchecked(Pointer c, byte only_if_exists, short name_len, Pointer name);
	/**
	 * @brief Get atom identifier by name<br>
	 * @param c The connection<br>
	 * @param only_if_exists Return a valid atom id only if the atom already exists.<br>
	 * @param name_len The length of the following \a name.<br>
	 * @param name The name of the atom.<br>
	 * @return A cookie<br>
	 * Retrieves the identifier (xcb_atom_t TODO) for the atom with the specified<br>
	 * name. Atoms are used in protocols like EWMH, for example to store window titles<br>
	 * (`_NET_WM_NAME` atom) as property of a window.<br>
	 * <br>
	 * If \a only_if_exists is 0, the atom will be created if it does not already exist.<br>
	 * If \a only_if_exists is 1, `XCB_ATOM_NONE` will be returned if the atom does<br>
	 * not yet exist.<br>
	 * This form can be used only if the request will cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * placed in the event queue.<br>
	 * Original signature : <code>xcb_intern_atom_cookie_t xcb_intern_atom_unchecked(xcb_connection_t*, uint8_t, uint16_t, const char*)</code><br>
	 * @param c <<br>
	 * @param only_if_exists <<br>
	 * @param name_len <<br>
	 * @param name <<br>
	 * <i>native declaration : xcb/xproto.h:4671</i>
	 */
	xcb.xcb_intern_atom_cookie_t.ByValue xcb_intern_atom_unchecked(PointerByReference c, byte only_if_exists, short name_len, String name);
	/**
	 * @brief Get atom identifier by name<br>
	 * @param c The connection<br>
	 * @param only_if_exists Return a valid atom id only if the atom already exists.<br>
	 * @param name_len The length of the following \a name.<br>
	 * @param name The name of the atom.<br>
	 * @return A cookie<br>
	 * Retrieves the identifier (xcb_atom_t TODO) for the atom with the specified<br>
	 * name. Atoms are used in protocols like EWMH, for example to store window titles<br>
	 * (`_NET_WM_NAME` atom) as property of a window.<br>
	 * <br>
	 * If \a only_if_exists is 0, the atom will be created if it does not already exist.<br>
	 * If \a only_if_exists is 1, `XCB_ATOM_NONE` will be returned if the atom does<br>
	 * not yet exist.<br>
	 * This form can be used only if the request will cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * placed in the event queue.<br>
	 * Original signature : <code>xcb_intern_atom_cookie_t xcb_intern_atom_unchecked(xcb_connection_t*, uint8_t, uint16_t, const char*)</code><br>
	 * @param c <<br>
	 * @param only_if_exists <<br>
	 * @param name_len <<br>
	 * @param name <<br>
	 * <i>native declaration : xcb/xproto.h:4671</i>
	 */
	xcb.xcb_intern_atom_cookie_t.ByValue xcb_intern_atom_unchecked(PointerByReference c, byte only_if_exists, short name_len, Pointer name);
	/**
	 * Return the reply<br>
	 * @param c      The connection<br>
	 * @param cookie The cookie<br>
	 * @param e      The xcb_generic_error_t supplied<br>
	 * Returns the reply of the request asked by<br>
	 * The parameter @p e supplied to this function must be NULL if<br>
	 * xcb_intern_atom_unchecked(). is used.<br>
	 * Otherwise, it stores the error if any.<br>
	 * The returned value must be freed by the caller using free().<br>
	 * Original signature : <code>xcb_intern_atom_reply_t* xcb_intern_atom_reply(xcb_connection_t*, xcb_intern_atom_cookie_t, xcb_generic_error_t**)</code><br>
	 * @param c <<br>
	 * @param cookie <<br>
	 * @param e <<br>
	 * <i>native declaration : xcb/xproto.h:4687</i><br>
	 * @deprecated use the safer method {@link #xcb_intern_atom_reply(com.sun.jna.ptr.PointerByReference, xcb.xcb_intern_atom_cookie_t.ByValue, xcb.xcb_generic_error_t.ByReference[])} instead
	 */
	@Deprecated 
	xcb_intern_atom_reply_t xcb_intern_atom_reply(Pointer c, xcb.xcb_intern_atom_cookie_t.ByValue cookie, PointerByReference e);
	/**
	 * Return the reply<br>
	 * @param c      The connection<br>
	 * @param cookie The cookie<br>
	 * @param e      The xcb_generic_error_t supplied<br>
	 * Returns the reply of the request asked by<br>
	 * The parameter @p e supplied to this function must be NULL if<br>
	 * xcb_intern_atom_unchecked(). is used.<br>
	 * Otherwise, it stores the error if any.<br>
	 * The returned value must be freed by the caller using free().<br>
	 * Original signature : <code>xcb_intern_atom_reply_t* xcb_intern_atom_reply(xcb_connection_t*, xcb_intern_atom_cookie_t, xcb_generic_error_t**)</code><br>
	 * @param c <<br>
	 * @param cookie <<br>
	 * @param e <<br>
	 * <i>native declaration : xcb/xproto.h:4687</i>
	 */
	xcb_intern_atom_reply_t xcb_intern_atom_reply(PointerByReference c, xcb.xcb_intern_atom_cookie_t.ByValue cookie, xcb_generic_error_t.ByReference e[]);
	/**
	 * Original signature : <code>int xcb_get_atom_name_sizeof(const void*)</code><br>
	 * @param _buffer <<br>
	 * <i>native declaration : xcb/xproto.h:4692</i>
	 */
	int xcb_get_atom_name_sizeof(Pointer _buffer);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_get_atom_name_cookie_t xcb_get_atom_name(xcb_connection_t*, xcb_atom_t)</code><br>
	 * @param c <<br>
	 * @param atom <<br>
	 * <i>native declaration : xcb/xproto.h:4701</i><br>
	 * @deprecated use the safer method {@link #xcb_get_atom_name(com.sun.jna.ptr.PointerByReference, int)} instead
	 */
	@Deprecated 
	xcb.xcb_get_atom_name_cookie_t.ByValue xcb_get_atom_name(Pointer c, int atom);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_get_atom_name_cookie_t xcb_get_atom_name(xcb_connection_t*, xcb_atom_t)</code><br>
	 * @param c <<br>
	 * @param atom <<br>
	 * <i>native declaration : xcb/xproto.h:4701</i>
	 */
	xcb.xcb_get_atom_name_cookie_t.ByValue xcb_get_atom_name(PointerByReference c, int atom);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * placed in the event queue.<br>
	 * Original signature : <code>xcb_get_atom_name_cookie_t xcb_get_atom_name_unchecked(xcb_connection_t*, xcb_atom_t)</code><br>
	 * @param c <<br>
	 * @param atom <<br>
	 * <i>native declaration : xcb/xproto.h:4713</i><br>
	 * @deprecated use the safer method {@link #xcb_get_atom_name_unchecked(com.sun.jna.ptr.PointerByReference, int)} instead
	 */
	@Deprecated 
	xcb.xcb_get_atom_name_cookie_t.ByValue xcb_get_atom_name_unchecked(Pointer c, int atom);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * placed in the event queue.<br>
	 * Original signature : <code>xcb_get_atom_name_cookie_t xcb_get_atom_name_unchecked(xcb_connection_t*, xcb_atom_t)</code><br>
	 * @param c <<br>
	 * @param atom <<br>
	 * <i>native declaration : xcb/xproto.h:4713</i>
	 */
	xcb.xcb_get_atom_name_cookie_t.ByValue xcb_get_atom_name_unchecked(PointerByReference c, int atom);
	/**
	 * Original signature : <code>char* xcb_get_atom_name_name(const xcb_get_atom_name_reply_t*)</code><br>
	 * @param R <<br>
	 * <i>native declaration : xcb/xproto.h:4718</i>
	 */
	Pointer xcb_get_atom_name_name(xcb_get_atom_name_reply_t R);
	/**
	 * Original signature : <code>int xcb_get_atom_name_name_length(const xcb_get_atom_name_reply_t*)</code><br>
	 * @param R <<br>
	 * <i>native declaration : xcb/xproto.h:4723</i>
	 */
	int xcb_get_atom_name_name_length(xcb_get_atom_name_reply_t R);
	/**
	 * Original signature : <code>xcb_generic_iterator_t xcb_get_atom_name_name_end(const xcb_get_atom_name_reply_t*)</code><br>
	 * @param R <<br>
	 * <i>native declaration : xcb/xproto.h:4728</i>
	 */
	xcb.xcb_generic_iterator_t.ByValue xcb_get_atom_name_name_end(xcb_get_atom_name_reply_t R);
	/**
	 * Return the reply<br>
	 * @param c      The connection<br>
	 * @param cookie The cookie<br>
	 * @param e      The xcb_generic_error_t supplied<br>
	 * Returns the reply of the request asked by<br>
	 * The parameter @p e supplied to this function must be NULL if<br>
	 * xcb_get_atom_name_unchecked(). is used.<br>
	 * Otherwise, it stores the error if any.<br>
	 * The returned value must be freed by the caller using free().<br>
	 * Original signature : <code>xcb_get_atom_name_reply_t* xcb_get_atom_name_reply(xcb_connection_t*, xcb_get_atom_name_cookie_t, xcb_generic_error_t**)</code><br>
	 * @param c <<br>
	 * @param cookie <<br>
	 * @param e <<br>
	 * <i>native declaration : xcb/xproto.h:4744</i><br>
	 * @deprecated use the safer method {@link #xcb_get_atom_name_reply(com.sun.jna.ptr.PointerByReference, xcb.xcb_get_atom_name_cookie_t.ByValue, xcb.xcb_generic_error_t.ByReference[])} instead
	 */
	@Deprecated 
	xcb_get_atom_name_reply_t xcb_get_atom_name_reply(Pointer c, xcb.xcb_get_atom_name_cookie_t.ByValue cookie, PointerByReference e);
	/**
	 * Return the reply<br>
	 * @param c      The connection<br>
	 * @param cookie The cookie<br>
	 * @param e      The xcb_generic_error_t supplied<br>
	 * Returns the reply of the request asked by<br>
	 * The parameter @p e supplied to this function must be NULL if<br>
	 * xcb_get_atom_name_unchecked(). is used.<br>
	 * Otherwise, it stores the error if any.<br>
	 * The returned value must be freed by the caller using free().<br>
	 * Original signature : <code>xcb_get_atom_name_reply_t* xcb_get_atom_name_reply(xcb_connection_t*, xcb_get_atom_name_cookie_t, xcb_generic_error_t**)</code><br>
	 * @param c <<br>
	 * @param cookie <<br>
	 * @param e <<br>
	 * <i>native declaration : xcb/xproto.h:4744</i>
	 */
	xcb_get_atom_name_reply_t xcb_get_atom_name_reply(PointerByReference c, xcb.xcb_get_atom_name_cookie_t.ByValue cookie, xcb_generic_error_t.ByReference e[]);
	/**
	 * Original signature : <code>int xcb_change_property_sizeof(const void*)</code><br>
	 * @param _buffer <<br>
	 * <i>native declaration : xcb/xproto.h:4749</i>
	 */
	int xcb_change_property_sizeof(Pointer _buffer);
	/**
	 * @brief Changes a window property<br>
	 * @param c The connection<br>
	 * @param mode A bitmask of #xcb_prop_mode_t values.<br>
	 * @param mode \n<br>
	 * @param window The window whose property you want to change.<br>
	 * @param property The property you want to change (an atom).<br>
	 * @param type The type of the property you want to change (an atom).<br>
	 * @param format Specifies whether the data should be viewed as a list of 8-bit, 16-bit or<br>
	 * 32-bit quantities. Possible values are 8, 16 and 32. This information allows<br>
	 * the X server to correctly perform byte-swap operations as necessary.<br>
	 * @param data_len Specifies the number of elements (see \a format).<br>
	 * @param data The property data.<br>
	 * @return A cookie<br>
	 * Sets or updates a property on the specified \a window. Properties are for<br>
	 * example the window title (`WM_NAME`) or its minimum size (`WM_NORMAL_HINTS`).<br>
	 * Protocols such as EWMH also use properties - for example EWMH defines the<br>
	 * window title, encoded as UTF-8 string, in the `_NET_WM_NAME` property.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_change_property_checked(xcb_connection_t*, uint8_t, xcb_window_t, __declspec(property) xcb_atom_t, xcb_atom_t, uint8_t, uint32_t, const void*)</code><br>
	 * @param c <<br>
	 * @param mode <<br>
	 * @param window <<br>
	 * @param type <<br>
	 * @param format <<br>
	 * @param data_len <<br>
	 * @param data <<br>
	 * <i>native declaration : xcb/xproto.h:4780</i><br>
	 * @deprecated use the safer method {@link #xcb_change_property_checked(com.sun.jna.ptr.PointerByReference, byte, int, int, int, byte, int, com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	xcb.xcb_void_cookie_t.ByValue xcb_change_property_checked(Pointer c, byte mode, int window, int xcb_atom_t1, int type, byte format, int data_len, Pointer data);
	/**
	 * @brief Changes a window property<br>
	 * @param c The connection<br>
	 * @param mode A bitmask of #xcb_prop_mode_t values.<br>
	 * @param mode \n<br>
	 * @param window The window whose property you want to change.<br>
	 * @param property The property you want to change (an atom).<br>
	 * @param type The type of the property you want to change (an atom).<br>
	 * @param format Specifies whether the data should be viewed as a list of 8-bit, 16-bit or<br>
	 * 32-bit quantities. Possible values are 8, 16 and 32. This information allows<br>
	 * the X server to correctly perform byte-swap operations as necessary.<br>
	 * @param data_len Specifies the number of elements (see \a format).<br>
	 * @param data The property data.<br>
	 * @return A cookie<br>
	 * Sets or updates a property on the specified \a window. Properties are for<br>
	 * example the window title (`WM_NAME`) or its minimum size (`WM_NORMAL_HINTS`).<br>
	 * Protocols such as EWMH also use properties - for example EWMH defines the<br>
	 * window title, encoded as UTF-8 string, in the `_NET_WM_NAME` property.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_change_property_checked(xcb_connection_t*, uint8_t, xcb_window_t, __declspec(property) xcb_atom_t, xcb_atom_t, uint8_t, uint32_t, const void*)</code><br>
	 * @param c <<br>
	 * @param mode <<br>
	 * @param window <<br>
	 * @param type <<br>
	 * @param format <<br>
	 * @param data_len <<br>
	 * @param data <<br>
	 * <i>native declaration : xcb/xproto.h:4780</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_change_property_checked(PointerByReference c, byte mode, int window, int xcb_atom_t1, int type, byte format, int data_len, Pointer data);
	/**
	 * @brief Changes a window property<br>
	 * @param c The connection<br>
	 * @param mode A bitmask of #xcb_prop_mode_t values.<br>
	 * @param mode \n<br>
	 * @param window The window whose property you want to change.<br>
	 * @param property The property you want to change (an atom).<br>
	 * @param type The type of the property you want to change (an atom).<br>
	 * @param format Specifies whether the data should be viewed as a list of 8-bit, 16-bit or<br>
	 * 32-bit quantities. Possible values are 8, 16 and 32. This information allows<br>
	 * the X server to correctly perform byte-swap operations as necessary.<br>
	 * @param data_len Specifies the number of elements (see \a format).<br>
	 * @param data The property data.<br>
	 * @return A cookie<br>
	 * Sets or updates a property on the specified \a window. Properties are for<br>
	 * example the window title (`WM_NAME`) or its minimum size (`WM_NORMAL_HINTS`).<br>
	 * Protocols such as EWMH also use properties - for example EWMH defines the<br>
	 * window title, encoded as UTF-8 string, in the `_NET_WM_NAME` property.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_change_property(xcb_connection_t*, uint8_t, xcb_window_t, __declspec(property) xcb_atom_t, xcb_atom_t, uint8_t, uint32_t, const void*)</code><br>
	 * @param c <<br>
	 * @param mode <<br>
	 * @param window <<br>
	 * @param type <<br>
	 * @param format <<br>
	 * @param data_len <<br>
	 * @param data <<br>
	 * <i>native declaration : xcb/xproto.h:4808</i><br>
	 * @deprecated use the safer method {@link #xcb_change_property(com.sun.jna.ptr.PointerByReference, byte, int, int, int, byte, int, com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	xcb.xcb_void_cookie_t.ByValue xcb_change_property(Pointer c, byte mode, int window, int xcb_atom_t1, int type, byte format, int data_len, Pointer data);
	/**
	 * @brief Changes a window property<br>
	 * @param c The connection<br>
	 * @param mode A bitmask of #xcb_prop_mode_t values.<br>
	 * @param mode \n<br>
	 * @param window The window whose property you want to change.<br>
	 * @param property The property you want to change (an atom).<br>
	 * @param type The type of the property you want to change (an atom).<br>
	 * @param format Specifies whether the data should be viewed as a list of 8-bit, 16-bit or<br>
	 * 32-bit quantities. Possible values are 8, 16 and 32. This information allows<br>
	 * the X server to correctly perform byte-swap operations as necessary.<br>
	 * @param data_len Specifies the number of elements (see \a format).<br>
	 * @param data The property data.<br>
	 * @return A cookie<br>
	 * Sets or updates a property on the specified \a window. Properties are for<br>
	 * example the window title (`WM_NAME`) or its minimum size (`WM_NORMAL_HINTS`).<br>
	 * Protocols such as EWMH also use properties - for example EWMH defines the<br>
	 * window title, encoded as UTF-8 string, in the `_NET_WM_NAME` property.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_change_property(xcb_connection_t*, uint8_t, xcb_window_t, __declspec(property) xcb_atom_t, xcb_atom_t, uint8_t, uint32_t, const void*)</code><br>
	 * @param c <<br>
	 * @param mode <<br>
	 * @param window <<br>
	 * @param type <<br>
	 * @param format <<br>
	 * @param data_len <<br>
	 * @param data <<br>
	 * <i>native declaration : xcb/xproto.h:4808</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_change_property(PointerByReference c, byte mode, int window, int xcb_atom_t1, int type, byte format, int data_len, Pointer data);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_delete_property_checked(xcb_connection_t*, xcb_window_t, __declspec(property) xcb_atom_t)</code><br>
	 * @param c <<br>
	 * @param window <<br>
	 * <i>native declaration : xcb/xproto.h:4820</i><br>
	 * @deprecated use the safer method {@link #xcb_delete_property_checked(com.sun.jna.ptr.PointerByReference, int, int)} instead
	 */
	@Deprecated 
	xcb.xcb_void_cookie_t.ByValue xcb_delete_property_checked(Pointer c, int window, int xcb_atom_t1);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_delete_property_checked(xcb_connection_t*, xcb_window_t, __declspec(property) xcb_atom_t)</code><br>
	 * @param c <<br>
	 * @param window <<br>
	 * <i>native declaration : xcb/xproto.h:4820</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_delete_property_checked(PointerByReference c, int window, int xcb_atom_t1);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_delete_property(xcb_connection_t*, xcb_window_t, __declspec(property) xcb_atom_t)</code><br>
	 * @param c <<br>
	 * @param window <<br>
	 * <i>native declaration : xcb/xproto.h:4829</i><br>
	 * @deprecated use the safer method {@link #xcb_delete_property(com.sun.jna.ptr.PointerByReference, int, int)} instead
	 */
	@Deprecated 
	xcb.xcb_void_cookie_t.ByValue xcb_delete_property(Pointer c, int window, int xcb_atom_t1);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_delete_property(xcb_connection_t*, xcb_window_t, __declspec(property) xcb_atom_t)</code><br>
	 * @param c <<br>
	 * @param window <<br>
	 * <i>native declaration : xcb/xproto.h:4829</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_delete_property(PointerByReference c, int window, int xcb_atom_t1);
	/**
	 * Original signature : <code>int xcb_get_property_sizeof(const void*)</code><br>
	 * @param _buffer <<br>
	 * <i>native declaration : xcb/xproto.h:4834</i>
	 */
	int xcb_get_property_sizeof(Pointer _buffer);
	/**
	 * @brief Gets a window property<br>
	 * @param c The connection<br>
	 * @param _delete Whether the property should actually be deleted. For deleting a property, the<br>
	 * specified \a type has to match the actual property type.<br>
	 * @param window The window whose property you want to get.<br>
	 * @param property The property you want to get (an atom).<br>
	 * @param type The type of the property you want to get (an atom).<br>
	 * @param long_offset Specifies the offset (in 32-bit multiples) in the specified property where the<br>
	 * data is to be retrieved.<br>
	 * @param long_length Specifies how many 32-bit multiples of data should be retrieved (e.g. if you<br>
	 * set \a long_length to 4, you will receive 16 bytes of data).<br>
	 * @return A cookie<br>
	 * Gets the specified \a property from the specified \a window. Properties are for<br>
	 * example the window title (`WM_NAME`) or its minimum size (`WM_NORMAL_HINTS`).<br>
	 * Protocols such as EWMH also use properties - for example EWMH defines the<br>
	 * window title, encoded as UTF-8 string, in the `_NET_WM_NAME` property.<br>
	 * <br>
	 * TODO: talk about \a type<br>
	 * <br>
	 * TODO: talk about `delete`<br>
	 * <br>
	 * TODO: talk about the offset/length thing. what's a valid use case?<br>
	 * Original signature : <code>xcb_get_property_cookie_t xcb_get_property(xcb_connection_t*, uint8_t, xcb_window_t, __declspec(property) xcb_atom_t, xcb_atom_t, uint32_t, uint32_t)</code><br>
	 * @param c <<br>
	 * @param _delete <<br>
	 * @param window <<br>
	 * @param type <<br>
	 * @param long_offset <<br>
	 * @param long_length <<br>
	 * <i>native declaration : xcb/xproto.h:4866</i><br>
	 * @deprecated use the safer method {@link #xcb_get_property(com.sun.jna.ptr.PointerByReference, byte, int, int, int, int, int)} instead
	 */
	@Deprecated 
	xcb.xcb_get_property_cookie_t.ByValue xcb_get_property(Pointer c, byte _delete, int window, int xcb_atom_t1, int type, int long_offset, int long_length);
	/**
	 * @brief Gets a window property<br>
	 * @param c The connection<br>
	 * @param _delete Whether the property should actually be deleted. For deleting a property, the<br>
	 * specified \a type has to match the actual property type.<br>
	 * @param window The window whose property you want to get.<br>
	 * @param property The property you want to get (an atom).<br>
	 * @param type The type of the property you want to get (an atom).<br>
	 * @param long_offset Specifies the offset (in 32-bit multiples) in the specified property where the<br>
	 * data is to be retrieved.<br>
	 * @param long_length Specifies how many 32-bit multiples of data should be retrieved (e.g. if you<br>
	 * set \a long_length to 4, you will receive 16 bytes of data).<br>
	 * @return A cookie<br>
	 * Gets the specified \a property from the specified \a window. Properties are for<br>
	 * example the window title (`WM_NAME`) or its minimum size (`WM_NORMAL_HINTS`).<br>
	 * Protocols such as EWMH also use properties - for example EWMH defines the<br>
	 * window title, encoded as UTF-8 string, in the `_NET_WM_NAME` property.<br>
	 * <br>
	 * TODO: talk about \a type<br>
	 * <br>
	 * TODO: talk about `delete`<br>
	 * <br>
	 * TODO: talk about the offset/length thing. what's a valid use case?<br>
	 * Original signature : <code>xcb_get_property_cookie_t xcb_get_property(xcb_connection_t*, uint8_t, xcb_window_t, __declspec(property) xcb_atom_t, xcb_atom_t, uint32_t, uint32_t)</code><br>
	 * @param c <<br>
	 * @param _delete <<br>
	 * @param window <<br>
	 * @param type <<br>
	 * @param long_offset <<br>
	 * @param long_length <<br>
	 * <i>native declaration : xcb/xproto.h:4866</i>
	 */
	xcb.xcb_get_property_cookie_t.ByValue xcb_get_property(PointerByReference c, byte _delete, int window, int xcb_atom_t1, int type, int long_offset, int long_length);
	/**
	 * @brief Gets a window property<br>
	 * @param c The connection<br>
	 * @param _delete Whether the property should actually be deleted. For deleting a property, the<br>
	 * specified \a type has to match the actual property type.<br>
	 * @param window The window whose property you want to get.<br>
	 * @param property The property you want to get (an atom).<br>
	 * @param type The type of the property you want to get (an atom).<br>
	 * @param long_offset Specifies the offset (in 32-bit multiples) in the specified property where the<br>
	 * data is to be retrieved.<br>
	 * @param long_length Specifies how many 32-bit multiples of data should be retrieved (e.g. if you<br>
	 * set \a long_length to 4, you will receive 16 bytes of data).<br>
	 * @return A cookie<br>
	 * Gets the specified \a property from the specified \a window. Properties are for<br>
	 * example the window title (`WM_NAME`) or its minimum size (`WM_NORMAL_HINTS`).<br>
	 * Protocols such as EWMH also use properties - for example EWMH defines the<br>
	 * window title, encoded as UTF-8 string, in the `_NET_WM_NAME` property.<br>
	 * <br>
	 * TODO: talk about \a type<br>
	 * <br>
	 * TODO: talk about `delete`<br>
	 * <br>
	 * TODO: talk about the offset/length thing. what's a valid use case?<br>
	 * This form can be used only if the request will cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * placed in the event queue.<br>
	 * Original signature : <code>xcb_get_property_cookie_t xcb_get_property_unchecked(xcb_connection_t*, uint8_t, xcb_window_t, __declspec(property) xcb_atom_t, xcb_atom_t, uint32_t, uint32_t)</code><br>
	 * @param c <<br>
	 * @param _delete <<br>
	 * @param window <<br>
	 * @param type <<br>
	 * @param long_offset <<br>
	 * @param long_length <<br>
	 * <i>native declaration : xcb/xproto.h:4901</i><br>
	 * @deprecated use the safer method {@link #xcb_get_property_unchecked(com.sun.jna.ptr.PointerByReference, byte, int, int, int, int, int)} instead
	 */
	@Deprecated 
	xcb.xcb_get_property_cookie_t.ByValue xcb_get_property_unchecked(Pointer c, byte _delete, int window, int xcb_atom_t1, int type, int long_offset, int long_length);
	/**
	 * @brief Gets a window property<br>
	 * @param c The connection<br>
	 * @param _delete Whether the property should actually be deleted. For deleting a property, the<br>
	 * specified \a type has to match the actual property type.<br>
	 * @param window The window whose property you want to get.<br>
	 * @param property The property you want to get (an atom).<br>
	 * @param type The type of the property you want to get (an atom).<br>
	 * @param long_offset Specifies the offset (in 32-bit multiples) in the specified property where the<br>
	 * data is to be retrieved.<br>
	 * @param long_length Specifies how many 32-bit multiples of data should be retrieved (e.g. if you<br>
	 * set \a long_length to 4, you will receive 16 bytes of data).<br>
	 * @return A cookie<br>
	 * Gets the specified \a property from the specified \a window. Properties are for<br>
	 * example the window title (`WM_NAME`) or its minimum size (`WM_NORMAL_HINTS`).<br>
	 * Protocols such as EWMH also use properties - for example EWMH defines the<br>
	 * window title, encoded as UTF-8 string, in the `_NET_WM_NAME` property.<br>
	 * <br>
	 * TODO: talk about \a type<br>
	 * <br>
	 * TODO: talk about `delete`<br>
	 * <br>
	 * TODO: talk about the offset/length thing. what's a valid use case?<br>
	 * This form can be used only if the request will cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * placed in the event queue.<br>
	 * Original signature : <code>xcb_get_property_cookie_t xcb_get_property_unchecked(xcb_connection_t*, uint8_t, xcb_window_t, __declspec(property) xcb_atom_t, xcb_atom_t, uint32_t, uint32_t)</code><br>
	 * @param c <<br>
	 * @param _delete <<br>
	 * @param window <<br>
	 * @param type <<br>
	 * @param long_offset <<br>
	 * @param long_length <<br>
	 * <i>native declaration : xcb/xproto.h:4901</i>
	 */
	xcb.xcb_get_property_cookie_t.ByValue xcb_get_property_unchecked(PointerByReference c, byte _delete, int window, int xcb_atom_t1, int type, int long_offset, int long_length);
	/**
	 * Original signature : <code>void* xcb_get_property_value(const xcb_get_property_reply_t*)</code><br>
	 * @param R <<br>
	 * <i>native declaration : xcb/xproto.h:4906</i>
	 */
	Pointer xcb_get_property_value(xcb_get_property_reply_t R);
	/**
	 * Original signature : <code>int xcb_get_property_value_length(const xcb_get_property_reply_t*)</code><br>
	 * @param R <<br>
	 * <i>native declaration : xcb/xproto.h:4911</i>
	 */
	int xcb_get_property_value_length(xcb_get_property_reply_t R);
	/**
	 * Original signature : <code>xcb_generic_iterator_t xcb_get_property_value_end(const xcb_get_property_reply_t*)</code><br>
	 * @param R <<br>
	 * <i>native declaration : xcb/xproto.h:4916</i>
	 */
	xcb.xcb_generic_iterator_t.ByValue xcb_get_property_value_end(xcb_get_property_reply_t R);
	/**
	 * Return the reply<br>
	 * @param c      The connection<br>
	 * @param cookie The cookie<br>
	 * @param e      The xcb_generic_error_t supplied<br>
	 * Returns the reply of the request asked by<br>
	 * The parameter @p e supplied to this function must be NULL if<br>
	 * xcb_get_property_unchecked(). is used.<br>
	 * Otherwise, it stores the error if any.<br>
	 * The returned value must be freed by the caller using free().<br>
	 * Original signature : <code>xcb_get_property_reply_t* xcb_get_property_reply(xcb_connection_t*, xcb_get_property_cookie_t, xcb_generic_error_t**)</code><br>
	 * @param c <<br>
	 * @param cookie <<br>
	 * @param e <<br>
	 * <i>native declaration : xcb/xproto.h:4932</i><br>
	 * @deprecated use the safer method {@link #xcb_get_property_reply(com.sun.jna.ptr.PointerByReference, xcb.xcb_get_property_cookie_t.ByValue, xcb.xcb_generic_error_t.ByReference[])} instead
	 */
	@Deprecated 
	xcb_get_property_reply_t xcb_get_property_reply(Pointer c, xcb.xcb_get_property_cookie_t.ByValue cookie, PointerByReference e);
	/**
	 * Return the reply<br>
	 * @param c      The connection<br>
	 * @param cookie The cookie<br>
	 * @param e      The xcb_generic_error_t supplied<br>
	 * Returns the reply of the request asked by<br>
	 * The parameter @p e supplied to this function must be NULL if<br>
	 * xcb_get_property_unchecked(). is used.<br>
	 * Otherwise, it stores the error if any.<br>
	 * The returned value must be freed by the caller using free().<br>
	 * Original signature : <code>xcb_get_property_reply_t* xcb_get_property_reply(xcb_connection_t*, xcb_get_property_cookie_t, xcb_generic_error_t**)</code><br>
	 * @param c <<br>
	 * @param cookie <<br>
	 * @param e <<br>
	 * <i>native declaration : xcb/xproto.h:4932</i>
	 */
	xcb_get_property_reply_t xcb_get_property_reply(PointerByReference c, xcb.xcb_get_property_cookie_t.ByValue cookie, xcb_generic_error_t.ByReference e[]);
	/**
	 * Original signature : <code>int xcb_list_properties_sizeof(const void*)</code><br>
	 * @param _buffer <<br>
	 * <i>native declaration : xcb/xproto.h:4937</i>
	 */
	int xcb_list_properties_sizeof(Pointer _buffer);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_list_properties_cookie_t xcb_list_properties(xcb_connection_t*, xcb_window_t)</code><br>
	 * @param c <<br>
	 * @param window <<br>
	 * <i>native declaration : xcb/xproto.h:4946</i><br>
	 * @deprecated use the safer method {@link #xcb_list_properties(com.sun.jna.ptr.PointerByReference, int)} instead
	 */
	@Deprecated 
	xcb.xcb_list_properties_cookie_t.ByValue xcb_list_properties(Pointer c, int window);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_list_properties_cookie_t xcb_list_properties(xcb_connection_t*, xcb_window_t)</code><br>
	 * @param c <<br>
	 * @param window <<br>
	 * <i>native declaration : xcb/xproto.h:4946</i>
	 */
	xcb.xcb_list_properties_cookie_t.ByValue xcb_list_properties(PointerByReference c, int window);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * placed in the event queue.<br>
	 * Original signature : <code>xcb_list_properties_cookie_t xcb_list_properties_unchecked(xcb_connection_t*, xcb_window_t)</code><br>
	 * @param c <<br>
	 * @param window <<br>
	 * <i>native declaration : xcb/xproto.h:4958</i><br>
	 * @deprecated use the safer method {@link #xcb_list_properties_unchecked(com.sun.jna.ptr.PointerByReference, int)} instead
	 */
	@Deprecated 
	xcb.xcb_list_properties_cookie_t.ByValue xcb_list_properties_unchecked(Pointer c, int window);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * placed in the event queue.<br>
	 * Original signature : <code>xcb_list_properties_cookie_t xcb_list_properties_unchecked(xcb_connection_t*, xcb_window_t)</code><br>
	 * @param c <<br>
	 * @param window <<br>
	 * <i>native declaration : xcb/xproto.h:4958</i>
	 */
	xcb.xcb_list_properties_cookie_t.ByValue xcb_list_properties_unchecked(PointerByReference c, int window);
	/**
	 * Original signature : <code>xcb_atom_t* xcb_list_properties_atoms(const xcb_list_properties_reply_t*)</code><br>
	 * @param R <<br>
	 * <i>native declaration : xcb/xproto.h:4963</i>
	 */
	IntByReference xcb_list_properties_atoms(xcb_list_properties_reply_t R);
	/**
	 * Original signature : <code>int xcb_list_properties_atoms_length(const xcb_list_properties_reply_t*)</code><br>
	 * @param R <<br>
	 * <i>native declaration : xcb/xproto.h:4968</i>
	 */
	int xcb_list_properties_atoms_length(xcb_list_properties_reply_t R);
	/**
	 * Original signature : <code>xcb_generic_iterator_t xcb_list_properties_atoms_end(const xcb_list_properties_reply_t*)</code><br>
	 * @param R <<br>
	 * <i>native declaration : xcb/xproto.h:4973</i>
	 */
	xcb.xcb_generic_iterator_t.ByValue xcb_list_properties_atoms_end(xcb_list_properties_reply_t R);
	/**
	 * Return the reply<br>
	 * @param c      The connection<br>
	 * @param cookie The cookie<br>
	 * @param e      The xcb_generic_error_t supplied<br>
	 * Returns the reply of the request asked by<br>
	 * The parameter @p e supplied to this function must be NULL if<br>
	 * xcb_list_properties_unchecked(). is used.<br>
	 * Otherwise, it stores the error if any.<br>
	 * The returned value must be freed by the caller using free().<br>
	 * Original signature : <code>xcb_list_properties_reply_t* xcb_list_properties_reply(xcb_connection_t*, xcb_list_properties_cookie_t, xcb_generic_error_t**)</code><br>
	 * @param c <<br>
	 * @param cookie <<br>
	 * @param e <<br>
	 * <i>native declaration : xcb/xproto.h:4989</i><br>
	 * @deprecated use the safer method {@link #xcb_list_properties_reply(com.sun.jna.ptr.PointerByReference, xcb.xcb_list_properties_cookie_t.ByValue, xcb.xcb_generic_error_t.ByReference[])} instead
	 */
	@Deprecated 
	xcb_list_properties_reply_t xcb_list_properties_reply(Pointer c, xcb.xcb_list_properties_cookie_t.ByValue cookie, PointerByReference e);
	/**
	 * Return the reply<br>
	 * @param c      The connection<br>
	 * @param cookie The cookie<br>
	 * @param e      The xcb_generic_error_t supplied<br>
	 * Returns the reply of the request asked by<br>
	 * The parameter @p e supplied to this function must be NULL if<br>
	 * xcb_list_properties_unchecked(). is used.<br>
	 * Otherwise, it stores the error if any.<br>
	 * The returned value must be freed by the caller using free().<br>
	 * Original signature : <code>xcb_list_properties_reply_t* xcb_list_properties_reply(xcb_connection_t*, xcb_list_properties_cookie_t, xcb_generic_error_t**)</code><br>
	 * @param c <<br>
	 * @param cookie <<br>
	 * @param e <<br>
	 * <i>native declaration : xcb/xproto.h:4989</i>
	 */
	xcb_list_properties_reply_t xcb_list_properties_reply(PointerByReference c, xcb.xcb_list_properties_cookie_t.ByValue cookie, xcb_generic_error_t.ByReference e[]);
	/**
	 * @brief Sets the owner of a selection<br>
	 * @param c The connection<br>
	 * @param owner The new owner of the selection.<br>
	 * \n<br>
	 * The special value `XCB_NONE` means that the selection will have no owner.<br>
	 * @param selection The selection.<br>
	 * @param time Timestamp to avoid race conditions when running X over the network.<br>
	 * \n<br>
	 * The selection will not be changed if \a time is earlier than the current<br>
	 * last-change time of the \a selection or is later than the current X server time.<br>
	 * Otherwise, the last-change time is set to the specified time.<br>
	 * \n<br>
	 * The special value `XCB_CURRENT_TIME` will be replaced with the current server<br>
	 * time.<br>
	 * @return A cookie<br>
	 * Makes `window` the owner of the selection \a selection and updates the<br>
	 * last-change time of the specified selection.<br>
	 * <br>
	 * TODO: briefly explain what a selection is.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_set_selection_owner_checked(xcb_connection_t*, xcb_window_t, xcb_atom_t, xcb_timestamp_t)</code><br>
	 * @param c <<br>
	 * @param owner <<br>
	 * @param selection <<br>
	 * @param time <<br>
	 * <i>native declaration : xcb/xproto.h:5019</i><br>
	 * @deprecated use the safer method {@link #xcb_set_selection_owner_checked(com.sun.jna.ptr.PointerByReference, int, int, int)} instead
	 */
	@Deprecated 
	xcb.xcb_void_cookie_t.ByValue xcb_set_selection_owner_checked(Pointer c, int owner, int selection, int time);
	/**
	 * @brief Sets the owner of a selection<br>
	 * @param c The connection<br>
	 * @param owner The new owner of the selection.<br>
	 * \n<br>
	 * The special value `XCB_NONE` means that the selection will have no owner.<br>
	 * @param selection The selection.<br>
	 * @param time Timestamp to avoid race conditions when running X over the network.<br>
	 * \n<br>
	 * The selection will not be changed if \a time is earlier than the current<br>
	 * last-change time of the \a selection or is later than the current X server time.<br>
	 * Otherwise, the last-change time is set to the specified time.<br>
	 * \n<br>
	 * The special value `XCB_CURRENT_TIME` will be replaced with the current server<br>
	 * time.<br>
	 * @return A cookie<br>
	 * Makes `window` the owner of the selection \a selection and updates the<br>
	 * last-change time of the specified selection.<br>
	 * <br>
	 * TODO: briefly explain what a selection is.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_set_selection_owner_checked(xcb_connection_t*, xcb_window_t, xcb_atom_t, xcb_timestamp_t)</code><br>
	 * @param c <<br>
	 * @param owner <<br>
	 * @param selection <<br>
	 * @param time <<br>
	 * <i>native declaration : xcb/xproto.h:5019</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_set_selection_owner_checked(PointerByReference c, int owner, int selection, int time);
	/**
	 * @brief Sets the owner of a selection<br>
	 * @param c The connection<br>
	 * @param owner The new owner of the selection.<br>
	 * \n<br>
	 * The special value `XCB_NONE` means that the selection will have no owner.<br>
	 * @param selection The selection.<br>
	 * @param time Timestamp to avoid race conditions when running X over the network.<br>
	 * \n<br>
	 * The selection will not be changed if \a time is earlier than the current<br>
	 * last-change time of the \a selection or is later than the current X server time.<br>
	 * Otherwise, the last-change time is set to the specified time.<br>
	 * \n<br>
	 * The special value `XCB_CURRENT_TIME` will be replaced with the current server<br>
	 * time.<br>
	 * @return A cookie<br>
	 * Makes `window` the owner of the selection \a selection and updates the<br>
	 * last-change time of the specified selection.<br>
	 * <br>
	 * TODO: briefly explain what a selection is.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_set_selection_owner(xcb_connection_t*, xcb_window_t, xcb_atom_t, xcb_timestamp_t)</code><br>
	 * @param c <<br>
	 * @param owner <<br>
	 * @param selection <<br>
	 * @param time <<br>
	 * <i>native declaration : xcb/xproto.h:5046</i><br>
	 * @deprecated use the safer method {@link #xcb_set_selection_owner(com.sun.jna.ptr.PointerByReference, int, int, int)} instead
	 */
	@Deprecated 
	xcb.xcb_void_cookie_t.ByValue xcb_set_selection_owner(Pointer c, int owner, int selection, int time);
	/**
	 * @brief Sets the owner of a selection<br>
	 * @param c The connection<br>
	 * @param owner The new owner of the selection.<br>
	 * \n<br>
	 * The special value `XCB_NONE` means that the selection will have no owner.<br>
	 * @param selection The selection.<br>
	 * @param time Timestamp to avoid race conditions when running X over the network.<br>
	 * \n<br>
	 * The selection will not be changed if \a time is earlier than the current<br>
	 * last-change time of the \a selection or is later than the current X server time.<br>
	 * Otherwise, the last-change time is set to the specified time.<br>
	 * \n<br>
	 * The special value `XCB_CURRENT_TIME` will be replaced with the current server<br>
	 * time.<br>
	 * @return A cookie<br>
	 * Makes `window` the owner of the selection \a selection and updates the<br>
	 * last-change time of the specified selection.<br>
	 * <br>
	 * TODO: briefly explain what a selection is.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_set_selection_owner(xcb_connection_t*, xcb_window_t, xcb_atom_t, xcb_timestamp_t)</code><br>
	 * @param c <<br>
	 * @param owner <<br>
	 * @param selection <<br>
	 * @param time <<br>
	 * <i>native declaration : xcb/xproto.h:5046</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_set_selection_owner(PointerByReference c, int owner, int selection, int time);
	/**
	 * @brief Gets the owner of a selection<br>
	 * @param c The connection<br>
	 * @param selection The selection.<br>
	 * @return A cookie<br>
	 * Gets the owner of the specified selection.<br>
	 * <br>
	 * TODO: briefly explain what a selection is.<br>
	 * Original signature : <code>xcb_get_selection_owner_cookie_t xcb_get_selection_owner(xcb_connection_t*, xcb_atom_t)</code><br>
	 * @param c <<br>
	 * @param selection <<br>
	 * <i>native declaration : xcb/xproto.h:5059</i><br>
	 * @deprecated use the safer method {@link #xcb_get_selection_owner(com.sun.jna.ptr.PointerByReference, int)} instead
	 */
	@Deprecated 
	xcb.xcb_get_selection_owner_cookie_t.ByValue xcb_get_selection_owner(Pointer c, int selection);
	/**
	 * @brief Gets the owner of a selection<br>
	 * @param c The connection<br>
	 * @param selection The selection.<br>
	 * @return A cookie<br>
	 * Gets the owner of the specified selection.<br>
	 * <br>
	 * TODO: briefly explain what a selection is.<br>
	 * Original signature : <code>xcb_get_selection_owner_cookie_t xcb_get_selection_owner(xcb_connection_t*, xcb_atom_t)</code><br>
	 * @param c <<br>
	 * @param selection <<br>
	 * <i>native declaration : xcb/xproto.h:5059</i>
	 */
	xcb.xcb_get_selection_owner_cookie_t.ByValue xcb_get_selection_owner(PointerByReference c, int selection);
	/**
	 * @brief Gets the owner of a selection<br>
	 * @param c The connection<br>
	 * @param selection The selection.<br>
	 * @return A cookie<br>
	 * Gets the owner of the specified selection.<br>
	 * <br>
	 * TODO: briefly explain what a selection is.<br>
	 * This form can be used only if the request will cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * placed in the event queue.<br>
	 * Original signature : <code>xcb_get_selection_owner_cookie_t xcb_get_selection_owner_unchecked(xcb_connection_t*, xcb_atom_t)</code><br>
	 * @param c <<br>
	 * @param selection <<br>
	 * <i>native declaration : xcb/xproto.h:5075</i><br>
	 * @deprecated use the safer method {@link #xcb_get_selection_owner_unchecked(com.sun.jna.ptr.PointerByReference, int)} instead
	 */
	@Deprecated 
	xcb.xcb_get_selection_owner_cookie_t.ByValue xcb_get_selection_owner_unchecked(Pointer c, int selection);
	/**
	 * @brief Gets the owner of a selection<br>
	 * @param c The connection<br>
	 * @param selection The selection.<br>
	 * @return A cookie<br>
	 * Gets the owner of the specified selection.<br>
	 * <br>
	 * TODO: briefly explain what a selection is.<br>
	 * This form can be used only if the request will cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * placed in the event queue.<br>
	 * Original signature : <code>xcb_get_selection_owner_cookie_t xcb_get_selection_owner_unchecked(xcb_connection_t*, xcb_atom_t)</code><br>
	 * @param c <<br>
	 * @param selection <<br>
	 * <i>native declaration : xcb/xproto.h:5075</i>
	 */
	xcb.xcb_get_selection_owner_cookie_t.ByValue xcb_get_selection_owner_unchecked(PointerByReference c, int selection);
	/**
	 * Return the reply<br>
	 * @param c      The connection<br>
	 * @param cookie The cookie<br>
	 * @param e      The xcb_generic_error_t supplied<br>
	 * Returns the reply of the request asked by<br>
	 * The parameter @p e supplied to this function must be NULL if<br>
	 * xcb_get_selection_owner_unchecked(). is used.<br>
	 * Otherwise, it stores the error if any.<br>
	 * The returned value must be freed by the caller using free().<br>
	 * Original signature : <code>xcb_get_selection_owner_reply_t* xcb_get_selection_owner_reply(xcb_connection_t*, xcb_get_selection_owner_cookie_t, xcb_generic_error_t**)</code><br>
	 * @param c <<br>
	 * @param cookie <<br>
	 * @param e <<br>
	 * <i>native declaration : xcb/xproto.h:5091</i><br>
	 * @deprecated use the safer method {@link #xcb_get_selection_owner_reply(com.sun.jna.ptr.PointerByReference, xcb.xcb_get_selection_owner_cookie_t.ByValue, xcb.xcb_generic_error_t.ByReference[])} instead
	 */
	@Deprecated 
	xcb_get_selection_owner_reply_t xcb_get_selection_owner_reply(Pointer c, xcb.xcb_get_selection_owner_cookie_t.ByValue cookie, PointerByReference e);
	/**
	 * Return the reply<br>
	 * @param c      The connection<br>
	 * @param cookie The cookie<br>
	 * @param e      The xcb_generic_error_t supplied<br>
	 * Returns the reply of the request asked by<br>
	 * The parameter @p e supplied to this function must be NULL if<br>
	 * xcb_get_selection_owner_unchecked(). is used.<br>
	 * Otherwise, it stores the error if any.<br>
	 * The returned value must be freed by the caller using free().<br>
	 * Original signature : <code>xcb_get_selection_owner_reply_t* xcb_get_selection_owner_reply(xcb_connection_t*, xcb_get_selection_owner_cookie_t, xcb_generic_error_t**)</code><br>
	 * @param c <<br>
	 * @param cookie <<br>
	 * @param e <<br>
	 * <i>native declaration : xcb/xproto.h:5091</i>
	 */
	xcb_get_selection_owner_reply_t xcb_get_selection_owner_reply(PointerByReference c, xcb.xcb_get_selection_owner_cookie_t.ByValue cookie, xcb_generic_error_t.ByReference e[]);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_convert_selection_checked(xcb_connection_t*, xcb_window_t, xcb_atom_t, xcb_atom_t, __declspec(property) xcb_atom_t, xcb_timestamp_t)</code><br>
	 * @param c <<br>
	 * @param requestor <<br>
	 * @param selection <<br>
	 * @param target <<br>
	 * @param time <<br>
	 * <i>native declaration : xcb/xproto.h:5106</i><br>
	 * @deprecated use the safer method {@link #xcb_convert_selection_checked(com.sun.jna.ptr.PointerByReference, int, int, int, int, int)} instead
	 */
	@Deprecated 
	xcb.xcb_void_cookie_t.ByValue xcb_convert_selection_checked(Pointer c, int requestor, int selection, int target, int xcb_atom_t1, int time);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_convert_selection_checked(xcb_connection_t*, xcb_window_t, xcb_atom_t, xcb_atom_t, __declspec(property) xcb_atom_t, xcb_timestamp_t)</code><br>
	 * @param c <<br>
	 * @param requestor <<br>
	 * @param selection <<br>
	 * @param target <<br>
	 * @param time <<br>
	 * <i>native declaration : xcb/xproto.h:5106</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_convert_selection_checked(PointerByReference c, int requestor, int selection, int target, int xcb_atom_t1, int time);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_convert_selection(xcb_connection_t*, xcb_window_t, xcb_atom_t, xcb_atom_t, __declspec(property) xcb_atom_t, xcb_timestamp_t)</code><br>
	 * @param c <<br>
	 * @param requestor <<br>
	 * @param selection <<br>
	 * @param target <<br>
	 * @param time <<br>
	 * <i>native declaration : xcb/xproto.h:5118</i><br>
	 * @deprecated use the safer method {@link #xcb_convert_selection(com.sun.jna.ptr.PointerByReference, int, int, int, int, int)} instead
	 */
	@Deprecated 
	xcb.xcb_void_cookie_t.ByValue xcb_convert_selection(Pointer c, int requestor, int selection, int target, int xcb_atom_t1, int time);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_convert_selection(xcb_connection_t*, xcb_window_t, xcb_atom_t, xcb_atom_t, __declspec(property) xcb_atom_t, xcb_timestamp_t)</code><br>
	 * @param c <<br>
	 * @param requestor <<br>
	 * @param selection <<br>
	 * @param target <<br>
	 * @param time <<br>
	 * <i>native declaration : xcb/xproto.h:5118</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_convert_selection(PointerByReference c, int requestor, int selection, int target, int xcb_atom_t1, int time);
	/**
	 * @brief send an event<br>
	 * @param c The connection<br>
	 * @param propagate If \a propagate is true and no clients have selected any event on \a destination,<br>
	 * the destination is replaced with the closest ancestor of \a destination for<br>
	 * which some client has selected a type in \a event_mask and for which no<br>
	 * intervening window has that type in its do-not-propagate-mask. If no such<br>
	 * window exists or if the window is an ancestor of the focus window and<br>
	 * `InputFocus` was originally specified as the destination, the event is not sent<br>
	 * to any clients. Otherwise, the event is reported to every client selecting on<br>
	 * the final destination any of the types specified in \a event_mask.<br>
	 * @param destination The window to send this event to. Every client which selects any event within<br>
	 * \a event_mask on \a destination will get the event.<br>
	 * \n<br>
	 * The special value `XCB_SEND_EVENT_DEST_POINTER_WINDOW` refers to the window<br>
	 * that contains the mouse pointer.<br>
	 * \n<br>
	 * The special value `XCB_SEND_EVENT_DEST_ITEM_FOCUS` refers to the window which<br>
	 * has the keyboard focus.<br>
	 * @param event_mask Event_mask for determining which clients should receive the specified event.<br>
	 * See \a destination and \a propagate.<br>
	 * @param event The event to send to the specified \a destination.<br>
	 * @return A cookie<br>
	 * Identifies the \a destination window, determines which clients should receive<br>
	 * the specified event and ignores any active grabs.<br>
	 * <br>
	 * The \a event must be one of the core events or an event defined by an extension,<br>
	 * so that the X server can correctly byte-swap the contents as necessary. The<br>
	 * contents of \a event are otherwise unaltered and unchecked except for the<br>
	 * `send_event` field which is forced to 'true'.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_send_event_checked(xcb_connection_t*, uint8_t, xcb_window_t, uint32_t, const char*)</code><br>
	 * @param c <<br>
	 * @param propagate <<br>
	 * @param destination <<br>
	 * @param event_mask <<br>
	 * @param event <<br>
	 * <i>native declaration : xcb/xproto.h:5159</i><br>
	 * @deprecated use the safer methods {@link #xcb_send_event_checked(com.sun.jna.ptr.PointerByReference, byte, int, int, java.lang.String)} and {@link #xcb_send_event_checked(com.sun.jna.ptr.PointerByReference, byte, int, int, com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	xcb.xcb_void_cookie_t.ByValue xcb_send_event_checked(Pointer c, byte propagate, int destination, int event_mask, Pointer event);
	/**
	 * @brief send an event<br>
	 * @param c The connection<br>
	 * @param propagate If \a propagate is true and no clients have selected any event on \a destination,<br>
	 * the destination is replaced with the closest ancestor of \a destination for<br>
	 * which some client has selected a type in \a event_mask and for which no<br>
	 * intervening window has that type in its do-not-propagate-mask. If no such<br>
	 * window exists or if the window is an ancestor of the focus window and<br>
	 * `InputFocus` was originally specified as the destination, the event is not sent<br>
	 * to any clients. Otherwise, the event is reported to every client selecting on<br>
	 * the final destination any of the types specified in \a event_mask.<br>
	 * @param destination The window to send this event to. Every client which selects any event within<br>
	 * \a event_mask on \a destination will get the event.<br>
	 * \n<br>
	 * The special value `XCB_SEND_EVENT_DEST_POINTER_WINDOW` refers to the window<br>
	 * that contains the mouse pointer.<br>
	 * \n<br>
	 * The special value `XCB_SEND_EVENT_DEST_ITEM_FOCUS` refers to the window which<br>
	 * has the keyboard focus.<br>
	 * @param event_mask Event_mask for determining which clients should receive the specified event.<br>
	 * See \a destination and \a propagate.<br>
	 * @param event The event to send to the specified \a destination.<br>
	 * @return A cookie<br>
	 * Identifies the \a destination window, determines which clients should receive<br>
	 * the specified event and ignores any active grabs.<br>
	 * <br>
	 * The \a event must be one of the core events or an event defined by an extension,<br>
	 * so that the X server can correctly byte-swap the contents as necessary. The<br>
	 * contents of \a event are otherwise unaltered and unchecked except for the<br>
	 * `send_event` field which is forced to 'true'.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_send_event_checked(xcb_connection_t*, uint8_t, xcb_window_t, uint32_t, const char*)</code><br>
	 * @param c <<br>
	 * @param propagate <<br>
	 * @param destination <<br>
	 * @param event_mask <<br>
	 * @param event <<br>
	 * <i>native declaration : xcb/xproto.h:5159</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_send_event_checked(PointerByReference c, byte propagate, int destination, int event_mask, String event);
	/**
	 * @brief send an event<br>
	 * @param c The connection<br>
	 * @param propagate If \a propagate is true and no clients have selected any event on \a destination,<br>
	 * the destination is replaced with the closest ancestor of \a destination for<br>
	 * which some client has selected a type in \a event_mask and for which no<br>
	 * intervening window has that type in its do-not-propagate-mask. If no such<br>
	 * window exists or if the window is an ancestor of the focus window and<br>
	 * `InputFocus` was originally specified as the destination, the event is not sent<br>
	 * to any clients. Otherwise, the event is reported to every client selecting on<br>
	 * the final destination any of the types specified in \a event_mask.<br>
	 * @param destination The window to send this event to. Every client which selects any event within<br>
	 * \a event_mask on \a destination will get the event.<br>
	 * \n<br>
	 * The special value `XCB_SEND_EVENT_DEST_POINTER_WINDOW` refers to the window<br>
	 * that contains the mouse pointer.<br>
	 * \n<br>
	 * The special value `XCB_SEND_EVENT_DEST_ITEM_FOCUS` refers to the window which<br>
	 * has the keyboard focus.<br>
	 * @param event_mask Event_mask for determining which clients should receive the specified event.<br>
	 * See \a destination and \a propagate.<br>
	 * @param event The event to send to the specified \a destination.<br>
	 * @return A cookie<br>
	 * Identifies the \a destination window, determines which clients should receive<br>
	 * the specified event and ignores any active grabs.<br>
	 * <br>
	 * The \a event must be one of the core events or an event defined by an extension,<br>
	 * so that the X server can correctly byte-swap the contents as necessary. The<br>
	 * contents of \a event are otherwise unaltered and unchecked except for the<br>
	 * `send_event` field which is forced to 'true'.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_send_event_checked(xcb_connection_t*, uint8_t, xcb_window_t, uint32_t, const char*)</code><br>
	 * @param c <<br>
	 * @param propagate <<br>
	 * @param destination <<br>
	 * @param event_mask <<br>
	 * @param event <<br>
	 * <i>native declaration : xcb/xproto.h:5159</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_send_event_checked(PointerByReference c, byte propagate, int destination, int event_mask, Pointer event);
	/**
	 * @brief send an event<br>
	 * @param c The connection<br>
	 * @param propagate If \a propagate is true and no clients have selected any event on \a destination,<br>
	 * the destination is replaced with the closest ancestor of \a destination for<br>
	 * which some client has selected a type in \a event_mask and for which no<br>
	 * intervening window has that type in its do-not-propagate-mask. If no such<br>
	 * window exists or if the window is an ancestor of the focus window and<br>
	 * `InputFocus` was originally specified as the destination, the event is not sent<br>
	 * to any clients. Otherwise, the event is reported to every client selecting on<br>
	 * the final destination any of the types specified in \a event_mask.<br>
	 * @param destination The window to send this event to. Every client which selects any event within<br>
	 * \a event_mask on \a destination will get the event.<br>
	 * \n<br>
	 * The special value `XCB_SEND_EVENT_DEST_POINTER_WINDOW` refers to the window<br>
	 * that contains the mouse pointer.<br>
	 * \n<br>
	 * The special value `XCB_SEND_EVENT_DEST_ITEM_FOCUS` refers to the window which<br>
	 * has the keyboard focus.<br>
	 * @param event_mask Event_mask for determining which clients should receive the specified event.<br>
	 * See \a destination and \a propagate.<br>
	 * @param event The event to send to the specified \a destination.<br>
	 * @return A cookie<br>
	 * Identifies the \a destination window, determines which clients should receive<br>
	 * the specified event and ignores any active grabs.<br>
	 * <br>
	 * The \a event must be one of the core events or an event defined by an extension,<br>
	 * so that the X server can correctly byte-swap the contents as necessary. The<br>
	 * contents of \a event are otherwise unaltered and unchecked except for the<br>
	 * `send_event` field which is forced to 'true'.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_send_event(xcb_connection_t*, uint8_t, xcb_window_t, uint32_t, const char*)</code><br>
	 * @param c <<br>
	 * @param propagate <<br>
	 * @param destination <<br>
	 * @param event_mask <<br>
	 * @param event <<br>
	 * <i>native declaration : xcb/xproto.h:5197</i><br>
	 * @deprecated use the safer methods {@link #xcb_send_event(com.sun.jna.ptr.PointerByReference, byte, int, int, java.lang.String)} and {@link #xcb_send_event(com.sun.jna.ptr.PointerByReference, byte, int, int, com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	xcb.xcb_void_cookie_t.ByValue xcb_send_event(Pointer c, byte propagate, int destination, int event_mask, Pointer event);
	/**
	 * @brief send an event<br>
	 * @param c The connection<br>
	 * @param propagate If \a propagate is true and no clients have selected any event on \a destination,<br>
	 * the destination is replaced with the closest ancestor of \a destination for<br>
	 * which some client has selected a type in \a event_mask and for which no<br>
	 * intervening window has that type in its do-not-propagate-mask. If no such<br>
	 * window exists or if the window is an ancestor of the focus window and<br>
	 * `InputFocus` was originally specified as the destination, the event is not sent<br>
	 * to any clients. Otherwise, the event is reported to every client selecting on<br>
	 * the final destination any of the types specified in \a event_mask.<br>
	 * @param destination The window to send this event to. Every client which selects any event within<br>
	 * \a event_mask on \a destination will get the event.<br>
	 * \n<br>
	 * The special value `XCB_SEND_EVENT_DEST_POINTER_WINDOW` refers to the window<br>
	 * that contains the mouse pointer.<br>
	 * \n<br>
	 * The special value `XCB_SEND_EVENT_DEST_ITEM_FOCUS` refers to the window which<br>
	 * has the keyboard focus.<br>
	 * @param event_mask Event_mask for determining which clients should receive the specified event.<br>
	 * See \a destination and \a propagate.<br>
	 * @param event The event to send to the specified \a destination.<br>
	 * @return A cookie<br>
	 * Identifies the \a destination window, determines which clients should receive<br>
	 * the specified event and ignores any active grabs.<br>
	 * <br>
	 * The \a event must be one of the core events or an event defined by an extension,<br>
	 * so that the X server can correctly byte-swap the contents as necessary. The<br>
	 * contents of \a event are otherwise unaltered and unchecked except for the<br>
	 * `send_event` field which is forced to 'true'.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_send_event(xcb_connection_t*, uint8_t, xcb_window_t, uint32_t, const char*)</code><br>
	 * @param c <<br>
	 * @param propagate <<br>
	 * @param destination <<br>
	 * @param event_mask <<br>
	 * @param event <<br>
	 * <i>native declaration : xcb/xproto.h:5197</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_send_event(PointerByReference c, byte propagate, int destination, int event_mask, String event);
	/**
	 * @brief send an event<br>
	 * @param c The connection<br>
	 * @param propagate If \a propagate is true and no clients have selected any event on \a destination,<br>
	 * the destination is replaced with the closest ancestor of \a destination for<br>
	 * which some client has selected a type in \a event_mask and for which no<br>
	 * intervening window has that type in its do-not-propagate-mask. If no such<br>
	 * window exists or if the window is an ancestor of the focus window and<br>
	 * `InputFocus` was originally specified as the destination, the event is not sent<br>
	 * to any clients. Otherwise, the event is reported to every client selecting on<br>
	 * the final destination any of the types specified in \a event_mask.<br>
	 * @param destination The window to send this event to. Every client which selects any event within<br>
	 * \a event_mask on \a destination will get the event.<br>
	 * \n<br>
	 * The special value `XCB_SEND_EVENT_DEST_POINTER_WINDOW` refers to the window<br>
	 * that contains the mouse pointer.<br>
	 * \n<br>
	 * The special value `XCB_SEND_EVENT_DEST_ITEM_FOCUS` refers to the window which<br>
	 * has the keyboard focus.<br>
	 * @param event_mask Event_mask for determining which clients should receive the specified event.<br>
	 * See \a destination and \a propagate.<br>
	 * @param event The event to send to the specified \a destination.<br>
	 * @return A cookie<br>
	 * Identifies the \a destination window, determines which clients should receive<br>
	 * the specified event and ignores any active grabs.<br>
	 * <br>
	 * The \a event must be one of the core events or an event defined by an extension,<br>
	 * so that the X server can correctly byte-swap the contents as necessary. The<br>
	 * contents of \a event are otherwise unaltered and unchecked except for the<br>
	 * `send_event` field which is forced to 'true'.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_send_event(xcb_connection_t*, uint8_t, xcb_window_t, uint32_t, const char*)</code><br>
	 * @param c <<br>
	 * @param propagate <<br>
	 * @param destination <<br>
	 * @param event_mask <<br>
	 * @param event <<br>
	 * <i>native declaration : xcb/xproto.h:5197</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_send_event(PointerByReference c, byte propagate, int destination, int event_mask, Pointer event);
	/**
	 * @brief Grab the pointer<br>
	 * @param c The connection<br>
	 * @param owner_events If 1, the \a grab_window will still get the pointer events. If 0, events are not<br>
	 * reported to the \a grab_window.<br>
	 * @param grab_window Specifies the window on which the pointer should be grabbed.<br>
	 * @param event_mask Specifies which pointer events are reported to the client.<br>
	 * \n<br>
	 * TODO: which values?<br>
	 * @param pointer_mode A bitmask of #xcb_grab_mode_t values.<br>
	 * @param pointer_mode \n<br>
	 * @param keyboard_mode A bitmask of #xcb_grab_mode_t values.<br>
	 * @param keyboard_mode \n<br>
	 * @param confine_to Specifies the window to confine the pointer in (the user will not be able to<br>
	 * move the pointer out of that window).<br>
	 * \n<br>
	 * The special value `XCB_NONE` means don't confine the pointer.<br>
	 * @param cursor Specifies the cursor that should be displayed or `XCB_NONE` to not change the<br>
	 * cursor.<br>
	 * @param time The time argument allows you to avoid certain circumstances that come up if<br>
	 * applications take a long time to respond or if there are long network delays.<br>
	 * Consider a situation where you have two applications, both of which normally<br>
	 * grab the pointer when clicked on. If both applications specify the timestamp<br>
	 * from the event, the second application may wake up faster and successfully grab<br>
	 * the pointer before the first application. The first application then will get<br>
	 * an indication that the other application grabbed the pointer before its request<br>
	 * was processed.<br>
	 * \n<br>
	 * The special value `XCB_CURRENT_TIME` will be replaced with the current server<br>
	 * time.<br>
	 * @return A cookie<br>
	 * Actively grabs control of the pointer. Further pointer events are reported only to the grabbing client. Overrides any active pointer grab by this client.<br>
	 * Original signature : <code>xcb_grab_pointer_cookie_t xcb_grab_pointer(xcb_connection_t*, uint8_t, xcb_window_t, uint16_t, uint8_t, uint8_t, xcb_window_t, xcb_cursor_t, xcb_timestamp_t)</code><br>
	 * @param c <<br>
	 * @param owner_events <<br>
	 * @param grab_window <<br>
	 * @param event_mask <<br>
	 * @param pointer_mode <<br>
	 * @param keyboard_mode <<br>
	 * @param confine_to <<br>
	 * @param cursor <<br>
	 * @param time <<br>
	 * <i>native declaration : xcb/xproto.h:5241</i><br>
	 * @deprecated use the safer method {@link #xcb_grab_pointer(com.sun.jna.ptr.PointerByReference, byte, int, short, byte, byte, int, int, int)} instead
	 */
	@Deprecated 
	xcb.xcb_grab_pointer_cookie_t.ByValue xcb_grab_pointer(Pointer c, byte owner_events, int grab_window, short event_mask, byte pointer_mode, byte keyboard_mode, int confine_to, int cursor, int time);
	/**
	 * @brief Grab the pointer<br>
	 * @param c The connection<br>
	 * @param owner_events If 1, the \a grab_window will still get the pointer events. If 0, events are not<br>
	 * reported to the \a grab_window.<br>
	 * @param grab_window Specifies the window on which the pointer should be grabbed.<br>
	 * @param event_mask Specifies which pointer events are reported to the client.<br>
	 * \n<br>
	 * TODO: which values?<br>
	 * @param pointer_mode A bitmask of #xcb_grab_mode_t values.<br>
	 * @param pointer_mode \n<br>
	 * @param keyboard_mode A bitmask of #xcb_grab_mode_t values.<br>
	 * @param keyboard_mode \n<br>
	 * @param confine_to Specifies the window to confine the pointer in (the user will not be able to<br>
	 * move the pointer out of that window).<br>
	 * \n<br>
	 * The special value `XCB_NONE` means don't confine the pointer.<br>
	 * @param cursor Specifies the cursor that should be displayed or `XCB_NONE` to not change the<br>
	 * cursor.<br>
	 * @param time The time argument allows you to avoid certain circumstances that come up if<br>
	 * applications take a long time to respond or if there are long network delays.<br>
	 * Consider a situation where you have two applications, both of which normally<br>
	 * grab the pointer when clicked on. If both applications specify the timestamp<br>
	 * from the event, the second application may wake up faster and successfully grab<br>
	 * the pointer before the first application. The first application then will get<br>
	 * an indication that the other application grabbed the pointer before its request<br>
	 * was processed.<br>
	 * \n<br>
	 * The special value `XCB_CURRENT_TIME` will be replaced with the current server<br>
	 * time.<br>
	 * @return A cookie<br>
	 * Actively grabs control of the pointer. Further pointer events are reported only to the grabbing client. Overrides any active pointer grab by this client.<br>
	 * Original signature : <code>xcb_grab_pointer_cookie_t xcb_grab_pointer(xcb_connection_t*, uint8_t, xcb_window_t, uint16_t, uint8_t, uint8_t, xcb_window_t, xcb_cursor_t, xcb_timestamp_t)</code><br>
	 * @param c <<br>
	 * @param owner_events <<br>
	 * @param grab_window <<br>
	 * @param event_mask <<br>
	 * @param pointer_mode <<br>
	 * @param keyboard_mode <<br>
	 * @param confine_to <<br>
	 * @param cursor <<br>
	 * @param time <<br>
	 * <i>native declaration : xcb/xproto.h:5241</i>
	 */
	xcb.xcb_grab_pointer_cookie_t.ByValue xcb_grab_pointer(PointerByReference c, byte owner_events, int grab_window, short event_mask, byte pointer_mode, byte keyboard_mode, int confine_to, int cursor, int time);
	/**
	 * @brief Grab the pointer<br>
	 * @param c The connection<br>
	 * @param owner_events If 1, the \a grab_window will still get the pointer events. If 0, events are not<br>
	 * reported to the \a grab_window.<br>
	 * @param grab_window Specifies the window on which the pointer should be grabbed.<br>
	 * @param event_mask Specifies which pointer events are reported to the client.<br>
	 * \n<br>
	 * TODO: which values?<br>
	 * @param pointer_mode A bitmask of #xcb_grab_mode_t values.<br>
	 * @param pointer_mode \n<br>
	 * @param keyboard_mode A bitmask of #xcb_grab_mode_t values.<br>
	 * @param keyboard_mode \n<br>
	 * @param confine_to Specifies the window to confine the pointer in (the user will not be able to<br>
	 * move the pointer out of that window).<br>
	 * \n<br>
	 * The special value `XCB_NONE` means don't confine the pointer.<br>
	 * @param cursor Specifies the cursor that should be displayed or `XCB_NONE` to not change the<br>
	 * cursor.<br>
	 * @param time The time argument allows you to avoid certain circumstances that come up if<br>
	 * applications take a long time to respond or if there are long network delays.<br>
	 * Consider a situation where you have two applications, both of which normally<br>
	 * grab the pointer when clicked on. If both applications specify the timestamp<br>
	 * from the event, the second application may wake up faster and successfully grab<br>
	 * the pointer before the first application. The first application then will get<br>
	 * an indication that the other application grabbed the pointer before its request<br>
	 * was processed.<br>
	 * \n<br>
	 * The special value `XCB_CURRENT_TIME` will be replaced with the current server<br>
	 * time.<br>
	 * @return A cookie<br>
	 * Actively grabs control of the pointer. Further pointer events are reported only to the grabbing client. Overrides any active pointer grab by this client.<br>
	 * This form can be used only if the request will cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * placed in the event queue.<br>
	 * Original signature : <code>xcb_grab_pointer_cookie_t xcb_grab_pointer_unchecked(xcb_connection_t*, uint8_t, xcb_window_t, uint16_t, uint8_t, uint8_t, xcb_window_t, xcb_cursor_t, xcb_timestamp_t)</code><br>
	 * @param c <<br>
	 * @param owner_events <<br>
	 * @param grab_window <<br>
	 * @param event_mask <<br>
	 * @param pointer_mode <<br>
	 * @param keyboard_mode <<br>
	 * @param confine_to <<br>
	 * @param cursor <<br>
	 * @param time <<br>
	 * <i>native declaration : xcb/xproto.h:5288</i><br>
	 * @deprecated use the safer method {@link #xcb_grab_pointer_unchecked(com.sun.jna.ptr.PointerByReference, byte, int, short, byte, byte, int, int, int)} instead
	 */
	@Deprecated 
	xcb.xcb_grab_pointer_cookie_t.ByValue xcb_grab_pointer_unchecked(Pointer c, byte owner_events, int grab_window, short event_mask, byte pointer_mode, byte keyboard_mode, int confine_to, int cursor, int time);
	/**
	 * @brief Grab the pointer<br>
	 * @param c The connection<br>
	 * @param owner_events If 1, the \a grab_window will still get the pointer events. If 0, events are not<br>
	 * reported to the \a grab_window.<br>
	 * @param grab_window Specifies the window on which the pointer should be grabbed.<br>
	 * @param event_mask Specifies which pointer events are reported to the client.<br>
	 * \n<br>
	 * TODO: which values?<br>
	 * @param pointer_mode A bitmask of #xcb_grab_mode_t values.<br>
	 * @param pointer_mode \n<br>
	 * @param keyboard_mode A bitmask of #xcb_grab_mode_t values.<br>
	 * @param keyboard_mode \n<br>
	 * @param confine_to Specifies the window to confine the pointer in (the user will not be able to<br>
	 * move the pointer out of that window).<br>
	 * \n<br>
	 * The special value `XCB_NONE` means don't confine the pointer.<br>
	 * @param cursor Specifies the cursor that should be displayed or `XCB_NONE` to not change the<br>
	 * cursor.<br>
	 * @param time The time argument allows you to avoid certain circumstances that come up if<br>
	 * applications take a long time to respond or if there are long network delays.<br>
	 * Consider a situation where you have two applications, both of which normally<br>
	 * grab the pointer when clicked on. If both applications specify the timestamp<br>
	 * from the event, the second application may wake up faster and successfully grab<br>
	 * the pointer before the first application. The first application then will get<br>
	 * an indication that the other application grabbed the pointer before its request<br>
	 * was processed.<br>
	 * \n<br>
	 * The special value `XCB_CURRENT_TIME` will be replaced with the current server<br>
	 * time.<br>
	 * @return A cookie<br>
	 * Actively grabs control of the pointer. Further pointer events are reported only to the grabbing client. Overrides any active pointer grab by this client.<br>
	 * This form can be used only if the request will cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * placed in the event queue.<br>
	 * Original signature : <code>xcb_grab_pointer_cookie_t xcb_grab_pointer_unchecked(xcb_connection_t*, uint8_t, xcb_window_t, uint16_t, uint8_t, uint8_t, xcb_window_t, xcb_cursor_t, xcb_timestamp_t)</code><br>
	 * @param c <<br>
	 * @param owner_events <<br>
	 * @param grab_window <<br>
	 * @param event_mask <<br>
	 * @param pointer_mode <<br>
	 * @param keyboard_mode <<br>
	 * @param confine_to <<br>
	 * @param cursor <<br>
	 * @param time <<br>
	 * <i>native declaration : xcb/xproto.h:5288</i>
	 */
	xcb.xcb_grab_pointer_cookie_t.ByValue xcb_grab_pointer_unchecked(PointerByReference c, byte owner_events, int grab_window, short event_mask, byte pointer_mode, byte keyboard_mode, int confine_to, int cursor, int time);
	/**
	 * Return the reply<br>
	 * @param c      The connection<br>
	 * @param cookie The cookie<br>
	 * @param e      The xcb_generic_error_t supplied<br>
	 * Returns the reply of the request asked by<br>
	 * The parameter @p e supplied to this function must be NULL if<br>
	 * xcb_grab_pointer_unchecked(). is used.<br>
	 * Otherwise, it stores the error if any.<br>
	 * The returned value must be freed by the caller using free().<br>
	 * Original signature : <code>xcb_grab_pointer_reply_t* xcb_grab_pointer_reply(xcb_connection_t*, xcb_grab_pointer_cookie_t, xcb_generic_error_t**)</code><br>
	 * @param c <<br>
	 * @param cookie <<br>
	 * @param e <<br>
	 * <i>native declaration : xcb/xproto.h:5304</i><br>
	 * @deprecated use the safer method {@link #xcb_grab_pointer_reply(com.sun.jna.ptr.PointerByReference, xcb.xcb_grab_pointer_cookie_t.ByValue, xcb.xcb_generic_error_t.ByReference[])} instead
	 */
	@Deprecated 
	xcb_grab_pointer_reply_t xcb_grab_pointer_reply(Pointer c, xcb.xcb_grab_pointer_cookie_t.ByValue cookie, PointerByReference e);
	/**
	 * Return the reply<br>
	 * @param c      The connection<br>
	 * @param cookie The cookie<br>
	 * @param e      The xcb_generic_error_t supplied<br>
	 * Returns the reply of the request asked by<br>
	 * The parameter @p e supplied to this function must be NULL if<br>
	 * xcb_grab_pointer_unchecked(). is used.<br>
	 * Otherwise, it stores the error if any.<br>
	 * The returned value must be freed by the caller using free().<br>
	 * Original signature : <code>xcb_grab_pointer_reply_t* xcb_grab_pointer_reply(xcb_connection_t*, xcb_grab_pointer_cookie_t, xcb_generic_error_t**)</code><br>
	 * @param c <<br>
	 * @param cookie <<br>
	 * @param e <<br>
	 * <i>native declaration : xcb/xproto.h:5304</i>
	 */
	xcb_grab_pointer_reply_t xcb_grab_pointer_reply(PointerByReference c, xcb.xcb_grab_pointer_cookie_t.ByValue cookie, xcb_generic_error_t.ByReference e[]);
	/**
	 * @brief release the pointer<br>
	 * @param c The connection<br>
	 * @param time Timestamp to avoid race conditions when running X over the network.<br>
	 * \n<br>
	 * The pointer will not be released if \a time is earlier than the<br>
	 * last-pointer-grab time or later than the current X server time.<br>
	 * @return A cookie<br>
	 * Releases the pointer and any queued events if you actively grabbed the pointer<br>
	 * before using `xcb_grab_pointer`, `xcb_grab_button` or within a normal button<br>
	 * press.<br>
	 * <br>
	 * EnterNotify and LeaveNotify events are generated.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_ungrab_pointer_checked(xcb_connection_t*, xcb_timestamp_t)</code><br>
	 * @param c <<br>
	 * @param time <<br>
	 * <i>native declaration : xcb/xproto.h:5325</i><br>
	 * @deprecated use the safer method {@link #xcb_ungrab_pointer_checked(com.sun.jna.ptr.PointerByReference, int)} instead
	 */
	@Deprecated 
	xcb.xcb_void_cookie_t.ByValue xcb_ungrab_pointer_checked(Pointer c, int time);
	/**
	 * @brief release the pointer<br>
	 * @param c The connection<br>
	 * @param time Timestamp to avoid race conditions when running X over the network.<br>
	 * \n<br>
	 * The pointer will not be released if \a time is earlier than the<br>
	 * last-pointer-grab time or later than the current X server time.<br>
	 * @return A cookie<br>
	 * Releases the pointer and any queued events if you actively grabbed the pointer<br>
	 * before using `xcb_grab_pointer`, `xcb_grab_button` or within a normal button<br>
	 * press.<br>
	 * <br>
	 * EnterNotify and LeaveNotify events are generated.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_ungrab_pointer_checked(xcb_connection_t*, xcb_timestamp_t)</code><br>
	 * @param c <<br>
	 * @param time <<br>
	 * <i>native declaration : xcb/xproto.h:5325</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_ungrab_pointer_checked(PointerByReference c, int time);
	/**
	 * @brief release the pointer<br>
	 * @param c The connection<br>
	 * @param time Timestamp to avoid race conditions when running X over the network.<br>
	 * \n<br>
	 * The pointer will not be released if \a time is earlier than the<br>
	 * last-pointer-grab time or later than the current X server time.<br>
	 * @return A cookie<br>
	 * Releases the pointer and any queued events if you actively grabbed the pointer<br>
	 * before using `xcb_grab_pointer`, `xcb_grab_button` or within a normal button<br>
	 * press.<br>
	 * <br>
	 * EnterNotify and LeaveNotify events are generated.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_ungrab_pointer(xcb_connection_t*, xcb_timestamp_t)</code><br>
	 * @param c <<br>
	 * @param time <<br>
	 * <i>native declaration : xcb/xproto.h:5343</i><br>
	 * @deprecated use the safer method {@link #xcb_ungrab_pointer(com.sun.jna.ptr.PointerByReference, int)} instead
	 */
	@Deprecated 
	xcb.xcb_void_cookie_t.ByValue xcb_ungrab_pointer(Pointer c, int time);
	/**
	 * @brief release the pointer<br>
	 * @param c The connection<br>
	 * @param time Timestamp to avoid race conditions when running X over the network.<br>
	 * \n<br>
	 * The pointer will not be released if \a time is earlier than the<br>
	 * last-pointer-grab time or later than the current X server time.<br>
	 * @return A cookie<br>
	 * Releases the pointer and any queued events if you actively grabbed the pointer<br>
	 * before using `xcb_grab_pointer`, `xcb_grab_button` or within a normal button<br>
	 * press.<br>
	 * <br>
	 * EnterNotify and LeaveNotify events are generated.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_ungrab_pointer(xcb_connection_t*, xcb_timestamp_t)</code><br>
	 * @param c <<br>
	 * @param time <<br>
	 * <i>native declaration : xcb/xproto.h:5343</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_ungrab_pointer(PointerByReference c, int time);
	/**
	 * @brief Grab pointer button(s)<br>
	 * @param c The connection<br>
	 * @param owner_events If 1, the \a grab_window will still get the pointer events. If 0, events are not<br>
	 * reported to the \a grab_window.<br>
	 * @param grab_window Specifies the window on which the pointer should be grabbed.<br>
	 * @param event_mask Specifies which pointer events are reported to the client.<br>
	 * \n<br>
	 * TODO: which values?<br>
	 * @param pointer_mode A bitmask of #xcb_grab_mode_t values.<br>
	 * @param pointer_mode \n<br>
	 * @param keyboard_mode A bitmask of #xcb_grab_mode_t values.<br>
	 * @param keyboard_mode \n<br>
	 * @param confine_to Specifies the window to confine the pointer in (the user will not be able to<br>
	 * move the pointer out of that window).<br>
	 * \n<br>
	 * The special value `XCB_NONE` means don't confine the pointer.<br>
	 * @param cursor Specifies the cursor that should be displayed or `XCB_NONE` to not change the<br>
	 * cursor.<br>
	 * @param button A bitmask of #xcb_button_index_t values.<br>
	 * @param button \n<br>
	 * @param modifiers The modifiers to grab.<br>
	 * \n<br>
	 * Using the special value `XCB_MOD_MASK_ANY` means grab the pointer with all<br>
	 * possible modifier combinations.<br>
	 * @return A cookie<br>
	 * This request establishes a passive grab. The pointer is actively grabbed as<br>
	 * described in GrabPointer, the last-pointer-grab time is set to the time at<br>
	 * which the button was pressed (as transmitted in the ButtonPress event), and the<br>
	 * ButtonPress event is reported if all of the following conditions are true:<br>
	 * <br>
	 * The pointer is not grabbed and the specified button is logically pressed when<br>
	 * the specified modifier keys are logically down, and no other buttons or<br>
	 * modifier keys are logically down.<br>
	 * <br>
	 * The grab-window contains the pointer.<br>
	 * <br>
	 * The confine-to window (if any) is viewable.<br>
	 * <br>
	 * A passive grab on the same button/key combination does not exist on any<br>
	 * ancestor of grab-window.<br>
	 * <br>
	 * The interpretation of the remaining arguments is the same as for GrabPointer.<br>
	 * The active grab is terminated automatically when the logical state of the<br>
	 * pointer has all buttons released, independent of the logical state of modifier<br>
	 * keys. Note that the logical state of a device (as seen by means of the<br>
	 * protocol) may lag the physical state if device event processing is frozen. This<br>
	 * request overrides all previous passive grabs by the same client on the same<br>
	 * button/key combinations on the same window. A modifier of AnyModifier is<br>
	 * equivalent to issuing the request for all possible modifier combinations<br>
	 * (including the combination of no modifiers). It is not required that all<br>
	 * specified modifiers have currently assigned keycodes. A button of AnyButton is<br>
	 * equivalent to issuing the request for all possible buttons. Otherwise, it is<br>
	 * not required that the button specified currently be assigned to a physical<br>
	 * button.<br>
	 * <br>
	 * An Access error is generated if some other client has already issued a<br>
	 * GrabButton request with the same button/key combination on the same window.<br>
	 * When using AnyModifier or AnyButton, the request fails completely (no grabs are<br>
	 * established), and an Access error is generated if there is a conflicting grab<br>
	 * for any combination. The request has no effect on an active grab.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_grab_button_checked(xcb_connection_t*, uint8_t, xcb_window_t, uint16_t, uint8_t, uint8_t, xcb_window_t, xcb_cursor_t, uint8_t, uint16_t)</code><br>
	 * @param c <<br>
	 * @param owner_events <<br>
	 * @param grab_window <<br>
	 * @param event_mask <<br>
	 * @param pointer_mode <<br>
	 * @param keyboard_mode <<br>
	 * @param confine_to <<br>
	 * @param cursor <<br>
	 * @param button <<br>
	 * @param modifiers <<br>
	 * <i>native declaration : xcb/xproto.h:5420</i><br>
	 * @deprecated use the safer method {@link #xcb_grab_button_checked(com.sun.jna.ptr.PointerByReference, byte, int, short, byte, byte, int, int, byte, short)} instead
	 */
	@Deprecated 
	xcb.xcb_void_cookie_t.ByValue xcb_grab_button_checked(Pointer c, byte owner_events, int grab_window, short event_mask, byte pointer_mode, byte keyboard_mode, int confine_to, int cursor, byte button, short modifiers);
	/**
	 * @brief Grab pointer button(s)<br>
	 * @param c The connection<br>
	 * @param owner_events If 1, the \a grab_window will still get the pointer events. If 0, events are not<br>
	 * reported to the \a grab_window.<br>
	 * @param grab_window Specifies the window on which the pointer should be grabbed.<br>
	 * @param event_mask Specifies which pointer events are reported to the client.<br>
	 * \n<br>
	 * TODO: which values?<br>
	 * @param pointer_mode A bitmask of #xcb_grab_mode_t values.<br>
	 * @param pointer_mode \n<br>
	 * @param keyboard_mode A bitmask of #xcb_grab_mode_t values.<br>
	 * @param keyboard_mode \n<br>
	 * @param confine_to Specifies the window to confine the pointer in (the user will not be able to<br>
	 * move the pointer out of that window).<br>
	 * \n<br>
	 * The special value `XCB_NONE` means don't confine the pointer.<br>
	 * @param cursor Specifies the cursor that should be displayed or `XCB_NONE` to not change the<br>
	 * cursor.<br>
	 * @param button A bitmask of #xcb_button_index_t values.<br>
	 * @param button \n<br>
	 * @param modifiers The modifiers to grab.<br>
	 * \n<br>
	 * Using the special value `XCB_MOD_MASK_ANY` means grab the pointer with all<br>
	 * possible modifier combinations.<br>
	 * @return A cookie<br>
	 * This request establishes a passive grab. The pointer is actively grabbed as<br>
	 * described in GrabPointer, the last-pointer-grab time is set to the time at<br>
	 * which the button was pressed (as transmitted in the ButtonPress event), and the<br>
	 * ButtonPress event is reported if all of the following conditions are true:<br>
	 * <br>
	 * The pointer is not grabbed and the specified button is logically pressed when<br>
	 * the specified modifier keys are logically down, and no other buttons or<br>
	 * modifier keys are logically down.<br>
	 * <br>
	 * The grab-window contains the pointer.<br>
	 * <br>
	 * The confine-to window (if any) is viewable.<br>
	 * <br>
	 * A passive grab on the same button/key combination does not exist on any<br>
	 * ancestor of grab-window.<br>
	 * <br>
	 * The interpretation of the remaining arguments is the same as for GrabPointer.<br>
	 * The active grab is terminated automatically when the logical state of the<br>
	 * pointer has all buttons released, independent of the logical state of modifier<br>
	 * keys. Note that the logical state of a device (as seen by means of the<br>
	 * protocol) may lag the physical state if device event processing is frozen. This<br>
	 * request overrides all previous passive grabs by the same client on the same<br>
	 * button/key combinations on the same window. A modifier of AnyModifier is<br>
	 * equivalent to issuing the request for all possible modifier combinations<br>
	 * (including the combination of no modifiers). It is not required that all<br>
	 * specified modifiers have currently assigned keycodes. A button of AnyButton is<br>
	 * equivalent to issuing the request for all possible buttons. Otherwise, it is<br>
	 * not required that the button specified currently be assigned to a physical<br>
	 * button.<br>
	 * <br>
	 * An Access error is generated if some other client has already issued a<br>
	 * GrabButton request with the same button/key combination on the same window.<br>
	 * When using AnyModifier or AnyButton, the request fails completely (no grabs are<br>
	 * established), and an Access error is generated if there is a conflicting grab<br>
	 * for any combination. The request has no effect on an active grab.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_grab_button_checked(xcb_connection_t*, uint8_t, xcb_window_t, uint16_t, uint8_t, uint8_t, xcb_window_t, xcb_cursor_t, uint8_t, uint16_t)</code><br>
	 * @param c <<br>
	 * @param owner_events <<br>
	 * @param grab_window <<br>
	 * @param event_mask <<br>
	 * @param pointer_mode <<br>
	 * @param keyboard_mode <<br>
	 * @param confine_to <<br>
	 * @param cursor <<br>
	 * @param button <<br>
	 * @param modifiers <<br>
	 * <i>native declaration : xcb/xproto.h:5420</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_grab_button_checked(PointerByReference c, byte owner_events, int grab_window, short event_mask, byte pointer_mode, byte keyboard_mode, int confine_to, int cursor, byte button, short modifiers);
	/**
	 * @brief Grab pointer button(s)<br>
	 * @param c The connection<br>
	 * @param owner_events If 1, the \a grab_window will still get the pointer events. If 0, events are not<br>
	 * reported to the \a grab_window.<br>
	 * @param grab_window Specifies the window on which the pointer should be grabbed.<br>
	 * @param event_mask Specifies which pointer events are reported to the client.<br>
	 * \n<br>
	 * TODO: which values?<br>
	 * @param pointer_mode A bitmask of #xcb_grab_mode_t values.<br>
	 * @param pointer_mode \n<br>
	 * @param keyboard_mode A bitmask of #xcb_grab_mode_t values.<br>
	 * @param keyboard_mode \n<br>
	 * @param confine_to Specifies the window to confine the pointer in (the user will not be able to<br>
	 * move the pointer out of that window).<br>
	 * \n<br>
	 * The special value `XCB_NONE` means don't confine the pointer.<br>
	 * @param cursor Specifies the cursor that should be displayed or `XCB_NONE` to not change the<br>
	 * cursor.<br>
	 * @param button A bitmask of #xcb_button_index_t values.<br>
	 * @param button \n<br>
	 * @param modifiers The modifiers to grab.<br>
	 * \n<br>
	 * Using the special value `XCB_MOD_MASK_ANY` means grab the pointer with all<br>
	 * possible modifier combinations.<br>
	 * @return A cookie<br>
	 * This request establishes a passive grab. The pointer is actively grabbed as<br>
	 * described in GrabPointer, the last-pointer-grab time is set to the time at<br>
	 * which the button was pressed (as transmitted in the ButtonPress event), and the<br>
	 * ButtonPress event is reported if all of the following conditions are true:<br>
	 * <br>
	 * The pointer is not grabbed and the specified button is logically pressed when<br>
	 * the specified modifier keys are logically down, and no other buttons or<br>
	 * modifier keys are logically down.<br>
	 * <br>
	 * The grab-window contains the pointer.<br>
	 * <br>
	 * The confine-to window (if any) is viewable.<br>
	 * <br>
	 * A passive grab on the same button/key combination does not exist on any<br>
	 * ancestor of grab-window.<br>
	 * <br>
	 * The interpretation of the remaining arguments is the same as for GrabPointer.<br>
	 * The active grab is terminated automatically when the logical state of the<br>
	 * pointer has all buttons released, independent of the logical state of modifier<br>
	 * keys. Note that the logical state of a device (as seen by means of the<br>
	 * protocol) may lag the physical state if device event processing is frozen. This<br>
	 * request overrides all previous passive grabs by the same client on the same<br>
	 * button/key combinations on the same window. A modifier of AnyModifier is<br>
	 * equivalent to issuing the request for all possible modifier combinations<br>
	 * (including the combination of no modifiers). It is not required that all<br>
	 * specified modifiers have currently assigned keycodes. A button of AnyButton is<br>
	 * equivalent to issuing the request for all possible buttons. Otherwise, it is<br>
	 * not required that the button specified currently be assigned to a physical<br>
	 * button.<br>
	 * <br>
	 * An Access error is generated if some other client has already issued a<br>
	 * GrabButton request with the same button/key combination on the same window.<br>
	 * When using AnyModifier or AnyButton, the request fails completely (no grabs are<br>
	 * established), and an Access error is generated if there is a conflicting grab<br>
	 * for any combination. The request has no effect on an active grab.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_grab_button(xcb_connection_t*, uint8_t, xcb_window_t, uint16_t, uint8_t, uint8_t, xcb_window_t, xcb_cursor_t, uint8_t, uint16_t)</code><br>
	 * @param c <<br>
	 * @param owner_events <<br>
	 * @param grab_window <<br>
	 * @param event_mask <<br>
	 * @param pointer_mode <<br>
	 * @param keyboard_mode <<br>
	 * @param confine_to <<br>
	 * @param cursor <<br>
	 * @param button <<br>
	 * @param modifiers <<br>
	 * <i>native declaration : xcb/xproto.h:5494</i><br>
	 * @deprecated use the safer method {@link #xcb_grab_button(com.sun.jna.ptr.PointerByReference, byte, int, short, byte, byte, int, int, byte, short)} instead
	 */
	@Deprecated 
	xcb.xcb_void_cookie_t.ByValue xcb_grab_button(Pointer c, byte owner_events, int grab_window, short event_mask, byte pointer_mode, byte keyboard_mode, int confine_to, int cursor, byte button, short modifiers);
	/**
	 * @brief Grab pointer button(s)<br>
	 * @param c The connection<br>
	 * @param owner_events If 1, the \a grab_window will still get the pointer events. If 0, events are not<br>
	 * reported to the \a grab_window.<br>
	 * @param grab_window Specifies the window on which the pointer should be grabbed.<br>
	 * @param event_mask Specifies which pointer events are reported to the client.<br>
	 * \n<br>
	 * TODO: which values?<br>
	 * @param pointer_mode A bitmask of #xcb_grab_mode_t values.<br>
	 * @param pointer_mode \n<br>
	 * @param keyboard_mode A bitmask of #xcb_grab_mode_t values.<br>
	 * @param keyboard_mode \n<br>
	 * @param confine_to Specifies the window to confine the pointer in (the user will not be able to<br>
	 * move the pointer out of that window).<br>
	 * \n<br>
	 * The special value `XCB_NONE` means don't confine the pointer.<br>
	 * @param cursor Specifies the cursor that should be displayed or `XCB_NONE` to not change the<br>
	 * cursor.<br>
	 * @param button A bitmask of #xcb_button_index_t values.<br>
	 * @param button \n<br>
	 * @param modifiers The modifiers to grab.<br>
	 * \n<br>
	 * Using the special value `XCB_MOD_MASK_ANY` means grab the pointer with all<br>
	 * possible modifier combinations.<br>
	 * @return A cookie<br>
	 * This request establishes a passive grab. The pointer is actively grabbed as<br>
	 * described in GrabPointer, the last-pointer-grab time is set to the time at<br>
	 * which the button was pressed (as transmitted in the ButtonPress event), and the<br>
	 * ButtonPress event is reported if all of the following conditions are true:<br>
	 * <br>
	 * The pointer is not grabbed and the specified button is logically pressed when<br>
	 * the specified modifier keys are logically down, and no other buttons or<br>
	 * modifier keys are logically down.<br>
	 * <br>
	 * The grab-window contains the pointer.<br>
	 * <br>
	 * The confine-to window (if any) is viewable.<br>
	 * <br>
	 * A passive grab on the same button/key combination does not exist on any<br>
	 * ancestor of grab-window.<br>
	 * <br>
	 * The interpretation of the remaining arguments is the same as for GrabPointer.<br>
	 * The active grab is terminated automatically when the logical state of the<br>
	 * pointer has all buttons released, independent of the logical state of modifier<br>
	 * keys. Note that the logical state of a device (as seen by means of the<br>
	 * protocol) may lag the physical state if device event processing is frozen. This<br>
	 * request overrides all previous passive grabs by the same client on the same<br>
	 * button/key combinations on the same window. A modifier of AnyModifier is<br>
	 * equivalent to issuing the request for all possible modifier combinations<br>
	 * (including the combination of no modifiers). It is not required that all<br>
	 * specified modifiers have currently assigned keycodes. A button of AnyButton is<br>
	 * equivalent to issuing the request for all possible buttons. Otherwise, it is<br>
	 * not required that the button specified currently be assigned to a physical<br>
	 * button.<br>
	 * <br>
	 * An Access error is generated if some other client has already issued a<br>
	 * GrabButton request with the same button/key combination on the same window.<br>
	 * When using AnyModifier or AnyButton, the request fails completely (no grabs are<br>
	 * established), and an Access error is generated if there is a conflicting grab<br>
	 * for any combination. The request has no effect on an active grab.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_grab_button(xcb_connection_t*, uint8_t, xcb_window_t, uint16_t, uint8_t, uint8_t, xcb_window_t, xcb_cursor_t, uint8_t, uint16_t)</code><br>
	 * @param c <<br>
	 * @param owner_events <<br>
	 * @param grab_window <<br>
	 * @param event_mask <<br>
	 * @param pointer_mode <<br>
	 * @param keyboard_mode <<br>
	 * @param confine_to <<br>
	 * @param cursor <<br>
	 * @param button <<br>
	 * @param modifiers <<br>
	 * <i>native declaration : xcb/xproto.h:5494</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_grab_button(PointerByReference c, byte owner_events, int grab_window, short event_mask, byte pointer_mode, byte keyboard_mode, int confine_to, int cursor, byte button, short modifiers);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_ungrab_button_checked(xcb_connection_t*, uint8_t, xcb_window_t, uint16_t)</code><br>
	 * @param c <<br>
	 * @param button <<br>
	 * @param grab_window <<br>
	 * @param modifiers <<br>
	 * <i>native declaration : xcb/xproto.h:5508</i><br>
	 * @deprecated use the safer method {@link #xcb_ungrab_button_checked(com.sun.jna.ptr.PointerByReference, byte, int, short)} instead
	 */
	@Deprecated 
	xcb.xcb_void_cookie_t.ByValue xcb_ungrab_button_checked(Pointer c, byte button, int grab_window, short modifiers);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_ungrab_button_checked(xcb_connection_t*, uint8_t, xcb_window_t, uint16_t)</code><br>
	 * @param c <<br>
	 * @param button <<br>
	 * @param grab_window <<br>
	 * @param modifiers <<br>
	 * <i>native declaration : xcb/xproto.h:5508</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_ungrab_button_checked(PointerByReference c, byte button, int grab_window, short modifiers);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_ungrab_button(xcb_connection_t*, uint8_t, xcb_window_t, uint16_t)</code><br>
	 * @param c <<br>
	 * @param button <<br>
	 * @param grab_window <<br>
	 * @param modifiers <<br>
	 * <i>native declaration : xcb/xproto.h:5519</i><br>
	 * @deprecated use the safer method {@link #xcb_ungrab_button(com.sun.jna.ptr.PointerByReference, byte, int, short)} instead
	 */
	@Deprecated 
	xcb.xcb_void_cookie_t.ByValue xcb_ungrab_button(Pointer c, byte button, int grab_window, short modifiers);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_ungrab_button(xcb_connection_t*, uint8_t, xcb_window_t, uint16_t)</code><br>
	 * @param c <<br>
	 * @param button <<br>
	 * @param grab_window <<br>
	 * @param modifiers <<br>
	 * <i>native declaration : xcb/xproto.h:5519</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_ungrab_button(PointerByReference c, byte button, int grab_window, short modifiers);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_change_active_pointer_grab_checked(xcb_connection_t*, xcb_cursor_t, xcb_timestamp_t, uint16_t)</code><br>
	 * @param c <<br>
	 * @param cursor <<br>
	 * @param time <<br>
	 * @param event_mask <<br>
	 * <i>native declaration : xcb/xproto.h:5533</i><br>
	 * @deprecated use the safer method {@link #xcb_change_active_pointer_grab_checked(com.sun.jna.ptr.PointerByReference, int, int, short)} instead
	 */
	@Deprecated 
	xcb.xcb_void_cookie_t.ByValue xcb_change_active_pointer_grab_checked(Pointer c, int cursor, int time, short event_mask);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_change_active_pointer_grab_checked(xcb_connection_t*, xcb_cursor_t, xcb_timestamp_t, uint16_t)</code><br>
	 * @param c <<br>
	 * @param cursor <<br>
	 * @param time <<br>
	 * @param event_mask <<br>
	 * <i>native declaration : xcb/xproto.h:5533</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_change_active_pointer_grab_checked(PointerByReference c, int cursor, int time, short event_mask);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_change_active_pointer_grab(xcb_connection_t*, xcb_cursor_t, xcb_timestamp_t, uint16_t)</code><br>
	 * @param c <<br>
	 * @param cursor <<br>
	 * @param time <<br>
	 * @param event_mask <<br>
	 * <i>native declaration : xcb/xproto.h:5544</i><br>
	 * @deprecated use the safer method {@link #xcb_change_active_pointer_grab(com.sun.jna.ptr.PointerByReference, int, int, short)} instead
	 */
	@Deprecated 
	xcb.xcb_void_cookie_t.ByValue xcb_change_active_pointer_grab(Pointer c, int cursor, int time, short event_mask);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_change_active_pointer_grab(xcb_connection_t*, xcb_cursor_t, xcb_timestamp_t, uint16_t)</code><br>
	 * @param c <<br>
	 * @param cursor <<br>
	 * @param time <<br>
	 * @param event_mask <<br>
	 * <i>native declaration : xcb/xproto.h:5544</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_change_active_pointer_grab(PointerByReference c, int cursor, int time, short event_mask);
	/**
	 * @brief Grab the keyboard<br>
	 * @param c The connection<br>
	 * @param owner_events If 1, the \a grab_window will still get the pointer events. If 0, events are not<br>
	 * reported to the \a grab_window.<br>
	 * @param grab_window Specifies the window on which the pointer should be grabbed.<br>
	 * @param time Timestamp to avoid race conditions when running X over the network.<br>
	 * \n<br>
	 * The special value `XCB_CURRENT_TIME` will be replaced with the current server<br>
	 * time.<br>
	 * @param pointer_mode A bitmask of #xcb_grab_mode_t values.<br>
	 * @param pointer_mode \n<br>
	 * @param keyboard_mode A bitmask of #xcb_grab_mode_t values.<br>
	 * @param keyboard_mode \n<br>
	 * @return A cookie<br>
	 * Actively grabs control of the keyboard and generates FocusIn and FocusOut<br>
	 * events. Further key events are reported only to the grabbing client.<br>
	 * <br>
	 * Any active keyboard grab by this client is overridden. If the keyboard is<br>
	 * actively grabbed by some other client, `AlreadyGrabbed` is returned. If<br>
	 * \a grab_window is not viewable, `GrabNotViewable` is returned. If the keyboard<br>
	 * is frozen by an active grab of another client, `GrabFrozen` is returned. If the<br>
	 * specified \a time is earlier than the last-keyboard-grab time or later than the<br>
	 * current X server time, `GrabInvalidTime` is returned. Otherwise, the<br>
	 * last-keyboard-grab time is set to the specified time.<br>
	 * Original signature : <code>xcb_grab_keyboard_cookie_t xcb_grab_keyboard(xcb_connection_t*, uint8_t, xcb_window_t, xcb_timestamp_t, uint8_t, uint8_t)</code><br>
	 * @param c <<br>
	 * @param owner_events <<br>
	 * @param grab_window <<br>
	 * @param time <<br>
	 * @param pointer_mode <<br>
	 * @param keyboard_mode <<br>
	 * <i>native declaration : xcb/xproto.h:5578</i><br>
	 * @deprecated use the safer method {@link #xcb_grab_keyboard(com.sun.jna.ptr.PointerByReference, byte, int, int, byte, byte)} instead
	 */
	@Deprecated 
	xcb.xcb_grab_keyboard_cookie_t.ByValue xcb_grab_keyboard(Pointer c, byte owner_events, int grab_window, int time, byte pointer_mode, byte keyboard_mode);
	/**
	 * @brief Grab the keyboard<br>
	 * @param c The connection<br>
	 * @param owner_events If 1, the \a grab_window will still get the pointer events. If 0, events are not<br>
	 * reported to the \a grab_window.<br>
	 * @param grab_window Specifies the window on which the pointer should be grabbed.<br>
	 * @param time Timestamp to avoid race conditions when running X over the network.<br>
	 * \n<br>
	 * The special value `XCB_CURRENT_TIME` will be replaced with the current server<br>
	 * time.<br>
	 * @param pointer_mode A bitmask of #xcb_grab_mode_t values.<br>
	 * @param pointer_mode \n<br>
	 * @param keyboard_mode A bitmask of #xcb_grab_mode_t values.<br>
	 * @param keyboard_mode \n<br>
	 * @return A cookie<br>
	 * Actively grabs control of the keyboard and generates FocusIn and FocusOut<br>
	 * events. Further key events are reported only to the grabbing client.<br>
	 * <br>
	 * Any active keyboard grab by this client is overridden. If the keyboard is<br>
	 * actively grabbed by some other client, `AlreadyGrabbed` is returned. If<br>
	 * \a grab_window is not viewable, `GrabNotViewable` is returned. If the keyboard<br>
	 * is frozen by an active grab of another client, `GrabFrozen` is returned. If the<br>
	 * specified \a time is earlier than the last-keyboard-grab time or later than the<br>
	 * current X server time, `GrabInvalidTime` is returned. Otherwise, the<br>
	 * last-keyboard-grab time is set to the specified time.<br>
	 * Original signature : <code>xcb_grab_keyboard_cookie_t xcb_grab_keyboard(xcb_connection_t*, uint8_t, xcb_window_t, xcb_timestamp_t, uint8_t, uint8_t)</code><br>
	 * @param c <<br>
	 * @param owner_events <<br>
	 * @param grab_window <<br>
	 * @param time <<br>
	 * @param pointer_mode <<br>
	 * @param keyboard_mode <<br>
	 * <i>native declaration : xcb/xproto.h:5578</i>
	 */
	xcb.xcb_grab_keyboard_cookie_t.ByValue xcb_grab_keyboard(PointerByReference c, byte owner_events, int grab_window, int time, byte pointer_mode, byte keyboard_mode);
	/**
	 * @brief Grab the keyboard<br>
	 * @param c The connection<br>
	 * @param owner_events If 1, the \a grab_window will still get the pointer events. If 0, events are not<br>
	 * reported to the \a grab_window.<br>
	 * @param grab_window Specifies the window on which the pointer should be grabbed.<br>
	 * @param time Timestamp to avoid race conditions when running X over the network.<br>
	 * \n<br>
	 * The special value `XCB_CURRENT_TIME` will be replaced with the current server<br>
	 * time.<br>
	 * @param pointer_mode A bitmask of #xcb_grab_mode_t values.<br>
	 * @param pointer_mode \n<br>
	 * @param keyboard_mode A bitmask of #xcb_grab_mode_t values.<br>
	 * @param keyboard_mode \n<br>
	 * @return A cookie<br>
	 * Actively grabs control of the keyboard and generates FocusIn and FocusOut<br>
	 * events. Further key events are reported only to the grabbing client.<br>
	 * <br>
	 * Any active keyboard grab by this client is overridden. If the keyboard is<br>
	 * actively grabbed by some other client, `AlreadyGrabbed` is returned. If<br>
	 * \a grab_window is not viewable, `GrabNotViewable` is returned. If the keyboard<br>
	 * is frozen by an active grab of another client, `GrabFrozen` is returned. If the<br>
	 * specified \a time is earlier than the last-keyboard-grab time or later than the<br>
	 * current X server time, `GrabInvalidTime` is returned. Otherwise, the<br>
	 * last-keyboard-grab time is set to the specified time.<br>
	 * This form can be used only if the request will cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * placed in the event queue.<br>
	 * Original signature : <code>xcb_grab_keyboard_cookie_t xcb_grab_keyboard_unchecked(xcb_connection_t*, uint8_t, xcb_window_t, xcb_timestamp_t, uint8_t, uint8_t)</code><br>
	 * @param c <<br>
	 * @param owner_events <<br>
	 * @param grab_window <<br>
	 * @param time <<br>
	 * @param pointer_mode <<br>
	 * @param keyboard_mode <<br>
	 * <i>native declaration : xcb/xproto.h:5615</i><br>
	 * @deprecated use the safer method {@link #xcb_grab_keyboard_unchecked(com.sun.jna.ptr.PointerByReference, byte, int, int, byte, byte)} instead
	 */
	@Deprecated 
	xcb.xcb_grab_keyboard_cookie_t.ByValue xcb_grab_keyboard_unchecked(Pointer c, byte owner_events, int grab_window, int time, byte pointer_mode, byte keyboard_mode);
	/**
	 * @brief Grab the keyboard<br>
	 * @param c The connection<br>
	 * @param owner_events If 1, the \a grab_window will still get the pointer events. If 0, events are not<br>
	 * reported to the \a grab_window.<br>
	 * @param grab_window Specifies the window on which the pointer should be grabbed.<br>
	 * @param time Timestamp to avoid race conditions when running X over the network.<br>
	 * \n<br>
	 * The special value `XCB_CURRENT_TIME` will be replaced with the current server<br>
	 * time.<br>
	 * @param pointer_mode A bitmask of #xcb_grab_mode_t values.<br>
	 * @param pointer_mode \n<br>
	 * @param keyboard_mode A bitmask of #xcb_grab_mode_t values.<br>
	 * @param keyboard_mode \n<br>
	 * @return A cookie<br>
	 * Actively grabs control of the keyboard and generates FocusIn and FocusOut<br>
	 * events. Further key events are reported only to the grabbing client.<br>
	 * <br>
	 * Any active keyboard grab by this client is overridden. If the keyboard is<br>
	 * actively grabbed by some other client, `AlreadyGrabbed` is returned. If<br>
	 * \a grab_window is not viewable, `GrabNotViewable` is returned. If the keyboard<br>
	 * is frozen by an active grab of another client, `GrabFrozen` is returned. If the<br>
	 * specified \a time is earlier than the last-keyboard-grab time or later than the<br>
	 * current X server time, `GrabInvalidTime` is returned. Otherwise, the<br>
	 * last-keyboard-grab time is set to the specified time.<br>
	 * This form can be used only if the request will cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * placed in the event queue.<br>
	 * Original signature : <code>xcb_grab_keyboard_cookie_t xcb_grab_keyboard_unchecked(xcb_connection_t*, uint8_t, xcb_window_t, xcb_timestamp_t, uint8_t, uint8_t)</code><br>
	 * @param c <<br>
	 * @param owner_events <<br>
	 * @param grab_window <<br>
	 * @param time <<br>
	 * @param pointer_mode <<br>
	 * @param keyboard_mode <<br>
	 * <i>native declaration : xcb/xproto.h:5615</i>
	 */
	xcb.xcb_grab_keyboard_cookie_t.ByValue xcb_grab_keyboard_unchecked(PointerByReference c, byte owner_events, int grab_window, int time, byte pointer_mode, byte keyboard_mode);
	/**
	 * Return the reply<br>
	 * @param c      The connection<br>
	 * @param cookie The cookie<br>
	 * @param e      The xcb_generic_error_t supplied<br>
	 * Returns the reply of the request asked by<br>
	 * The parameter @p e supplied to this function must be NULL if<br>
	 * xcb_grab_keyboard_unchecked(). is used.<br>
	 * Otherwise, it stores the error if any.<br>
	 * The returned value must be freed by the caller using free().<br>
	 * Original signature : <code>xcb_grab_keyboard_reply_t* xcb_grab_keyboard_reply(xcb_connection_t*, xcb_grab_keyboard_cookie_t, xcb_generic_error_t**)</code><br>
	 * @param c <<br>
	 * @param cookie <<br>
	 * @param e <<br>
	 * <i>native declaration : xcb/xproto.h:5631</i><br>
	 * @deprecated use the safer method {@link #xcb_grab_keyboard_reply(com.sun.jna.ptr.PointerByReference, xcb.xcb_grab_keyboard_cookie_t.ByValue, xcb.xcb_generic_error_t.ByReference[])} instead
	 */
	@Deprecated 
	xcb_grab_keyboard_reply_t xcb_grab_keyboard_reply(Pointer c, xcb.xcb_grab_keyboard_cookie_t.ByValue cookie, PointerByReference e);
	/**
	 * Return the reply<br>
	 * @param c      The connection<br>
	 * @param cookie The cookie<br>
	 * @param e      The xcb_generic_error_t supplied<br>
	 * Returns the reply of the request asked by<br>
	 * The parameter @p e supplied to this function must be NULL if<br>
	 * xcb_grab_keyboard_unchecked(). is used.<br>
	 * Otherwise, it stores the error if any.<br>
	 * The returned value must be freed by the caller using free().<br>
	 * Original signature : <code>xcb_grab_keyboard_reply_t* xcb_grab_keyboard_reply(xcb_connection_t*, xcb_grab_keyboard_cookie_t, xcb_generic_error_t**)</code><br>
	 * @param c <<br>
	 * @param cookie <<br>
	 * @param e <<br>
	 * <i>native declaration : xcb/xproto.h:5631</i>
	 */
	xcb_grab_keyboard_reply_t xcb_grab_keyboard_reply(PointerByReference c, xcb.xcb_grab_keyboard_cookie_t.ByValue cookie, xcb_generic_error_t.ByReference e[]);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_ungrab_keyboard_checked(xcb_connection_t*, xcb_timestamp_t)</code><br>
	 * @param c <<br>
	 * @param time <<br>
	 * <i>native declaration : xcb/xproto.h:5643</i><br>
	 * @deprecated use the safer method {@link #xcb_ungrab_keyboard_checked(com.sun.jna.ptr.PointerByReference, int)} instead
	 */
	@Deprecated 
	xcb.xcb_void_cookie_t.ByValue xcb_ungrab_keyboard_checked(Pointer c, int time);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_ungrab_keyboard_checked(xcb_connection_t*, xcb_timestamp_t)</code><br>
	 * @param c <<br>
	 * @param time <<br>
	 * <i>native declaration : xcb/xproto.h:5643</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_ungrab_keyboard_checked(PointerByReference c, int time);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_ungrab_keyboard(xcb_connection_t*, xcb_timestamp_t)</code><br>
	 * @param c <<br>
	 * @param time <<br>
	 * <i>native declaration : xcb/xproto.h:5652</i><br>
	 * @deprecated use the safer method {@link #xcb_ungrab_keyboard(com.sun.jna.ptr.PointerByReference, int)} instead
	 */
	@Deprecated 
	xcb.xcb_void_cookie_t.ByValue xcb_ungrab_keyboard(Pointer c, int time);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_ungrab_keyboard(xcb_connection_t*, xcb_timestamp_t)</code><br>
	 * @param c <<br>
	 * @param time <<br>
	 * <i>native declaration : xcb/xproto.h:5652</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_ungrab_keyboard(PointerByReference c, int time);
	/**
	 * @brief Grab keyboard key(s)<br>
	 * @param c The connection<br>
	 * @param owner_events If 1, the \a grab_window will still get the pointer events. If 0, events are not<br>
	 * reported to the \a grab_window.<br>
	 * @param grab_window Specifies the window on which the pointer should be grabbed.<br>
	 * @param modifiers The modifiers to grab.<br>
	 * \n<br>
	 * Using the special value `XCB_MOD_MASK_ANY` means grab the pointer with all<br>
	 * possible modifier combinations.<br>
	 * @param key The keycode of the key to grab.<br>
	 * \n<br>
	 * The special value `XCB_GRAB_ANY` means grab any key.<br>
	 * @param pointer_mode A bitmask of #xcb_grab_mode_t values.<br>
	 * @param pointer_mode \n<br>
	 * @param keyboard_mode A bitmask of #xcb_grab_mode_t values.<br>
	 * @param keyboard_mode \n<br>
	 * @return A cookie<br>
	 * Establishes a passive grab on the keyboard. In the future, the keyboard is<br>
	 * actively grabbed (as for `GrabKeyboard`), the last-keyboard-grab time is set to<br>
	 * the time at which the key was pressed (as transmitted in the KeyPress event),<br>
	 * and the KeyPress event is reported if all of the following conditions are true:<br>
	 * <br>
	 * The keyboard is not grabbed and the specified key (which can itself be a<br>
	 * modifier key) is logically pressed when the specified modifier keys are<br>
	 * logically down, and no other modifier keys are logically down.<br>
	 * <br>
	 * Either the grab_window is an ancestor of (or is) the focus window, or the<br>
	 * grab_window is a descendant of the focus window and contains the pointer.<br>
	 * <br>
	 * A passive grab on the same key combination does not exist on any ancestor of<br>
	 * grab_window.<br>
	 * <br>
	 * The interpretation of the remaining arguments is as for XGrabKeyboard.  The active grab is terminated<br>
	 * automatically when the logical state of the keyboard has the specified key released (independent of the<br>
	 * logical state of the modifier keys), at which point a KeyRelease event is reported to the grabbing window.<br>
	 * <br>
	 * Note that the logical state of a device (as seen by client applications) may lag the physical state if<br>
	 * device event processing is frozen.<br>
	 * <br>
	 * A modifiers argument of AnyModifier is equivalent to issuing the request for all possible modifier combinations (including the combination of no modifiers).  It is not required that all modifiers specified<br>
	 * have currently assigned KeyCodes.  A keycode argument of AnyKey is equivalent to issuing the request for<br>
	 * all possible KeyCodes.  Otherwise, the specified keycode must be in the range specified by min_keycode<br>
	 * and max_keycode in the connection setup, or a BadValue error results.<br>
	 * <br>
	 * If some other client has issued a XGrabKey with the same key combination on the same window, a BadAccess<br>
	 * error results.  When using AnyModifier or AnyKey, the request fails completely, and a BadAccess error<br>
	 * results (no grabs are established) if there is a conflicting grab for any combination.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_grab_key_checked(xcb_connection_t*, uint8_t, xcb_window_t, uint16_t, xcb_keycode_t, uint8_t, uint8_t)</code><br>
	 * @param c <<br>
	 * @param owner_events <<br>
	 * @param grab_window <<br>
	 * @param modifiers <<br>
	 * @param key <<br>
	 * @param pointer_mode <<br>
	 * @param keyboard_mode <<br>
	 * <i>native declaration : xcb/xproto.h:5713</i><br>
	 * @deprecated use the safer method {@link #xcb_grab_key_checked(com.sun.jna.ptr.PointerByReference, byte, int, short, byte, byte, byte)} instead
	 */
	@Deprecated 
	xcb.xcb_void_cookie_t.ByValue xcb_grab_key_checked(Pointer c, byte owner_events, int grab_window, short modifiers, byte key, byte pointer_mode, byte keyboard_mode);
	/**
	 * @brief Grab keyboard key(s)<br>
	 * @param c The connection<br>
	 * @param owner_events If 1, the \a grab_window will still get the pointer events. If 0, events are not<br>
	 * reported to the \a grab_window.<br>
	 * @param grab_window Specifies the window on which the pointer should be grabbed.<br>
	 * @param modifiers The modifiers to grab.<br>
	 * \n<br>
	 * Using the special value `XCB_MOD_MASK_ANY` means grab the pointer with all<br>
	 * possible modifier combinations.<br>
	 * @param key The keycode of the key to grab.<br>
	 * \n<br>
	 * The special value `XCB_GRAB_ANY` means grab any key.<br>
	 * @param pointer_mode A bitmask of #xcb_grab_mode_t values.<br>
	 * @param pointer_mode \n<br>
	 * @param keyboard_mode A bitmask of #xcb_grab_mode_t values.<br>
	 * @param keyboard_mode \n<br>
	 * @return A cookie<br>
	 * Establishes a passive grab on the keyboard. In the future, the keyboard is<br>
	 * actively grabbed (as for `GrabKeyboard`), the last-keyboard-grab time is set to<br>
	 * the time at which the key was pressed (as transmitted in the KeyPress event),<br>
	 * and the KeyPress event is reported if all of the following conditions are true:<br>
	 * <br>
	 * The keyboard is not grabbed and the specified key (which can itself be a<br>
	 * modifier key) is logically pressed when the specified modifier keys are<br>
	 * logically down, and no other modifier keys are logically down.<br>
	 * <br>
	 * Either the grab_window is an ancestor of (or is) the focus window, or the<br>
	 * grab_window is a descendant of the focus window and contains the pointer.<br>
	 * <br>
	 * A passive grab on the same key combination does not exist on any ancestor of<br>
	 * grab_window.<br>
	 * <br>
	 * The interpretation of the remaining arguments is as for XGrabKeyboard.  The active grab is terminated<br>
	 * automatically when the logical state of the keyboard has the specified key released (independent of the<br>
	 * logical state of the modifier keys), at which point a KeyRelease event is reported to the grabbing window.<br>
	 * <br>
	 * Note that the logical state of a device (as seen by client applications) may lag the physical state if<br>
	 * device event processing is frozen.<br>
	 * <br>
	 * A modifiers argument of AnyModifier is equivalent to issuing the request for all possible modifier combinations (including the combination of no modifiers).  It is not required that all modifiers specified<br>
	 * have currently assigned KeyCodes.  A keycode argument of AnyKey is equivalent to issuing the request for<br>
	 * all possible KeyCodes.  Otherwise, the specified keycode must be in the range specified by min_keycode<br>
	 * and max_keycode in the connection setup, or a BadValue error results.<br>
	 * <br>
	 * If some other client has issued a XGrabKey with the same key combination on the same window, a BadAccess<br>
	 * error results.  When using AnyModifier or AnyKey, the request fails completely, and a BadAccess error<br>
	 * results (no grabs are established) if there is a conflicting grab for any combination.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_grab_key_checked(xcb_connection_t*, uint8_t, xcb_window_t, uint16_t, xcb_keycode_t, uint8_t, uint8_t)</code><br>
	 * @param c <<br>
	 * @param owner_events <<br>
	 * @param grab_window <<br>
	 * @param modifiers <<br>
	 * @param key <<br>
	 * @param pointer_mode <<br>
	 * @param keyboard_mode <<br>
	 * <i>native declaration : xcb/xproto.h:5713</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_grab_key_checked(PointerByReference c, byte owner_events, int grab_window, short modifiers, byte key, byte pointer_mode, byte keyboard_mode);
	/**
	 * @brief Grab keyboard key(s)<br>
	 * @param c The connection<br>
	 * @param owner_events If 1, the \a grab_window will still get the pointer events. If 0, events are not<br>
	 * reported to the \a grab_window.<br>
	 * @param grab_window Specifies the window on which the pointer should be grabbed.<br>
	 * @param modifiers The modifiers to grab.<br>
	 * \n<br>
	 * Using the special value `XCB_MOD_MASK_ANY` means grab the pointer with all<br>
	 * possible modifier combinations.<br>
	 * @param key The keycode of the key to grab.<br>
	 * \n<br>
	 * The special value `XCB_GRAB_ANY` means grab any key.<br>
	 * @param pointer_mode A bitmask of #xcb_grab_mode_t values.<br>
	 * @param pointer_mode \n<br>
	 * @param keyboard_mode A bitmask of #xcb_grab_mode_t values.<br>
	 * @param keyboard_mode \n<br>
	 * @return A cookie<br>
	 * Establishes a passive grab on the keyboard. In the future, the keyboard is<br>
	 * actively grabbed (as for `GrabKeyboard`), the last-keyboard-grab time is set to<br>
	 * the time at which the key was pressed (as transmitted in the KeyPress event),<br>
	 * and the KeyPress event is reported if all of the following conditions are true:<br>
	 * <br>
	 * The keyboard is not grabbed and the specified key (which can itself be a<br>
	 * modifier key) is logically pressed when the specified modifier keys are<br>
	 * logically down, and no other modifier keys are logically down.<br>
	 * <br>
	 * Either the grab_window is an ancestor of (or is) the focus window, or the<br>
	 * grab_window is a descendant of the focus window and contains the pointer.<br>
	 * <br>
	 * A passive grab on the same key combination does not exist on any ancestor of<br>
	 * grab_window.<br>
	 * <br>
	 * The interpretation of the remaining arguments is as for XGrabKeyboard.  The active grab is terminated<br>
	 * automatically when the logical state of the keyboard has the specified key released (independent of the<br>
	 * logical state of the modifier keys), at which point a KeyRelease event is reported to the grabbing window.<br>
	 * <br>
	 * Note that the logical state of a device (as seen by client applications) may lag the physical state if<br>
	 * device event processing is frozen.<br>
	 * <br>
	 * A modifiers argument of AnyModifier is equivalent to issuing the request for all possible modifier combinations (including the combination of no modifiers).  It is not required that all modifiers specified<br>
	 * have currently assigned KeyCodes.  A keycode argument of AnyKey is equivalent to issuing the request for<br>
	 * all possible KeyCodes.  Otherwise, the specified keycode must be in the range specified by min_keycode<br>
	 * and max_keycode in the connection setup, or a BadValue error results.<br>
	 * <br>
	 * If some other client has issued a XGrabKey with the same key combination on the same window, a BadAccess<br>
	 * error results.  When using AnyModifier or AnyKey, the request fails completely, and a BadAccess error<br>
	 * results (no grabs are established) if there is a conflicting grab for any combination.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_grab_key(xcb_connection_t*, uint8_t, xcb_window_t, uint16_t, xcb_keycode_t, uint8_t, uint8_t)</code><br>
	 * @param c <<br>
	 * @param owner_events <<br>
	 * @param grab_window <<br>
	 * @param modifiers <<br>
	 * @param key <<br>
	 * @param pointer_mode <<br>
	 * @param keyboard_mode <<br>
	 * <i>native declaration : xcb/xproto.h:5771</i><br>
	 * @deprecated use the safer method {@link #xcb_grab_key(com.sun.jna.ptr.PointerByReference, byte, int, short, byte, byte, byte)} instead
	 */
	@Deprecated 
	xcb.xcb_void_cookie_t.ByValue xcb_grab_key(Pointer c, byte owner_events, int grab_window, short modifiers, byte key, byte pointer_mode, byte keyboard_mode);
	/**
	 * @brief Grab keyboard key(s)<br>
	 * @param c The connection<br>
	 * @param owner_events If 1, the \a grab_window will still get the pointer events. If 0, events are not<br>
	 * reported to the \a grab_window.<br>
	 * @param grab_window Specifies the window on which the pointer should be grabbed.<br>
	 * @param modifiers The modifiers to grab.<br>
	 * \n<br>
	 * Using the special value `XCB_MOD_MASK_ANY` means grab the pointer with all<br>
	 * possible modifier combinations.<br>
	 * @param key The keycode of the key to grab.<br>
	 * \n<br>
	 * The special value `XCB_GRAB_ANY` means grab any key.<br>
	 * @param pointer_mode A bitmask of #xcb_grab_mode_t values.<br>
	 * @param pointer_mode \n<br>
	 * @param keyboard_mode A bitmask of #xcb_grab_mode_t values.<br>
	 * @param keyboard_mode \n<br>
	 * @return A cookie<br>
	 * Establishes a passive grab on the keyboard. In the future, the keyboard is<br>
	 * actively grabbed (as for `GrabKeyboard`), the last-keyboard-grab time is set to<br>
	 * the time at which the key was pressed (as transmitted in the KeyPress event),<br>
	 * and the KeyPress event is reported if all of the following conditions are true:<br>
	 * <br>
	 * The keyboard is not grabbed and the specified key (which can itself be a<br>
	 * modifier key) is logically pressed when the specified modifier keys are<br>
	 * logically down, and no other modifier keys are logically down.<br>
	 * <br>
	 * Either the grab_window is an ancestor of (or is) the focus window, or the<br>
	 * grab_window is a descendant of the focus window and contains the pointer.<br>
	 * <br>
	 * A passive grab on the same key combination does not exist on any ancestor of<br>
	 * grab_window.<br>
	 * <br>
	 * The interpretation of the remaining arguments is as for XGrabKeyboard.  The active grab is terminated<br>
	 * automatically when the logical state of the keyboard has the specified key released (independent of the<br>
	 * logical state of the modifier keys), at which point a KeyRelease event is reported to the grabbing window.<br>
	 * <br>
	 * Note that the logical state of a device (as seen by client applications) may lag the physical state if<br>
	 * device event processing is frozen.<br>
	 * <br>
	 * A modifiers argument of AnyModifier is equivalent to issuing the request for all possible modifier combinations (including the combination of no modifiers).  It is not required that all modifiers specified<br>
	 * have currently assigned KeyCodes.  A keycode argument of AnyKey is equivalent to issuing the request for<br>
	 * all possible KeyCodes.  Otherwise, the specified keycode must be in the range specified by min_keycode<br>
	 * and max_keycode in the connection setup, or a BadValue error results.<br>
	 * <br>
	 * If some other client has issued a XGrabKey with the same key combination on the same window, a BadAccess<br>
	 * error results.  When using AnyModifier or AnyKey, the request fails completely, and a BadAccess error<br>
	 * results (no grabs are established) if there is a conflicting grab for any combination.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_grab_key(xcb_connection_t*, uint8_t, xcb_window_t, uint16_t, xcb_keycode_t, uint8_t, uint8_t)</code><br>
	 * @param c <<br>
	 * @param owner_events <<br>
	 * @param grab_window <<br>
	 * @param modifiers <<br>
	 * @param key <<br>
	 * @param pointer_mode <<br>
	 * @param keyboard_mode <<br>
	 * <i>native declaration : xcb/xproto.h:5771</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_grab_key(PointerByReference c, byte owner_events, int grab_window, short modifiers, byte key, byte pointer_mode, byte keyboard_mode);
	/**
	 * @brief release a key combination<br>
	 * @param c The connection<br>
	 * @param key The keycode of the specified key combination.<br>
	 * \n<br>
	 * Using the special value `XCB_GRAB_ANY` means releasing all possible key codes.<br>
	 * @param grab_window The window on which the grabbed key combination will be released.<br>
	 * @param modifiers The modifiers of the specified key combination.<br>
	 * \n<br>
	 * Using the special value `XCB_MOD_MASK_ANY` means releasing the key combination<br>
	 * with every possible modifier combination.<br>
	 * @return A cookie<br>
	 * Releases the key combination on \a grab_window if you grabbed it using<br>
	 * `xcb_grab_key` before.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_ungrab_key_checked(xcb_connection_t*, xcb_keycode_t, xcb_window_t, uint16_t)</code><br>
	 * @param c <<br>
	 * @param key <<br>
	 * @param grab_window <<br>
	 * @param modifiers <<br>
	 * <i>native declaration : xcb/xproto.h:5795</i><br>
	 * @deprecated use the safer method {@link #xcb_ungrab_key_checked(com.sun.jna.ptr.PointerByReference, byte, int, short)} instead
	 */
	@Deprecated 
	xcb.xcb_void_cookie_t.ByValue xcb_ungrab_key_checked(Pointer c, byte key, int grab_window, short modifiers);
	/**
	 * @brief release a key combination<br>
	 * @param c The connection<br>
	 * @param key The keycode of the specified key combination.<br>
	 * \n<br>
	 * Using the special value `XCB_GRAB_ANY` means releasing all possible key codes.<br>
	 * @param grab_window The window on which the grabbed key combination will be released.<br>
	 * @param modifiers The modifiers of the specified key combination.<br>
	 * \n<br>
	 * Using the special value `XCB_MOD_MASK_ANY` means releasing the key combination<br>
	 * with every possible modifier combination.<br>
	 * @return A cookie<br>
	 * Releases the key combination on \a grab_window if you grabbed it using<br>
	 * `xcb_grab_key` before.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_ungrab_key_checked(xcb_connection_t*, xcb_keycode_t, xcb_window_t, uint16_t)</code><br>
	 * @param c <<br>
	 * @param key <<br>
	 * @param grab_window <<br>
	 * @param modifiers <<br>
	 * <i>native declaration : xcb/xproto.h:5795</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_ungrab_key_checked(PointerByReference c, byte key, int grab_window, short modifiers);
	/**
	 * @brief release a key combination<br>
	 * @param c The connection<br>
	 * @param key The keycode of the specified key combination.<br>
	 * \n<br>
	 * Using the special value `XCB_GRAB_ANY` means releasing all possible key codes.<br>
	 * @param grab_window The window on which the grabbed key combination will be released.<br>
	 * @param modifiers The modifiers of the specified key combination.<br>
	 * \n<br>
	 * Using the special value `XCB_MOD_MASK_ANY` means releasing the key combination<br>
	 * with every possible modifier combination.<br>
	 * @return A cookie<br>
	 * Releases the key combination on \a grab_window if you grabbed it using<br>
	 * `xcb_grab_key` before.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_ungrab_key(xcb_connection_t*, xcb_keycode_t, xcb_window_t, uint16_t)</code><br>
	 * @param c <<br>
	 * @param key <<br>
	 * @param grab_window <<br>
	 * @param modifiers <<br>
	 * <i>native declaration : xcb/xproto.h:5816</i><br>
	 * @deprecated use the safer method {@link #xcb_ungrab_key(com.sun.jna.ptr.PointerByReference, byte, int, short)} instead
	 */
	@Deprecated 
	xcb.xcb_void_cookie_t.ByValue xcb_ungrab_key(Pointer c, byte key, int grab_window, short modifiers);
	/**
	 * @brief release a key combination<br>
	 * @param c The connection<br>
	 * @param key The keycode of the specified key combination.<br>
	 * \n<br>
	 * Using the special value `XCB_GRAB_ANY` means releasing all possible key codes.<br>
	 * @param grab_window The window on which the grabbed key combination will be released.<br>
	 * @param modifiers The modifiers of the specified key combination.<br>
	 * \n<br>
	 * Using the special value `XCB_MOD_MASK_ANY` means releasing the key combination<br>
	 * with every possible modifier combination.<br>
	 * @return A cookie<br>
	 * Releases the key combination on \a grab_window if you grabbed it using<br>
	 * `xcb_grab_key` before.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_ungrab_key(xcb_connection_t*, xcb_keycode_t, xcb_window_t, uint16_t)</code><br>
	 * @param c <<br>
	 * @param key <<br>
	 * @param grab_window <<br>
	 * @param modifiers <<br>
	 * <i>native declaration : xcb/xproto.h:5816</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_ungrab_key(PointerByReference c, byte key, int grab_window, short modifiers);
	/**
	 * @brief release queued events<br>
	 * @param c The connection<br>
	 * @param mode A bitmask of #xcb_allow_t values.<br>
	 * @param mode \n<br>
	 * @param time Timestamp to avoid race conditions when running X over the network.<br>
	 * \n<br>
	 * The special value `XCB_CURRENT_TIME` will be replaced with the current server<br>
	 * time.<br>
	 * @return A cookie<br>
	 * Releases queued events if the client has caused a device (pointer/keyboard) to<br>
	 * freeze due to grabbing it actively. This request has no effect if \a time is<br>
	 * earlier than the last-grab time of the most recent active grab for this client<br>
	 * or if \a time is later than the current X server time.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_allow_events_checked(xcb_connection_t*, uint8_t, xcb_timestamp_t)</code><br>
	 * @param c <<br>
	 * @param mode <<br>
	 * @param time <<br>
	 * <i>native declaration : xcb/xproto.h:5839</i><br>
	 * @deprecated use the safer method {@link #xcb_allow_events_checked(com.sun.jna.ptr.PointerByReference, byte, int)} instead
	 */
	@Deprecated 
	xcb.xcb_void_cookie_t.ByValue xcb_allow_events_checked(Pointer c, byte mode, int time);
	/**
	 * @brief release queued events<br>
	 * @param c The connection<br>
	 * @param mode A bitmask of #xcb_allow_t values.<br>
	 * @param mode \n<br>
	 * @param time Timestamp to avoid race conditions when running X over the network.<br>
	 * \n<br>
	 * The special value `XCB_CURRENT_TIME` will be replaced with the current server<br>
	 * time.<br>
	 * @return A cookie<br>
	 * Releases queued events if the client has caused a device (pointer/keyboard) to<br>
	 * freeze due to grabbing it actively. This request has no effect if \a time is<br>
	 * earlier than the last-grab time of the most recent active grab for this client<br>
	 * or if \a time is later than the current X server time.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_allow_events_checked(xcb_connection_t*, uint8_t, xcb_timestamp_t)</code><br>
	 * @param c <<br>
	 * @param mode <<br>
	 * @param time <<br>
	 * <i>native declaration : xcb/xproto.h:5839</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_allow_events_checked(PointerByReference c, byte mode, int time);
	/**
	 * @brief release queued events<br>
	 * @param c The connection<br>
	 * @param mode A bitmask of #xcb_allow_t values.<br>
	 * @param mode \n<br>
	 * @param time Timestamp to avoid race conditions when running X over the network.<br>
	 * \n<br>
	 * The special value `XCB_CURRENT_TIME` will be replaced with the current server<br>
	 * time.<br>
	 * @return A cookie<br>
	 * Releases queued events if the client has caused a device (pointer/keyboard) to<br>
	 * freeze due to grabbing it actively. This request has no effect if \a time is<br>
	 * earlier than the last-grab time of the most recent active grab for this client<br>
	 * or if \a time is later than the current X server time.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_allow_events(xcb_connection_t*, uint8_t, xcb_timestamp_t)</code><br>
	 * @param c <<br>
	 * @param mode <<br>
	 * @param time <<br>
	 * <i>native declaration : xcb/xproto.h:5859</i><br>
	 * @deprecated use the safer method {@link #xcb_allow_events(com.sun.jna.ptr.PointerByReference, byte, int)} instead
	 */
	@Deprecated 
	xcb.xcb_void_cookie_t.ByValue xcb_allow_events(Pointer c, byte mode, int time);
	/**
	 * @brief release queued events<br>
	 * @param c The connection<br>
	 * @param mode A bitmask of #xcb_allow_t values.<br>
	 * @param mode \n<br>
	 * @param time Timestamp to avoid race conditions when running X over the network.<br>
	 * \n<br>
	 * The special value `XCB_CURRENT_TIME` will be replaced with the current server<br>
	 * time.<br>
	 * @return A cookie<br>
	 * Releases queued events if the client has caused a device (pointer/keyboard) to<br>
	 * freeze due to grabbing it actively. This request has no effect if \a time is<br>
	 * earlier than the last-grab time of the most recent active grab for this client<br>
	 * or if \a time is later than the current X server time.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_allow_events(xcb_connection_t*, uint8_t, xcb_timestamp_t)</code><br>
	 * @param c <<br>
	 * @param mode <<br>
	 * @param time <<br>
	 * <i>native declaration : xcb/xproto.h:5859</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_allow_events(PointerByReference c, byte mode, int time);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_grab_server_checked(xcb_connection_t*)</code><br>
	 * @param c <<br>
	 * <i>native declaration : xcb/xproto.h:5870</i><br>
	 * @deprecated use the safer method {@link #xcb_grab_server_checked(com.sun.jna.ptr.PointerByReference)} instead
	 */
	@Deprecated 
	xcb.xcb_void_cookie_t.ByValue xcb_grab_server_checked(Pointer c);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_grab_server_checked(xcb_connection_t*)</code><br>
	 * @param c <<br>
	 * <i>native declaration : xcb/xproto.h:5870</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_grab_server_checked(PointerByReference c);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_grab_server(xcb_connection_t*)</code><br>
	 * @param c <<br>
	 * <i>native declaration : xcb/xproto.h:5878</i><br>
	 * @deprecated use the safer method {@link #xcb_grab_server(com.sun.jna.ptr.PointerByReference)} instead
	 */
	@Deprecated 
	xcb.xcb_void_cookie_t.ByValue xcb_grab_server(Pointer c);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_grab_server(xcb_connection_t*)</code><br>
	 * @param c <<br>
	 * <i>native declaration : xcb/xproto.h:5878</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_grab_server(PointerByReference c);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_ungrab_server_checked(xcb_connection_t*)</code><br>
	 * @param c <<br>
	 * <i>native declaration : xcb/xproto.h:5889</i><br>
	 * @deprecated use the safer method {@link #xcb_ungrab_server_checked(com.sun.jna.ptr.PointerByReference)} instead
	 */
	@Deprecated 
	xcb.xcb_void_cookie_t.ByValue xcb_ungrab_server_checked(Pointer c);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_ungrab_server_checked(xcb_connection_t*)</code><br>
	 * @param c <<br>
	 * <i>native declaration : xcb/xproto.h:5889</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_ungrab_server_checked(PointerByReference c);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_ungrab_server(xcb_connection_t*)</code><br>
	 * @param c <<br>
	 * <i>native declaration : xcb/xproto.h:5897</i><br>
	 * @deprecated use the safer method {@link #xcb_ungrab_server(com.sun.jna.ptr.PointerByReference)} instead
	 */
	@Deprecated 
	xcb.xcb_void_cookie_t.ByValue xcb_ungrab_server(Pointer c);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_ungrab_server(xcb_connection_t*)</code><br>
	 * @param c <<br>
	 * <i>native declaration : xcb/xproto.h:5897</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_ungrab_server(PointerByReference c);
	/**
	 * @brief get pointer coordinates<br>
	 * @param c The connection<br>
	 * @param window A window to check if the pointer is on the same screen as \a window (see the<br>
	 * `same_screen` field in the reply).<br>
	 * @return A cookie<br>
	 * Gets the root window the pointer is logically on and the pointer coordinates<br>
	 * relative to the root window's origin.<br>
	 * Original signature : <code>xcb_query_pointer_cookie_t xcb_query_pointer(xcb_connection_t*, xcb_window_t)</code><br>
	 * @param c <<br>
	 * @param window <<br>
	 * <i>native declaration : xcb/xproto.h:5910</i><br>
	 * @deprecated use the safer method {@link #xcb_query_pointer(com.sun.jna.ptr.PointerByReference, int)} instead
	 */
	@Deprecated 
	xcb.xcb_query_pointer_cookie_t.ByValue xcb_query_pointer(Pointer c, int window);
	/**
	 * @brief get pointer coordinates<br>
	 * @param c The connection<br>
	 * @param window A window to check if the pointer is on the same screen as \a window (see the<br>
	 * `same_screen` field in the reply).<br>
	 * @return A cookie<br>
	 * Gets the root window the pointer is logically on and the pointer coordinates<br>
	 * relative to the root window's origin.<br>
	 * Original signature : <code>xcb_query_pointer_cookie_t xcb_query_pointer(xcb_connection_t*, xcb_window_t)</code><br>
	 * @param c <<br>
	 * @param window <<br>
	 * <i>native declaration : xcb/xproto.h:5910</i>
	 */
	xcb.xcb_query_pointer_cookie_t.ByValue xcb_query_pointer(PointerByReference c, int window);
	/**
	 * @brief get pointer coordinates<br>
	 * @param c The connection<br>
	 * @param window A window to check if the pointer is on the same screen as \a window (see the<br>
	 * `same_screen` field in the reply).<br>
	 * @return A cookie<br>
	 * Gets the root window the pointer is logically on and the pointer coordinates<br>
	 * relative to the root window's origin.<br>
	 * This form can be used only if the request will cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * placed in the event queue.<br>
	 * Original signature : <code>xcb_query_pointer_cookie_t xcb_query_pointer_unchecked(xcb_connection_t*, xcb_window_t)</code><br>
	 * @param c <<br>
	 * @param window <<br>
	 * <i>native declaration : xcb/xproto.h:5926</i><br>
	 * @deprecated use the safer method {@link #xcb_query_pointer_unchecked(com.sun.jna.ptr.PointerByReference, int)} instead
	 */
	@Deprecated 
	xcb.xcb_query_pointer_cookie_t.ByValue xcb_query_pointer_unchecked(Pointer c, int window);
	/**
	 * @brief get pointer coordinates<br>
	 * @param c The connection<br>
	 * @param window A window to check if the pointer is on the same screen as \a window (see the<br>
	 * `same_screen` field in the reply).<br>
	 * @return A cookie<br>
	 * Gets the root window the pointer is logically on and the pointer coordinates<br>
	 * relative to the root window's origin.<br>
	 * This form can be used only if the request will cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * placed in the event queue.<br>
	 * Original signature : <code>xcb_query_pointer_cookie_t xcb_query_pointer_unchecked(xcb_connection_t*, xcb_window_t)</code><br>
	 * @param c <<br>
	 * @param window <<br>
	 * <i>native declaration : xcb/xproto.h:5926</i>
	 */
	xcb.xcb_query_pointer_cookie_t.ByValue xcb_query_pointer_unchecked(PointerByReference c, int window);
	/**
	 * Return the reply<br>
	 * @param c      The connection<br>
	 * @param cookie The cookie<br>
	 * @param e      The xcb_generic_error_t supplied<br>
	 * Returns the reply of the request asked by<br>
	 * The parameter @p e supplied to this function must be NULL if<br>
	 * xcb_query_pointer_unchecked(). is used.<br>
	 * Otherwise, it stores the error if any.<br>
	 * The returned value must be freed by the caller using free().<br>
	 * Original signature : <code>xcb_query_pointer_reply_t* xcb_query_pointer_reply(xcb_connection_t*, xcb_query_pointer_cookie_t, xcb_generic_error_t**)</code><br>
	 * @param c <<br>
	 * @param cookie <<br>
	 * @param e <<br>
	 * <i>native declaration : xcb/xproto.h:5942</i><br>
	 * @deprecated use the safer method {@link #xcb_query_pointer_reply(com.sun.jna.ptr.PointerByReference, xcb.xcb_query_pointer_cookie_t.ByValue, xcb.xcb_generic_error_t.ByReference[])} instead
	 */
	@Deprecated 
	xcb_query_pointer_reply_t xcb_query_pointer_reply(Pointer c, xcb.xcb_query_pointer_cookie_t.ByValue cookie, PointerByReference e);
	/**
	 * Return the reply<br>
	 * @param c      The connection<br>
	 * @param cookie The cookie<br>
	 * @param e      The xcb_generic_error_t supplied<br>
	 * Returns the reply of the request asked by<br>
	 * The parameter @p e supplied to this function must be NULL if<br>
	 * xcb_query_pointer_unchecked(). is used.<br>
	 * Otherwise, it stores the error if any.<br>
	 * The returned value must be freed by the caller using free().<br>
	 * Original signature : <code>xcb_query_pointer_reply_t* xcb_query_pointer_reply(xcb_connection_t*, xcb_query_pointer_cookie_t, xcb_generic_error_t**)</code><br>
	 * @param c <<br>
	 * @param cookie <<br>
	 * @param e <<br>
	 * <i>native declaration : xcb/xproto.h:5942</i>
	 */
	xcb_query_pointer_reply_t xcb_query_pointer_reply(PointerByReference c, xcb.xcb_query_pointer_cookie_t.ByValue cookie, xcb_generic_error_t.ByReference e[]);
	/**
	 * Get the next element of the iterator<br>
	 * @param i Pointer to a xcb_timecoord_iterator_t<br>
	 * Get the next element in the iterator. The member rem is<br>
	 * decreased by one. The member data points to the next<br>
	 * element. The member index is increased by sizeof(xcb_timecoord_t)<br>
	 * Original signature : <code>void xcb_timecoord_next(xcb_timecoord_iterator_t*)</code><br>
	 * @param i <<br>
	 * <i>native declaration : xcb/xproto.h:5952</i>
	 */
	void xcb_timecoord_next(xcb_timecoord_iterator_t i);
	/**
	 * Return the iterator pointing to the last element<br>
	 * @param i An xcb_timecoord_iterator_t<br>
	 * @return  The iterator pointing to the last element<br>
	 * Set the current element in the iterator to the last element.<br>
	 * The member rem is set to 0. The member data points to the<br>
	 * last element.<br>
	 * Original signature : <code>xcb_generic_iterator_t xcb_timecoord_end(xcb_timecoord_iterator_t)</code><br>
	 * @param i <<br>
	 * <i>native declaration : xcb/xproto.h:5963</i>
	 */
	xcb.xcb_generic_iterator_t.ByValue xcb_timecoord_end(xcb_timecoord_iterator_t.ByValue i);
	/**
	 * Original signature : <code>int xcb_get_motion_events_sizeof(const void*)</code><br>
	 * @param _buffer <<br>
	 * <i>native declaration : xcb/xproto.h:5968</i>
	 */
	int xcb_get_motion_events_sizeof(Pointer _buffer);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_get_motion_events_cookie_t xcb_get_motion_events(xcb_connection_t*, xcb_window_t, xcb_timestamp_t, xcb_timestamp_t)</code><br>
	 * @param c <<br>
	 * @param window <<br>
	 * @param start <<br>
	 * @param stop <<br>
	 * <i>native declaration : xcb/xproto.h:5979</i><br>
	 * @deprecated use the safer method {@link #xcb_get_motion_events(com.sun.jna.ptr.PointerByReference, int, int, int)} instead
	 */
	@Deprecated 
	xcb.xcb_get_motion_events_cookie_t.ByValue xcb_get_motion_events(Pointer c, int window, int start, int stop);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_get_motion_events_cookie_t xcb_get_motion_events(xcb_connection_t*, xcb_window_t, xcb_timestamp_t, xcb_timestamp_t)</code><br>
	 * @param c <<br>
	 * @param window <<br>
	 * @param start <<br>
	 * @param stop <<br>
	 * <i>native declaration : xcb/xproto.h:5979</i>
	 */
	xcb.xcb_get_motion_events_cookie_t.ByValue xcb_get_motion_events(PointerByReference c, int window, int start, int stop);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * placed in the event queue.<br>
	 * Original signature : <code>xcb_get_motion_events_cookie_t xcb_get_motion_events_unchecked(xcb_connection_t*, xcb_window_t, xcb_timestamp_t, xcb_timestamp_t)</code><br>
	 * @param c <<br>
	 * @param window <<br>
	 * @param start <<br>
	 * @param stop <<br>
	 * <i>native declaration : xcb/xproto.h:5993</i><br>
	 * @deprecated use the safer method {@link #xcb_get_motion_events_unchecked(com.sun.jna.ptr.PointerByReference, int, int, int)} instead
	 */
	@Deprecated 
	xcb.xcb_get_motion_events_cookie_t.ByValue xcb_get_motion_events_unchecked(Pointer c, int window, int start, int stop);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * placed in the event queue.<br>
	 * Original signature : <code>xcb_get_motion_events_cookie_t xcb_get_motion_events_unchecked(xcb_connection_t*, xcb_window_t, xcb_timestamp_t, xcb_timestamp_t)</code><br>
	 * @param c <<br>
	 * @param window <<br>
	 * @param start <<br>
	 * @param stop <<br>
	 * <i>native declaration : xcb/xproto.h:5993</i>
	 */
	xcb.xcb_get_motion_events_cookie_t.ByValue xcb_get_motion_events_unchecked(PointerByReference c, int window, int start, int stop);
	/**
	 * Original signature : <code>xcb_timecoord_t* xcb_get_motion_events_events(const xcb_get_motion_events_reply_t*)</code><br>
	 * @param R <<br>
	 * <i>native declaration : xcb/xproto.h:5998</i>
	 */
	xcb_timecoord_t xcb_get_motion_events_events(xcb_get_motion_events_reply_t R);
	/**
	 * Original signature : <code>int xcb_get_motion_events_events_length(const xcb_get_motion_events_reply_t*)</code><br>
	 * @param R <<br>
	 * <i>native declaration : xcb/xproto.h:6003</i>
	 */
	int xcb_get_motion_events_events_length(xcb_get_motion_events_reply_t R);
	/**
	 * Original signature : <code>xcb_timecoord_iterator_t xcb_get_motion_events_events_iterator(const xcb_get_motion_events_reply_t*)</code><br>
	 * @param R <<br>
	 * <i>native declaration : xcb/xproto.h:6008</i>
	 */
	xcb_timecoord_iterator_t.ByValue xcb_get_motion_events_events_iterator(xcb_get_motion_events_reply_t R);
	/**
	 * Return the reply<br>
	 * @param c      The connection<br>
	 * @param cookie The cookie<br>
	 * @param e      The xcb_generic_error_t supplied<br>
	 * Returns the reply of the request asked by<br>
	 * The parameter @p e supplied to this function must be NULL if<br>
	 * xcb_get_motion_events_unchecked(). is used.<br>
	 * Otherwise, it stores the error if any.<br>
	 * The returned value must be freed by the caller using free().<br>
	 * Original signature : <code>xcb_get_motion_events_reply_t* xcb_get_motion_events_reply(xcb_connection_t*, xcb_get_motion_events_cookie_t, xcb_generic_error_t**)</code><br>
	 * @param c <<br>
	 * @param cookie <<br>
	 * @param e <<br>
	 * <i>native declaration : xcb/xproto.h:6024</i><br>
	 * @deprecated use the safer method {@link #xcb_get_motion_events_reply(com.sun.jna.ptr.PointerByReference, xcb.xcb_get_motion_events_cookie_t.ByValue, xcb.xcb_generic_error_t.ByReference[])} instead
	 */
	@Deprecated 
	xcb_get_motion_events_reply_t xcb_get_motion_events_reply(Pointer c, xcb.xcb_get_motion_events_cookie_t.ByValue cookie, PointerByReference e);
	/**
	 * Return the reply<br>
	 * @param c      The connection<br>
	 * @param cookie The cookie<br>
	 * @param e      The xcb_generic_error_t supplied<br>
	 * Returns the reply of the request asked by<br>
	 * The parameter @p e supplied to this function must be NULL if<br>
	 * xcb_get_motion_events_unchecked(). is used.<br>
	 * Otherwise, it stores the error if any.<br>
	 * The returned value must be freed by the caller using free().<br>
	 * Original signature : <code>xcb_get_motion_events_reply_t* xcb_get_motion_events_reply(xcb_connection_t*, xcb_get_motion_events_cookie_t, xcb_generic_error_t**)</code><br>
	 * @param c <<br>
	 * @param cookie <<br>
	 * @param e <<br>
	 * <i>native declaration : xcb/xproto.h:6024</i>
	 */
	xcb_get_motion_events_reply_t xcb_get_motion_events_reply(PointerByReference c, xcb.xcb_get_motion_events_cookie_t.ByValue cookie, xcb_generic_error_t.ByReference e[]);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_translate_coordinates_cookie_t xcb_translate_coordinates(xcb_connection_t*, xcb_window_t, xcb_window_t, int16_t, int16_t)</code><br>
	 * @param c <<br>
	 * @param src_window <<br>
	 * @param dst_window <<br>
	 * @param src_x <<br>
	 * @param src_y <<br>
	 * <i>native declaration : xcb/xproto.h:6036</i><br>
	 * @deprecated use the safer method {@link #xcb_translate_coordinates(com.sun.jna.ptr.PointerByReference, int, int, short, short)} instead
	 */
	@Deprecated 
	xcb.xcb_translate_coordinates_cookie_t.ByValue xcb_translate_coordinates(Pointer c, int src_window, int dst_window, short src_x, short src_y);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_translate_coordinates_cookie_t xcb_translate_coordinates(xcb_connection_t*, xcb_window_t, xcb_window_t, int16_t, int16_t)</code><br>
	 * @param c <<br>
	 * @param src_window <<br>
	 * @param dst_window <<br>
	 * @param src_x <<br>
	 * @param src_y <<br>
	 * <i>native declaration : xcb/xproto.h:6036</i>
	 */
	xcb.xcb_translate_coordinates_cookie_t.ByValue xcb_translate_coordinates(PointerByReference c, int src_window, int dst_window, short src_x, short src_y);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * placed in the event queue.<br>
	 * Original signature : <code>xcb_translate_coordinates_cookie_t xcb_translate_coordinates_unchecked(xcb_connection_t*, xcb_window_t, xcb_window_t, int16_t, int16_t)</code><br>
	 * @param c <<br>
	 * @param src_window <<br>
	 * @param dst_window <<br>
	 * @param src_x <<br>
	 * @param src_y <<br>
	 * <i>native declaration : xcb/xproto.h:6051</i><br>
	 * @deprecated use the safer method {@link #xcb_translate_coordinates_unchecked(com.sun.jna.ptr.PointerByReference, int, int, short, short)} instead
	 */
	@Deprecated 
	xcb.xcb_translate_coordinates_cookie_t.ByValue xcb_translate_coordinates_unchecked(Pointer c, int src_window, int dst_window, short src_x, short src_y);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * placed in the event queue.<br>
	 * Original signature : <code>xcb_translate_coordinates_cookie_t xcb_translate_coordinates_unchecked(xcb_connection_t*, xcb_window_t, xcb_window_t, int16_t, int16_t)</code><br>
	 * @param c <<br>
	 * @param src_window <<br>
	 * @param dst_window <<br>
	 * @param src_x <<br>
	 * @param src_y <<br>
	 * <i>native declaration : xcb/xproto.h:6051</i>
	 */
	xcb.xcb_translate_coordinates_cookie_t.ByValue xcb_translate_coordinates_unchecked(PointerByReference c, int src_window, int dst_window, short src_x, short src_y);
	/**
	 * Return the reply<br>
	 * @param c      The connection<br>
	 * @param cookie The cookie<br>
	 * @param e      The xcb_generic_error_t supplied<br>
	 * Returns the reply of the request asked by<br>
	 * The parameter @p e supplied to this function must be NULL if<br>
	 * xcb_translate_coordinates_unchecked(). is used.<br>
	 * Otherwise, it stores the error if any.<br>
	 * The returned value must be freed by the caller using free().<br>
	 * Original signature : <code>xcb_translate_coordinates_reply_t* xcb_translate_coordinates_reply(xcb_connection_t*, xcb_translate_coordinates_cookie_t, xcb_generic_error_t**)</code><br>
	 * @param c <<br>
	 * @param cookie <<br>
	 * @param e <<br>
	 * <i>native declaration : xcb/xproto.h:6067</i><br>
	 * @deprecated use the safer method {@link #xcb_translate_coordinates_reply(com.sun.jna.ptr.PointerByReference, xcb.xcb_translate_coordinates_cookie_t.ByValue, xcb.xcb_generic_error_t.ByReference[])} instead
	 */
	@Deprecated 
	xcb_translate_coordinates_reply_t xcb_translate_coordinates_reply(Pointer c, xcb.xcb_translate_coordinates_cookie_t.ByValue cookie, PointerByReference e);
	/**
	 * Return the reply<br>
	 * @param c      The connection<br>
	 * @param cookie The cookie<br>
	 * @param e      The xcb_generic_error_t supplied<br>
	 * Returns the reply of the request asked by<br>
	 * The parameter @p e supplied to this function must be NULL if<br>
	 * xcb_translate_coordinates_unchecked(). is used.<br>
	 * Otherwise, it stores the error if any.<br>
	 * The returned value must be freed by the caller using free().<br>
	 * Original signature : <code>xcb_translate_coordinates_reply_t* xcb_translate_coordinates_reply(xcb_connection_t*, xcb_translate_coordinates_cookie_t, xcb_generic_error_t**)</code><br>
	 * @param c <<br>
	 * @param cookie <<br>
	 * @param e <<br>
	 * <i>native declaration : xcb/xproto.h:6067</i>
	 */
	xcb_translate_coordinates_reply_t xcb_translate_coordinates_reply(PointerByReference c, xcb.xcb_translate_coordinates_cookie_t.ByValue cookie, xcb_generic_error_t.ByReference e[]);
	/**
	 * @brief move mouse pointer<br>
	 * @param c The connection<br>
	 * @param src_window If \a src_window is not `XCB_NONE` (TODO), the move will only take place if the<br>
	 * pointer is inside \a src_window and within the rectangle specified by (\a src_x,<br>
	 * \a src_y, \a src_width, \a src_height). The rectangle coordinates are relative to<br>
	 * \a src_window.<br>
	 * @param dst_window If \a dst_window is not `XCB_NONE` (TODO), the pointer will be moved to the<br>
	 * offsets (\a dst_x, \a dst_y) relative to \a dst_window. If \a dst_window is<br>
	 * `XCB_NONE` (TODO), the pointer will be moved by the offsets (\a dst_x, \a dst_y)<br>
	 * relative to the current position of the pointer.<br>
	 * @return A cookie<br>
	 * Moves the mouse pointer to the specified position.<br>
	 * <br>
	 * If \a src_window is not `XCB_NONE` (TODO), the move will only take place if the<br>
	 * pointer is inside \a src_window and within the rectangle specified by (\a src_x,<br>
	 * \a src_y, \a src_width, \a src_height). The rectangle coordinates are relative to<br>
	 * \a src_window.<br>
	 * <br>
	 * If \a dst_window is not `XCB_NONE` (TODO), the pointer will be moved to the<br>
	 * offsets (\a dst_x, \a dst_y) relative to \a dst_window. If \a dst_window is<br>
	 * `XCB_NONE` (TODO), the pointer will be moved by the offsets (\a dst_x, \a dst_y)<br>
	 * relative to the current position of the pointer.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_warp_pointer_checked(xcb_connection_t*, xcb_window_t, xcb_window_t, int16_t, int16_t, uint16_t, uint16_t, int16_t, int16_t)</code><br>
	 * @param c <<br>
	 * @param src_window <<br>
	 * @param dst_window <<br>
	 * @param src_x <<br>
	 * @param src_y <<br>
	 * @param src_width <<br>
	 * @param src_height <<br>
	 * @param dst_x <<br>
	 * @param dst_y <<br>
	 * <i>native declaration : xcb/xproto.h:6105</i><br>
	 * @deprecated use the safer method {@link #xcb_warp_pointer_checked(com.sun.jna.ptr.PointerByReference, int, int, short, short, short, short, short, short)} instead
	 */
	@Deprecated 
	xcb.xcb_void_cookie_t.ByValue xcb_warp_pointer_checked(Pointer c, int src_window, int dst_window, short src_x, short src_y, short src_width, short src_height, short dst_x, short dst_y);
	/**
	 * @brief move mouse pointer<br>
	 * @param c The connection<br>
	 * @param src_window If \a src_window is not `XCB_NONE` (TODO), the move will only take place if the<br>
	 * pointer is inside \a src_window and within the rectangle specified by (\a src_x,<br>
	 * \a src_y, \a src_width, \a src_height). The rectangle coordinates are relative to<br>
	 * \a src_window.<br>
	 * @param dst_window If \a dst_window is not `XCB_NONE` (TODO), the pointer will be moved to the<br>
	 * offsets (\a dst_x, \a dst_y) relative to \a dst_window. If \a dst_window is<br>
	 * `XCB_NONE` (TODO), the pointer will be moved by the offsets (\a dst_x, \a dst_y)<br>
	 * relative to the current position of the pointer.<br>
	 * @return A cookie<br>
	 * Moves the mouse pointer to the specified position.<br>
	 * <br>
	 * If \a src_window is not `XCB_NONE` (TODO), the move will only take place if the<br>
	 * pointer is inside \a src_window and within the rectangle specified by (\a src_x,<br>
	 * \a src_y, \a src_width, \a src_height). The rectangle coordinates are relative to<br>
	 * \a src_window.<br>
	 * <br>
	 * If \a dst_window is not `XCB_NONE` (TODO), the pointer will be moved to the<br>
	 * offsets (\a dst_x, \a dst_y) relative to \a dst_window. If \a dst_window is<br>
	 * `XCB_NONE` (TODO), the pointer will be moved by the offsets (\a dst_x, \a dst_y)<br>
	 * relative to the current position of the pointer.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_warp_pointer_checked(xcb_connection_t*, xcb_window_t, xcb_window_t, int16_t, int16_t, uint16_t, uint16_t, int16_t, int16_t)</code><br>
	 * @param c <<br>
	 * @param src_window <<br>
	 * @param dst_window <<br>
	 * @param src_x <<br>
	 * @param src_y <<br>
	 * @param src_width <<br>
	 * @param src_height <<br>
	 * @param dst_x <<br>
	 * @param dst_y <<br>
	 * <i>native declaration : xcb/xproto.h:6105</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_warp_pointer_checked(PointerByReference c, int src_window, int dst_window, short src_x, short src_y, short src_width, short src_height, short dst_x, short dst_y);
	/**
	 * @brief move mouse pointer<br>
	 * @param c The connection<br>
	 * @param src_window If \a src_window is not `XCB_NONE` (TODO), the move will only take place if the<br>
	 * pointer is inside \a src_window and within the rectangle specified by (\a src_x,<br>
	 * \a src_y, \a src_width, \a src_height). The rectangle coordinates are relative to<br>
	 * \a src_window.<br>
	 * @param dst_window If \a dst_window is not `XCB_NONE` (TODO), the pointer will be moved to the<br>
	 * offsets (\a dst_x, \a dst_y) relative to \a dst_window. If \a dst_window is<br>
	 * `XCB_NONE` (TODO), the pointer will be moved by the offsets (\a dst_x, \a dst_y)<br>
	 * relative to the current position of the pointer.<br>
	 * @return A cookie<br>
	 * Moves the mouse pointer to the specified position.<br>
	 * <br>
	 * If \a src_window is not `XCB_NONE` (TODO), the move will only take place if the<br>
	 * pointer is inside \a src_window and within the rectangle specified by (\a src_x,<br>
	 * \a src_y, \a src_width, \a src_height). The rectangle coordinates are relative to<br>
	 * \a src_window.<br>
	 * <br>
	 * If \a dst_window is not `XCB_NONE` (TODO), the pointer will be moved to the<br>
	 * offsets (\a dst_x, \a dst_y) relative to \a dst_window. If \a dst_window is<br>
	 * `XCB_NONE` (TODO), the pointer will be moved by the offsets (\a dst_x, \a dst_y)<br>
	 * relative to the current position of the pointer.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_warp_pointer(xcb_connection_t*, xcb_window_t, xcb_window_t, int16_t, int16_t, uint16_t, uint16_t, int16_t, int16_t)</code><br>
	 * @param c <<br>
	 * @param src_window <<br>
	 * @param dst_window <<br>
	 * @param src_x <<br>
	 * @param src_y <<br>
	 * @param src_width <<br>
	 * @param src_height <<br>
	 * @param dst_x <<br>
	 * @param dst_y <<br>
	 * <i>native declaration : xcb/xproto.h:6140</i><br>
	 * @deprecated use the safer method {@link #xcb_warp_pointer(com.sun.jna.ptr.PointerByReference, int, int, short, short, short, short, short, short)} instead
	 */
	@Deprecated 
	xcb.xcb_void_cookie_t.ByValue xcb_warp_pointer(Pointer c, int src_window, int dst_window, short src_x, short src_y, short src_width, short src_height, short dst_x, short dst_y);
	/**
	 * @brief move mouse pointer<br>
	 * @param c The connection<br>
	 * @param src_window If \a src_window is not `XCB_NONE` (TODO), the move will only take place if the<br>
	 * pointer is inside \a src_window and within the rectangle specified by (\a src_x,<br>
	 * \a src_y, \a src_width, \a src_height). The rectangle coordinates are relative to<br>
	 * \a src_window.<br>
	 * @param dst_window If \a dst_window is not `XCB_NONE` (TODO), the pointer will be moved to the<br>
	 * offsets (\a dst_x, \a dst_y) relative to \a dst_window. If \a dst_window is<br>
	 * `XCB_NONE` (TODO), the pointer will be moved by the offsets (\a dst_x, \a dst_y)<br>
	 * relative to the current position of the pointer.<br>
	 * @return A cookie<br>
	 * Moves the mouse pointer to the specified position.<br>
	 * <br>
	 * If \a src_window is not `XCB_NONE` (TODO), the move will only take place if the<br>
	 * pointer is inside \a src_window and within the rectangle specified by (\a src_x,<br>
	 * \a src_y, \a src_width, \a src_height). The rectangle coordinates are relative to<br>
	 * \a src_window.<br>
	 * <br>
	 * If \a dst_window is not `XCB_NONE` (TODO), the pointer will be moved to the<br>
	 * offsets (\a dst_x, \a dst_y) relative to \a dst_window. If \a dst_window is<br>
	 * `XCB_NONE` (TODO), the pointer will be moved by the offsets (\a dst_x, \a dst_y)<br>
	 * relative to the current position of the pointer.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_warp_pointer(xcb_connection_t*, xcb_window_t, xcb_window_t, int16_t, int16_t, uint16_t, uint16_t, int16_t, int16_t)</code><br>
	 * @param c <<br>
	 * @param src_window <<br>
	 * @param dst_window <<br>
	 * @param src_x <<br>
	 * @param src_y <<br>
	 * @param src_width <<br>
	 * @param src_height <<br>
	 * @param dst_x <<br>
	 * @param dst_y <<br>
	 * <i>native declaration : xcb/xproto.h:6140</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_warp_pointer(PointerByReference c, int src_window, int dst_window, short src_x, short src_y, short src_width, short src_height, short dst_x, short dst_y);
	/**
	 * @brief Sets input focus<br>
	 * @param c The connection<br>
	 * @param revert_to A bitmask of #xcb_input_focus_t values.<br>
	 * @param revert_to Specifies what happens when the \a focus window becomes unviewable (if \a focus<br>
	 * is neither `XCB_NONE` nor `XCB_POINTER_ROOT`).<br>
	 * @param focus The window to focus. All keyboard events will be reported to this window. The<br>
	 * window must be viewable (TODO), or a `xcb_match_error_t` occurs (TODO).<br>
	 * \n<br>
	 * If \a focus is `XCB_NONE` (TODO), all keyboard events are<br>
	 * discarded until a new focus window is set.<br>
	 * \n<br>
	 * If \a focus is `XCB_POINTER_ROOT` (TODO), focus is on the root window of the<br>
	 * screen on which the pointer is on currently.<br>
	 * @param time Timestamp to avoid race conditions when running X over the network.<br>
	 * \n<br>
	 * The special value `XCB_CURRENT_TIME` will be replaced with the current server<br>
	 * time.<br>
	 * @return A cookie<br>
	 * Changes the input focus and the last-focus-change time. If the specified \a time<br>
	 * is earlier than the current last-focus-change time, the request is ignored (to<br>
	 * avoid race conditions when running X over the network).<br>
	 * <br>
	 * A FocusIn and FocusOut event is generated when focus is changed.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_set_input_focus_checked(xcb_connection_t*, uint8_t, xcb_window_t, xcb_timestamp_t)</code><br>
	 * @param c <<br>
	 * @param revert_to <<br>
	 * @param focus <<br>
	 * @param time <<br>
	 * <i>native declaration : xcb/xproto.h:6174</i><br>
	 * @deprecated use the safer method {@link #xcb_set_input_focus_checked(com.sun.jna.ptr.PointerByReference, byte, int, int)} instead
	 */
	@Deprecated 
	xcb.xcb_void_cookie_t.ByValue xcb_set_input_focus_checked(Pointer c, byte revert_to, int focus, int time);
	/**
	 * @brief Sets input focus<br>
	 * @param c The connection<br>
	 * @param revert_to A bitmask of #xcb_input_focus_t values.<br>
	 * @param revert_to Specifies what happens when the \a focus window becomes unviewable (if \a focus<br>
	 * is neither `XCB_NONE` nor `XCB_POINTER_ROOT`).<br>
	 * @param focus The window to focus. All keyboard events will be reported to this window. The<br>
	 * window must be viewable (TODO), or a `xcb_match_error_t` occurs (TODO).<br>
	 * \n<br>
	 * If \a focus is `XCB_NONE` (TODO), all keyboard events are<br>
	 * discarded until a new focus window is set.<br>
	 * \n<br>
	 * If \a focus is `XCB_POINTER_ROOT` (TODO), focus is on the root window of the<br>
	 * screen on which the pointer is on currently.<br>
	 * @param time Timestamp to avoid race conditions when running X over the network.<br>
	 * \n<br>
	 * The special value `XCB_CURRENT_TIME` will be replaced with the current server<br>
	 * time.<br>
	 * @return A cookie<br>
	 * Changes the input focus and the last-focus-change time. If the specified \a time<br>
	 * is earlier than the current last-focus-change time, the request is ignored (to<br>
	 * avoid race conditions when running X over the network).<br>
	 * <br>
	 * A FocusIn and FocusOut event is generated when focus is changed.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_set_input_focus_checked(xcb_connection_t*, uint8_t, xcb_window_t, xcb_timestamp_t)</code><br>
	 * @param c <<br>
	 * @param revert_to <<br>
	 * @param focus <<br>
	 * @param time <<br>
	 * <i>native declaration : xcb/xproto.h:6174</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_set_input_focus_checked(PointerByReference c, byte revert_to, int focus, int time);
	/**
	 * @brief Sets input focus<br>
	 * @param c The connection<br>
	 * @param revert_to A bitmask of #xcb_input_focus_t values.<br>
	 * @param revert_to Specifies what happens when the \a focus window becomes unviewable (if \a focus<br>
	 * is neither `XCB_NONE` nor `XCB_POINTER_ROOT`).<br>
	 * @param focus The window to focus. All keyboard events will be reported to this window. The<br>
	 * window must be viewable (TODO), or a `xcb_match_error_t` occurs (TODO).<br>
	 * \n<br>
	 * If \a focus is `XCB_NONE` (TODO), all keyboard events are<br>
	 * discarded until a new focus window is set.<br>
	 * \n<br>
	 * If \a focus is `XCB_POINTER_ROOT` (TODO), focus is on the root window of the<br>
	 * screen on which the pointer is on currently.<br>
	 * @param time Timestamp to avoid race conditions when running X over the network.<br>
	 * \n<br>
	 * The special value `XCB_CURRENT_TIME` will be replaced with the current server<br>
	 * time.<br>
	 * @return A cookie<br>
	 * Changes the input focus and the last-focus-change time. If the specified \a time<br>
	 * is earlier than the current last-focus-change time, the request is ignored (to<br>
	 * avoid race conditions when running X over the network).<br>
	 * <br>
	 * A FocusIn and FocusOut event is generated when focus is changed.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_set_input_focus(xcb_connection_t*, uint8_t, xcb_window_t, xcb_timestamp_t)</code><br>
	 * @param c <<br>
	 * @param revert_to <<br>
	 * @param focus <<br>
	 * @param time <<br>
	 * <i>native declaration : xcb/xproto.h:6205</i><br>
	 * @deprecated use the safer method {@link #xcb_set_input_focus(com.sun.jna.ptr.PointerByReference, byte, int, int)} instead
	 */
	@Deprecated 
	xcb.xcb_void_cookie_t.ByValue xcb_set_input_focus(Pointer c, byte revert_to, int focus, int time);
	/**
	 * @brief Sets input focus<br>
	 * @param c The connection<br>
	 * @param revert_to A bitmask of #xcb_input_focus_t values.<br>
	 * @param revert_to Specifies what happens when the \a focus window becomes unviewable (if \a focus<br>
	 * is neither `XCB_NONE` nor `XCB_POINTER_ROOT`).<br>
	 * @param focus The window to focus. All keyboard events will be reported to this window. The<br>
	 * window must be viewable (TODO), or a `xcb_match_error_t` occurs (TODO).<br>
	 * \n<br>
	 * If \a focus is `XCB_NONE` (TODO), all keyboard events are<br>
	 * discarded until a new focus window is set.<br>
	 * \n<br>
	 * If \a focus is `XCB_POINTER_ROOT` (TODO), focus is on the root window of the<br>
	 * screen on which the pointer is on currently.<br>
	 * @param time Timestamp to avoid race conditions when running X over the network.<br>
	 * \n<br>
	 * The special value `XCB_CURRENT_TIME` will be replaced with the current server<br>
	 * time.<br>
	 * @return A cookie<br>
	 * Changes the input focus and the last-focus-change time. If the specified \a time<br>
	 * is earlier than the current last-focus-change time, the request is ignored (to<br>
	 * avoid race conditions when running X over the network).<br>
	 * <br>
	 * A FocusIn and FocusOut event is generated when focus is changed.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_set_input_focus(xcb_connection_t*, uint8_t, xcb_window_t, xcb_timestamp_t)</code><br>
	 * @param c <<br>
	 * @param revert_to <<br>
	 * @param focus <<br>
	 * @param time <<br>
	 * <i>native declaration : xcb/xproto.h:6205</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_set_input_focus(PointerByReference c, byte revert_to, int focus, int time);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_get_input_focus_cookie_t xcb_get_input_focus(xcb_connection_t*)</code><br>
	 * @param c <<br>
	 * <i>native declaration : xcb/xproto.h:6213</i><br>
	 * @deprecated use the safer method {@link #xcb_get_input_focus(com.sun.jna.ptr.PointerByReference)} instead
	 */
	@Deprecated 
	xcb.xcb_get_input_focus_cookie_t.ByValue xcb_get_input_focus(Pointer c);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_get_input_focus_cookie_t xcb_get_input_focus(xcb_connection_t*)</code><br>
	 * @param c <<br>
	 * <i>native declaration : xcb/xproto.h:6213</i>
	 */
	xcb.xcb_get_input_focus_cookie_t.ByValue xcb_get_input_focus(PointerByReference c);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * placed in the event queue.<br>
	 * Original signature : <code>xcb_get_input_focus_cookie_t xcb_get_input_focus_unchecked(xcb_connection_t*)</code><br>
	 * @param c <<br>
	 * <i>native declaration : xcb/xproto.h:6224</i><br>
	 * @deprecated use the safer method {@link #xcb_get_input_focus_unchecked(com.sun.jna.ptr.PointerByReference)} instead
	 */
	@Deprecated 
	xcb.xcb_get_input_focus_cookie_t.ByValue xcb_get_input_focus_unchecked(Pointer c);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * placed in the event queue.<br>
	 * Original signature : <code>xcb_get_input_focus_cookie_t xcb_get_input_focus_unchecked(xcb_connection_t*)</code><br>
	 * @param c <<br>
	 * <i>native declaration : xcb/xproto.h:6224</i>
	 */
	xcb.xcb_get_input_focus_cookie_t.ByValue xcb_get_input_focus_unchecked(PointerByReference c);
	/**
	 * Return the reply<br>
	 * @param c      The connection<br>
	 * @param cookie The cookie<br>
	 * @param e      The xcb_generic_error_t supplied<br>
	 * Returns the reply of the request asked by<br>
	 * The parameter @p e supplied to this function must be NULL if<br>
	 * xcb_get_input_focus_unchecked(). is used.<br>
	 * Otherwise, it stores the error if any.<br>
	 * The returned value must be freed by the caller using free().<br>
	 * Original signature : <code>xcb_get_input_focus_reply_t* xcb_get_input_focus_reply(xcb_connection_t*, xcb_get_input_focus_cookie_t, xcb_generic_error_t**)</code><br>
	 * @param c <<br>
	 * @param cookie <<br>
	 * @param e <<br>
	 * <i>native declaration : xcb/xproto.h:6240</i><br>
	 * @deprecated use the safer method {@link #xcb_get_input_focus_reply(com.sun.jna.ptr.PointerByReference, xcb.xcb_get_input_focus_cookie_t.ByValue, xcb.xcb_generic_error_t.ByReference[])} instead
	 */
	@Deprecated 
	xcb_get_input_focus_reply_t xcb_get_input_focus_reply(Pointer c, xcb.xcb_get_input_focus_cookie_t.ByValue cookie, PointerByReference e);
	/**
	 * Return the reply<br>
	 * @param c      The connection<br>
	 * @param cookie The cookie<br>
	 * @param e      The xcb_generic_error_t supplied<br>
	 * Returns the reply of the request asked by<br>
	 * The parameter @p e supplied to this function must be NULL if<br>
	 * xcb_get_input_focus_unchecked(). is used.<br>
	 * Otherwise, it stores the error if any.<br>
	 * The returned value must be freed by the caller using free().<br>
	 * Original signature : <code>xcb_get_input_focus_reply_t* xcb_get_input_focus_reply(xcb_connection_t*, xcb_get_input_focus_cookie_t, xcb_generic_error_t**)</code><br>
	 * @param c <<br>
	 * @param cookie <<br>
	 * @param e <<br>
	 * <i>native declaration : xcb/xproto.h:6240</i>
	 */
	xcb_get_input_focus_reply_t xcb_get_input_focus_reply(PointerByReference c, xcb.xcb_get_input_focus_cookie_t.ByValue cookie, xcb_generic_error_t.ByReference e[]);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_query_keymap_cookie_t xcb_query_keymap(xcb_connection_t*)</code><br>
	 * @param c <<br>
	 * <i>native declaration : xcb/xproto.h:6248</i><br>
	 * @deprecated use the safer method {@link #xcb_query_keymap(com.sun.jna.ptr.PointerByReference)} instead
	 */
	@Deprecated 
	xcb.xcb_query_keymap_cookie_t.ByValue xcb_query_keymap(Pointer c);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_query_keymap_cookie_t xcb_query_keymap(xcb_connection_t*)</code><br>
	 * @param c <<br>
	 * <i>native declaration : xcb/xproto.h:6248</i>
	 */
	xcb.xcb_query_keymap_cookie_t.ByValue xcb_query_keymap(PointerByReference c);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * placed in the event queue.<br>
	 * Original signature : <code>xcb_query_keymap_cookie_t xcb_query_keymap_unchecked(xcb_connection_t*)</code><br>
	 * @param c <<br>
	 * <i>native declaration : xcb/xproto.h:6259</i><br>
	 * @deprecated use the safer method {@link #xcb_query_keymap_unchecked(com.sun.jna.ptr.PointerByReference)} instead
	 */
	@Deprecated 
	xcb.xcb_query_keymap_cookie_t.ByValue xcb_query_keymap_unchecked(Pointer c);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * placed in the event queue.<br>
	 * Original signature : <code>xcb_query_keymap_cookie_t xcb_query_keymap_unchecked(xcb_connection_t*)</code><br>
	 * @param c <<br>
	 * <i>native declaration : xcb/xproto.h:6259</i>
	 */
	xcb.xcb_query_keymap_cookie_t.ByValue xcb_query_keymap_unchecked(PointerByReference c);
	/**
	 * Return the reply<br>
	 * @param c      The connection<br>
	 * @param cookie The cookie<br>
	 * @param e      The xcb_generic_error_t supplied<br>
	 * Returns the reply of the request asked by<br>
	 * The parameter @p e supplied to this function must be NULL if<br>
	 * xcb_query_keymap_unchecked(). is used.<br>
	 * Otherwise, it stores the error if any.<br>
	 * The returned value must be freed by the caller using free().<br>
	 * Original signature : <code>xcb_query_keymap_reply_t* xcb_query_keymap_reply(xcb_connection_t*, xcb_query_keymap_cookie_t, xcb_generic_error_t**)</code><br>
	 * @param c <<br>
	 * @param cookie <<br>
	 * @param e <<br>
	 * <i>native declaration : xcb/xproto.h:6275</i><br>
	 * @deprecated use the safer method {@link #xcb_query_keymap_reply(com.sun.jna.ptr.PointerByReference, xcb.xcb_query_keymap_cookie_t.ByValue, xcb.xcb_generic_error_t.ByReference[])} instead
	 */
	@Deprecated 
	xcb_query_keymap_reply_t xcb_query_keymap_reply(Pointer c, xcb.xcb_query_keymap_cookie_t.ByValue cookie, PointerByReference e);
	/**
	 * Return the reply<br>
	 * @param c      The connection<br>
	 * @param cookie The cookie<br>
	 * @param e      The xcb_generic_error_t supplied<br>
	 * Returns the reply of the request asked by<br>
	 * The parameter @p e supplied to this function must be NULL if<br>
	 * xcb_query_keymap_unchecked(). is used.<br>
	 * Otherwise, it stores the error if any.<br>
	 * The returned value must be freed by the caller using free().<br>
	 * Original signature : <code>xcb_query_keymap_reply_t* xcb_query_keymap_reply(xcb_connection_t*, xcb_query_keymap_cookie_t, xcb_generic_error_t**)</code><br>
	 * @param c <<br>
	 * @param cookie <<br>
	 * @param e <<br>
	 * <i>native declaration : xcb/xproto.h:6275</i>
	 */
	xcb_query_keymap_reply_t xcb_query_keymap_reply(PointerByReference c, xcb.xcb_query_keymap_cookie_t.ByValue cookie, xcb_generic_error_t.ByReference e[]);
	/**
	 * Original signature : <code>int xcb_open_font_sizeof(const void*)</code><br>
	 * @param _buffer <<br>
	 * <i>native declaration : xcb/xproto.h:6280</i>
	 */
	int xcb_open_font_sizeof(Pointer _buffer);
	/**
	 * @brief opens a font<br>
	 * @param c The connection<br>
	 * @param fid The ID with which you will refer to the font, created by `xcb_generate_id`.<br>
	 * @param name_len Length (in bytes) of \a name.<br>
	 * @param name A pattern describing an X core font.<br>
	 * @return A cookie<br>
	 * Opens any X core font matching the given \a name (for example "-misc-fixed-*").<br>
	 * <br>
	 * Note that X core fonts are deprecated (but still supported) in favor of<br>
	 * client-side rendering using Xft.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_open_font_checked(xcb_connection_t*, xcb_font_t, uint16_t, const char*)</code><br>
	 * @param c <<br>
	 * @param fid <<br>
	 * @param name_len <<br>
	 * @param name <<br>
	 * <i>native declaration : xcb/xproto.h:6301</i><br>
	 * @deprecated use the safer methods {@link #xcb_open_font_checked(com.sun.jna.ptr.PointerByReference, int, short, java.lang.String)} and {@link #xcb_open_font_checked(com.sun.jna.ptr.PointerByReference, int, short, com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	xcb.xcb_void_cookie_t.ByValue xcb_open_font_checked(Pointer c, int fid, short name_len, Pointer name);
	/**
	 * @brief opens a font<br>
	 * @param c The connection<br>
	 * @param fid The ID with which you will refer to the font, created by `xcb_generate_id`.<br>
	 * @param name_len Length (in bytes) of \a name.<br>
	 * @param name A pattern describing an X core font.<br>
	 * @return A cookie<br>
	 * Opens any X core font matching the given \a name (for example "-misc-fixed-*").<br>
	 * <br>
	 * Note that X core fonts are deprecated (but still supported) in favor of<br>
	 * client-side rendering using Xft.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_open_font_checked(xcb_connection_t*, xcb_font_t, uint16_t, const char*)</code><br>
	 * @param c <<br>
	 * @param fid <<br>
	 * @param name_len <<br>
	 * @param name <<br>
	 * <i>native declaration : xcb/xproto.h:6301</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_open_font_checked(PointerByReference c, int fid, short name_len, String name);
	/**
	 * @brief opens a font<br>
	 * @param c The connection<br>
	 * @param fid The ID with which you will refer to the font, created by `xcb_generate_id`.<br>
	 * @param name_len Length (in bytes) of \a name.<br>
	 * @param name A pattern describing an X core font.<br>
	 * @return A cookie<br>
	 * Opens any X core font matching the given \a name (for example "-misc-fixed-*").<br>
	 * <br>
	 * Note that X core fonts are deprecated (but still supported) in favor of<br>
	 * client-side rendering using Xft.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_open_font_checked(xcb_connection_t*, xcb_font_t, uint16_t, const char*)</code><br>
	 * @param c <<br>
	 * @param fid <<br>
	 * @param name_len <<br>
	 * @param name <<br>
	 * <i>native declaration : xcb/xproto.h:6301</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_open_font_checked(PointerByReference c, int fid, short name_len, Pointer name);
	/**
	 * @brief opens a font<br>
	 * @param c The connection<br>
	 * @param fid The ID with which you will refer to the font, created by `xcb_generate_id`.<br>
	 * @param name_len Length (in bytes) of \a name.<br>
	 * @param name A pattern describing an X core font.<br>
	 * @return A cookie<br>
	 * Opens any X core font matching the given \a name (for example "-misc-fixed-*").<br>
	 * <br>
	 * Note that X core fonts are deprecated (but still supported) in favor of<br>
	 * client-side rendering using Xft.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_open_font(xcb_connection_t*, xcb_font_t, uint16_t, const char*)</code><br>
	 * @param c <<br>
	 * @param fid <<br>
	 * @param name_len <<br>
	 * @param name <<br>
	 * <i>native declaration : xcb/xproto.h:6319</i><br>
	 * @deprecated use the safer methods {@link #xcb_open_font(com.sun.jna.ptr.PointerByReference, int, short, java.lang.String)} and {@link #xcb_open_font(com.sun.jna.ptr.PointerByReference, int, short, com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	xcb.xcb_void_cookie_t.ByValue xcb_open_font(Pointer c, int fid, short name_len, Pointer name);
	/**
	 * @brief opens a font<br>
	 * @param c The connection<br>
	 * @param fid The ID with which you will refer to the font, created by `xcb_generate_id`.<br>
	 * @param name_len Length (in bytes) of \a name.<br>
	 * @param name A pattern describing an X core font.<br>
	 * @return A cookie<br>
	 * Opens any X core font matching the given \a name (for example "-misc-fixed-*").<br>
	 * <br>
	 * Note that X core fonts are deprecated (but still supported) in favor of<br>
	 * client-side rendering using Xft.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_open_font(xcb_connection_t*, xcb_font_t, uint16_t, const char*)</code><br>
	 * @param c <<br>
	 * @param fid <<br>
	 * @param name_len <<br>
	 * @param name <<br>
	 * <i>native declaration : xcb/xproto.h:6319</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_open_font(PointerByReference c, int fid, short name_len, String name);
	/**
	 * @brief opens a font<br>
	 * @param c The connection<br>
	 * @param fid The ID with which you will refer to the font, created by `xcb_generate_id`.<br>
	 * @param name_len Length (in bytes) of \a name.<br>
	 * @param name A pattern describing an X core font.<br>
	 * @return A cookie<br>
	 * Opens any X core font matching the given \a name (for example "-misc-fixed-*").<br>
	 * <br>
	 * Note that X core fonts are deprecated (but still supported) in favor of<br>
	 * client-side rendering using Xft.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_open_font(xcb_connection_t*, xcb_font_t, uint16_t, const char*)</code><br>
	 * @param c <<br>
	 * @param fid <<br>
	 * @param name_len <<br>
	 * @param name <<br>
	 * <i>native declaration : xcb/xproto.h:6319</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_open_font(PointerByReference c, int fid, short name_len, Pointer name);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_close_font_checked(xcb_connection_t*, xcb_font_t)</code><br>
	 * @param c <<br>
	 * @param font <<br>
	 * <i>native declaration : xcb/xproto.h:6331</i><br>
	 * @deprecated use the safer method {@link #xcb_close_font_checked(com.sun.jna.ptr.PointerByReference, int)} instead
	 */
	@Deprecated 
	xcb.xcb_void_cookie_t.ByValue xcb_close_font_checked(Pointer c, int font);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_close_font_checked(xcb_connection_t*, xcb_font_t)</code><br>
	 * @param c <<br>
	 * @param font <<br>
	 * <i>native declaration : xcb/xproto.h:6331</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_close_font_checked(PointerByReference c, int font);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_close_font(xcb_connection_t*, xcb_font_t)</code><br>
	 * @param c <<br>
	 * @param font <<br>
	 * <i>native declaration : xcb/xproto.h:6340</i><br>
	 * @deprecated use the safer method {@link #xcb_close_font(com.sun.jna.ptr.PointerByReference, int)} instead
	 */
	@Deprecated 
	xcb.xcb_void_cookie_t.ByValue xcb_close_font(Pointer c, int font);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_close_font(xcb_connection_t*, xcb_font_t)</code><br>
	 * @param c <<br>
	 * @param font <<br>
	 * <i>native declaration : xcb/xproto.h:6340</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_close_font(PointerByReference c, int font);
	/**
	 * Get the next element of the iterator<br>
	 * @param i Pointer to a xcb_fontprop_iterator_t<br>
	 * Get the next element in the iterator. The member rem is<br>
	 * decreased by one. The member data points to the next<br>
	 * element. The member index is increased by sizeof(xcb_fontprop_t)<br>
	 * Original signature : <code>void xcb_fontprop_next(xcb_fontprop_iterator_t*)</code><br>
	 * @param i <<br>
	 * <i>native declaration : xcb/xproto.h:6350</i>
	 */
	void xcb_fontprop_next(xcb_fontprop_iterator_t i);
	/**
	 * Return the iterator pointing to the last element<br>
	 * @param i An xcb_fontprop_iterator_t<br>
	 * @return  The iterator pointing to the last element<br>
	 * Set the current element in the iterator to the last element.<br>
	 * The member rem is set to 0. The member data points to the<br>
	 * last element.<br>
	 * Original signature : <code>xcb_generic_iterator_t xcb_fontprop_end(xcb_fontprop_iterator_t)</code><br>
	 * @param i <<br>
	 * <i>native declaration : xcb/xproto.h:6361</i>
	 */
	xcb.xcb_generic_iterator_t.ByValue xcb_fontprop_end(xcb_fontprop_iterator_t.ByValue i);
	/**
	 * Get the next element of the iterator<br>
	 * @param i Pointer to a xcb_charinfo_iterator_t<br>
	 * Get the next element in the iterator. The member rem is<br>
	 * decreased by one. The member data points to the next<br>
	 * element. The member index is increased by sizeof(xcb_charinfo_t)<br>
	 * Original signature : <code>void xcb_charinfo_next(xcb_charinfo_iterator_t*)</code><br>
	 * @param i <<br>
	 * <i>native declaration : xcb/xproto.h:6371</i>
	 */
	void xcb_charinfo_next(xcb_charinfo_iterator_t i);
	/**
	 * Return the iterator pointing to the last element<br>
	 * @param i An xcb_charinfo_iterator_t<br>
	 * @return  The iterator pointing to the last element<br>
	 * Set the current element in the iterator to the last element.<br>
	 * The member rem is set to 0. The member data points to the<br>
	 * last element.<br>
	 * Original signature : <code>xcb_generic_iterator_t xcb_charinfo_end(xcb_charinfo_iterator_t)</code><br>
	 * @param i <<br>
	 * <i>native declaration : xcb/xproto.h:6382</i>
	 */
	xcb.xcb_generic_iterator_t.ByValue xcb_charinfo_end(xcb_charinfo_iterator_t.ByValue i);
	/**
	 * Original signature : <code>int xcb_query_font_sizeof(const void*)</code><br>
	 * @param _buffer <<br>
	 * <i>native declaration : xcb/xproto.h:6387</i>
	 */
	int xcb_query_font_sizeof(Pointer _buffer);
	/**
	 * @brief query font metrics<br>
	 * @param c The connection<br>
	 * @param font The fontable (Font or Graphics Context) to query.<br>
	 * @return A cookie<br>
	 * Queries information associated with the font.<br>
	 * Original signature : <code>xcb_query_font_cookie_t xcb_query_font(xcb_connection_t*, xcb_fontable_t)</code><br>
	 * @param c <<br>
	 * @param font <<br>
	 * <i>native declaration : xcb/xproto.h:6398</i><br>
	 * @deprecated use the safer method {@link #xcb_query_font(com.sun.jna.ptr.PointerByReference, int)} instead
	 */
	@Deprecated 
	xcb.xcb_query_font_cookie_t.ByValue xcb_query_font(Pointer c, int font);
	/**
	 * @brief query font metrics<br>
	 * @param c The connection<br>
	 * @param font The fontable (Font or Graphics Context) to query.<br>
	 * @return A cookie<br>
	 * Queries information associated with the font.<br>
	 * Original signature : <code>xcb_query_font_cookie_t xcb_query_font(xcb_connection_t*, xcb_fontable_t)</code><br>
	 * @param c <<br>
	 * @param font <<br>
	 * <i>native declaration : xcb/xproto.h:6398</i>
	 */
	xcb.xcb_query_font_cookie_t.ByValue xcb_query_font(PointerByReference c, int font);
	/**
	 * @brief query font metrics<br>
	 * @param c The connection<br>
	 * @param font The fontable (Font or Graphics Context) to query.<br>
	 * @return A cookie<br>
	 * Queries information associated with the font.<br>
	 * This form can be used only if the request will cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * placed in the event queue.<br>
	 * Original signature : <code>xcb_query_font_cookie_t xcb_query_font_unchecked(xcb_connection_t*, xcb_fontable_t)</code><br>
	 * @param c <<br>
	 * @param font <<br>
	 * <i>native declaration : xcb/xproto.h:6412</i><br>
	 * @deprecated use the safer method {@link #xcb_query_font_unchecked(com.sun.jna.ptr.PointerByReference, int)} instead
	 */
	@Deprecated 
	xcb.xcb_query_font_cookie_t.ByValue xcb_query_font_unchecked(Pointer c, int font);
	/**
	 * @brief query font metrics<br>
	 * @param c The connection<br>
	 * @param font The fontable (Font or Graphics Context) to query.<br>
	 * @return A cookie<br>
	 * Queries information associated with the font.<br>
	 * This form can be used only if the request will cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * placed in the event queue.<br>
	 * Original signature : <code>xcb_query_font_cookie_t xcb_query_font_unchecked(xcb_connection_t*, xcb_fontable_t)</code><br>
	 * @param c <<br>
	 * @param font <<br>
	 * <i>native declaration : xcb/xproto.h:6412</i>
	 */
	xcb.xcb_query_font_cookie_t.ByValue xcb_query_font_unchecked(PointerByReference c, int font);
	/**
	 * Original signature : <code>xcb_fontprop_t* xcb_query_font_properties(const xcb_query_font_reply_t*)</code><br>
	 * @param R <<br>
	 * <i>native declaration : xcb/xproto.h:6417</i>
	 */
	xcb_fontprop_t xcb_query_font_properties(xcb_query_font_reply_t R);
	/**
	 * Original signature : <code>int xcb_query_font_properties_length(const xcb_query_font_reply_t*)</code><br>
	 * @param R <<br>
	 * <i>native declaration : xcb/xproto.h:6422</i>
	 */
	int xcb_query_font_properties_length(xcb_query_font_reply_t R);
	/**
	 * Original signature : <code>xcb_fontprop_iterator_t xcb_query_font_properties_iterator(const xcb_query_font_reply_t*)</code><br>
	 * @param R <<br>
	 * <i>native declaration : xcb/xproto.h:6427</i>
	 */
	xcb_fontprop_iterator_t.ByValue xcb_query_font_properties_iterator(xcb_query_font_reply_t R);
	/**
	 * Original signature : <code>xcb_charinfo_t* xcb_query_font_char_infos(const xcb_query_font_reply_t*)</code><br>
	 * @param R <<br>
	 * <i>native declaration : xcb/xproto.h:6432</i>
	 */
	xcb_charinfo_t xcb_query_font_char_infos(xcb_query_font_reply_t R);
	/**
	 * Original signature : <code>int xcb_query_font_char_infos_length(const xcb_query_font_reply_t*)</code><br>
	 * @param R <<br>
	 * <i>native declaration : xcb/xproto.h:6437</i>
	 */
	int xcb_query_font_char_infos_length(xcb_query_font_reply_t R);
	/**
	 * Original signature : <code>xcb_charinfo_iterator_t xcb_query_font_char_infos_iterator(const xcb_query_font_reply_t*)</code><br>
	 * @param R <<br>
	 * <i>native declaration : xcb/xproto.h:6442</i>
	 */
	xcb_charinfo_iterator_t.ByValue xcb_query_font_char_infos_iterator(xcb_query_font_reply_t R);
	/**
	 * Return the reply<br>
	 * @param c      The connection<br>
	 * @param cookie The cookie<br>
	 * @param e      The xcb_generic_error_t supplied<br>
	 * Returns the reply of the request asked by<br>
	 * The parameter @p e supplied to this function must be NULL if<br>
	 * xcb_query_font_unchecked(). is used.<br>
	 * Otherwise, it stores the error if any.<br>
	 * The returned value must be freed by the caller using free().<br>
	 * Original signature : <code>xcb_query_font_reply_t* xcb_query_font_reply(xcb_connection_t*, xcb_query_font_cookie_t, xcb_generic_error_t**)</code><br>
	 * @param c <<br>
	 * @param cookie <<br>
	 * @param e <<br>
	 * <i>native declaration : xcb/xproto.h:6458</i><br>
	 * @deprecated use the safer method {@link #xcb_query_font_reply(com.sun.jna.ptr.PointerByReference, xcb.xcb_query_font_cookie_t.ByValue, xcb.xcb_generic_error_t.ByReference[])} instead
	 */
	@Deprecated 
	xcb_query_font_reply_t xcb_query_font_reply(Pointer c, xcb.xcb_query_font_cookie_t.ByValue cookie, PointerByReference e);
	/**
	 * Return the reply<br>
	 * @param c      The connection<br>
	 * @param cookie The cookie<br>
	 * @param e      The xcb_generic_error_t supplied<br>
	 * Returns the reply of the request asked by<br>
	 * The parameter @p e supplied to this function must be NULL if<br>
	 * xcb_query_font_unchecked(). is used.<br>
	 * Otherwise, it stores the error if any.<br>
	 * The returned value must be freed by the caller using free().<br>
	 * Original signature : <code>xcb_query_font_reply_t* xcb_query_font_reply(xcb_connection_t*, xcb_query_font_cookie_t, xcb_generic_error_t**)</code><br>
	 * @param c <<br>
	 * @param cookie <<br>
	 * @param e <<br>
	 * <i>native declaration : xcb/xproto.h:6458</i>
	 */
	xcb_query_font_reply_t xcb_query_font_reply(PointerByReference c, xcb.xcb_query_font_cookie_t.ByValue cookie, xcb_generic_error_t.ByReference e[]);
	/**
	 * Original signature : <code>int xcb_query_text_extents_sizeof(const void*, uint32_t)</code><br>
	 * @param _buffer <<br>
	 * @param string_len <<br>
	 * <i>native declaration : xcb/xproto.h:6464</i>
	 */
	int xcb_query_text_extents_sizeof(Pointer _buffer, int string_len);
	/**
	 * @brief get text extents<br>
	 * @param c The connection<br>
	 * @param font The \a font to calculate text extents in. You can also pass a graphics context.<br>
	 * @param string_len The number of characters in \a string.<br>
	 * @param string The text to get text extents for.<br>
	 * @return A cookie<br>
	 * Query text extents from the X11 server. This request returns the bounding box<br>
	 * of the specified 16-bit character string in the specified \a font or the font<br>
	 * contained in the specified graphics context.<br>
	 * <br>
	 * `font_ascent` is set to the maximum of the ascent metrics of all characters in<br>
	 * the string. `font_descent` is set to the maximum of the descent metrics.<br>
	 * `overall_width` is set to the sum of the character-width metrics of all<br>
	 * characters in the string. For each character in the string, let W be the sum of<br>
	 * the character-width metrics of all characters preceding it in the string. Let L<br>
	 * be the left-side-bearing metric of the character plus W. Let R be the<br>
	 * right-side-bearing metric of the character plus W. The lbearing member is set<br>
	 * to the minimum L of all characters in the string. The rbearing member is set to<br>
	 * the maximum R.<br>
	 * <br>
	 * For fonts defined with linear indexing rather than 2-byte matrix indexing, each<br>
	 * `xcb_char2b_t` structure is interpreted as a 16-bit number with byte1 as the<br>
	 * most significant byte. If the font has no defined default character, undefined<br>
	 * characters in the string are taken to have all zero metrics.<br>
	 * <br>
	 * Characters with all zero metrics are ignored. If the font has no defined<br>
	 * default_char, the undefined characters in the string are also ignored.<br>
	 * Original signature : <code>xcb_query_text_extents_cookie_t xcb_query_text_extents(xcb_connection_t*, xcb_fontable_t, uint32_t, const xcb_char2b_t*)</code><br>
	 * @param c <<br>
	 * @param font <<br>
	 * @param string_len <<br>
	 * @param string <<br>
	 * <i>native declaration : xcb/xproto.h:6499</i><br>
	 * @deprecated use the safer method {@link #xcb_query_text_extents(com.sun.jna.ptr.PointerByReference, int, int, xcb.xcb_char2b_t)} instead
	 */
	@Deprecated 
	xcb.xcb_query_text_extents_cookie_t.ByValue xcb_query_text_extents(Pointer c, int font, int string_len, xcb_char2b_t string);
	/**
	 * @brief get text extents<br>
	 * @param c The connection<br>
	 * @param font The \a font to calculate text extents in. You can also pass a graphics context.<br>
	 * @param string_len The number of characters in \a string.<br>
	 * @param string The text to get text extents for.<br>
	 * @return A cookie<br>
	 * Query text extents from the X11 server. This request returns the bounding box<br>
	 * of the specified 16-bit character string in the specified \a font or the font<br>
	 * contained in the specified graphics context.<br>
	 * <br>
	 * `font_ascent` is set to the maximum of the ascent metrics of all characters in<br>
	 * the string. `font_descent` is set to the maximum of the descent metrics.<br>
	 * `overall_width` is set to the sum of the character-width metrics of all<br>
	 * characters in the string. For each character in the string, let W be the sum of<br>
	 * the character-width metrics of all characters preceding it in the string. Let L<br>
	 * be the left-side-bearing metric of the character plus W. Let R be the<br>
	 * right-side-bearing metric of the character plus W. The lbearing member is set<br>
	 * to the minimum L of all characters in the string. The rbearing member is set to<br>
	 * the maximum R.<br>
	 * <br>
	 * For fonts defined with linear indexing rather than 2-byte matrix indexing, each<br>
	 * `xcb_char2b_t` structure is interpreted as a 16-bit number with byte1 as the<br>
	 * most significant byte. If the font has no defined default character, undefined<br>
	 * characters in the string are taken to have all zero metrics.<br>
	 * <br>
	 * Characters with all zero metrics are ignored. If the font has no defined<br>
	 * default_char, the undefined characters in the string are also ignored.<br>
	 * Original signature : <code>xcb_query_text_extents_cookie_t xcb_query_text_extents(xcb_connection_t*, xcb_fontable_t, uint32_t, const xcb_char2b_t*)</code><br>
	 * @param c <<br>
	 * @param font <<br>
	 * @param string_len <<br>
	 * @param string <<br>
	 * <i>native declaration : xcb/xproto.h:6499</i>
	 */
	xcb.xcb_query_text_extents_cookie_t.ByValue xcb_query_text_extents(PointerByReference c, int font, int string_len, xcb_char2b_t string);
	/**
	 * @brief get text extents<br>
	 * @param c The connection<br>
	 * @param font The \a font to calculate text extents in. You can also pass a graphics context.<br>
	 * @param string_len The number of characters in \a string.<br>
	 * @param string The text to get text extents for.<br>
	 * @return A cookie<br>
	 * Query text extents from the X11 server. This request returns the bounding box<br>
	 * of the specified 16-bit character string in the specified \a font or the font<br>
	 * contained in the specified graphics context.<br>
	 * <br>
	 * `font_ascent` is set to the maximum of the ascent metrics of all characters in<br>
	 * the string. `font_descent` is set to the maximum of the descent metrics.<br>
	 * `overall_width` is set to the sum of the character-width metrics of all<br>
	 * characters in the string. For each character in the string, let W be the sum of<br>
	 * the character-width metrics of all characters preceding it in the string. Let L<br>
	 * be the left-side-bearing metric of the character plus W. Let R be the<br>
	 * right-side-bearing metric of the character plus W. The lbearing member is set<br>
	 * to the minimum L of all characters in the string. The rbearing member is set to<br>
	 * the maximum R.<br>
	 * <br>
	 * For fonts defined with linear indexing rather than 2-byte matrix indexing, each<br>
	 * `xcb_char2b_t` structure is interpreted as a 16-bit number with byte1 as the<br>
	 * most significant byte. If the font has no defined default character, undefined<br>
	 * characters in the string are taken to have all zero metrics.<br>
	 * <br>
	 * Characters with all zero metrics are ignored. If the font has no defined<br>
	 * default_char, the undefined characters in the string are also ignored.<br>
	 * This form can be used only if the request will cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * placed in the event queue.<br>
	 * Original signature : <code>xcb_query_text_extents_cookie_t xcb_query_text_extents_unchecked(xcb_connection_t*, xcb_fontable_t, uint32_t, const xcb_char2b_t*)</code><br>
	 * @param c <<br>
	 * @param font <<br>
	 * @param string_len <<br>
	 * @param string <<br>
	 * <i>native declaration : xcb/xproto.h:6537</i><br>
	 * @deprecated use the safer method {@link #xcb_query_text_extents_unchecked(com.sun.jna.ptr.PointerByReference, int, int, xcb.xcb_char2b_t)} instead
	 */
	@Deprecated 
	xcb.xcb_query_text_extents_cookie_t.ByValue xcb_query_text_extents_unchecked(Pointer c, int font, int string_len, xcb_char2b_t string);
	/**
	 * @brief get text extents<br>
	 * @param c The connection<br>
	 * @param font The \a font to calculate text extents in. You can also pass a graphics context.<br>
	 * @param string_len The number of characters in \a string.<br>
	 * @param string The text to get text extents for.<br>
	 * @return A cookie<br>
	 * Query text extents from the X11 server. This request returns the bounding box<br>
	 * of the specified 16-bit character string in the specified \a font or the font<br>
	 * contained in the specified graphics context.<br>
	 * <br>
	 * `font_ascent` is set to the maximum of the ascent metrics of all characters in<br>
	 * the string. `font_descent` is set to the maximum of the descent metrics.<br>
	 * `overall_width` is set to the sum of the character-width metrics of all<br>
	 * characters in the string. For each character in the string, let W be the sum of<br>
	 * the character-width metrics of all characters preceding it in the string. Let L<br>
	 * be the left-side-bearing metric of the character plus W. Let R be the<br>
	 * right-side-bearing metric of the character plus W. The lbearing member is set<br>
	 * to the minimum L of all characters in the string. The rbearing member is set to<br>
	 * the maximum R.<br>
	 * <br>
	 * For fonts defined with linear indexing rather than 2-byte matrix indexing, each<br>
	 * `xcb_char2b_t` structure is interpreted as a 16-bit number with byte1 as the<br>
	 * most significant byte. If the font has no defined default character, undefined<br>
	 * characters in the string are taken to have all zero metrics.<br>
	 * <br>
	 * Characters with all zero metrics are ignored. If the font has no defined<br>
	 * default_char, the undefined characters in the string are also ignored.<br>
	 * This form can be used only if the request will cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * placed in the event queue.<br>
	 * Original signature : <code>xcb_query_text_extents_cookie_t xcb_query_text_extents_unchecked(xcb_connection_t*, xcb_fontable_t, uint32_t, const xcb_char2b_t*)</code><br>
	 * @param c <<br>
	 * @param font <<br>
	 * @param string_len <<br>
	 * @param string <<br>
	 * <i>native declaration : xcb/xproto.h:6537</i>
	 */
	xcb.xcb_query_text_extents_cookie_t.ByValue xcb_query_text_extents_unchecked(PointerByReference c, int font, int string_len, xcb_char2b_t string);
	/**
	 * Return the reply<br>
	 * @param c      The connection<br>
	 * @param cookie The cookie<br>
	 * @param e      The xcb_generic_error_t supplied<br>
	 * Returns the reply of the request asked by<br>
	 * The parameter @p e supplied to this function must be NULL if<br>
	 * xcb_query_text_extents_unchecked(). is used.<br>
	 * Otherwise, it stores the error if any.<br>
	 * The returned value must be freed by the caller using free().<br>
	 * Original signature : <code>xcb_query_text_extents_reply_t* xcb_query_text_extents_reply(xcb_connection_t*, xcb_query_text_extents_cookie_t, xcb_generic_error_t**)</code><br>
	 * @param c <<br>
	 * @param cookie <<br>
	 * @param e <<br>
	 * <i>native declaration : xcb/xproto.h:6553</i><br>
	 * @deprecated use the safer method {@link #xcb_query_text_extents_reply(com.sun.jna.ptr.PointerByReference, xcb.xcb_query_text_extents_cookie_t.ByValue, xcb.xcb_generic_error_t.ByReference[])} instead
	 */
	@Deprecated 
	xcb_query_text_extents_reply_t xcb_query_text_extents_reply(Pointer c, xcb.xcb_query_text_extents_cookie_t.ByValue cookie, PointerByReference e);
	/**
	 * Return the reply<br>
	 * @param c      The connection<br>
	 * @param cookie The cookie<br>
	 * @param e      The xcb_generic_error_t supplied<br>
	 * Returns the reply of the request asked by<br>
	 * The parameter @p e supplied to this function must be NULL if<br>
	 * xcb_query_text_extents_unchecked(). is used.<br>
	 * Otherwise, it stores the error if any.<br>
	 * The returned value must be freed by the caller using free().<br>
	 * Original signature : <code>xcb_query_text_extents_reply_t* xcb_query_text_extents_reply(xcb_connection_t*, xcb_query_text_extents_cookie_t, xcb_generic_error_t**)</code><br>
	 * @param c <<br>
	 * @param cookie <<br>
	 * @param e <<br>
	 * <i>native declaration : xcb/xproto.h:6553</i>
	 */
	xcb_query_text_extents_reply_t xcb_query_text_extents_reply(PointerByReference c, xcb.xcb_query_text_extents_cookie_t.ByValue cookie, xcb_generic_error_t.ByReference e[]);
	/**
	 * Original signature : <code>int xcb_str_sizeof(const void*)</code><br>
	 * @param _buffer <<br>
	 * <i>native declaration : xcb/xproto.h:6558</i>
	 */
	int xcb_str_sizeof(Pointer _buffer);
	/**
	 * Original signature : <code>char* xcb_str_name(const xcb_str_t*)</code><br>
	 * @param R <<br>
	 * <i>native declaration : xcb/xproto.h:6563</i>
	 */
	Pointer xcb_str_name(xcb_str_t R);
	/**
	 * Original signature : <code>int xcb_str_name_length(const xcb_str_t*)</code><br>
	 * @param R <<br>
	 * <i>native declaration : xcb/xproto.h:6568</i>
	 */
	int xcb_str_name_length(xcb_str_t R);
	/**
	 * Original signature : <code>xcb_generic_iterator_t xcb_str_name_end(const xcb_str_t*)</code><br>
	 * @param R <<br>
	 * <i>native declaration : xcb/xproto.h:6573</i>
	 */
	xcb.xcb_generic_iterator_t.ByValue xcb_str_name_end(xcb_str_t R);
	/**
	 * Get the next element of the iterator<br>
	 * @param i Pointer to a xcb_str_iterator_t<br>
	 * Get the next element in the iterator. The member rem is<br>
	 * decreased by one. The member data points to the next<br>
	 * element. The member index is increased by sizeof(xcb_str_t)<br>
	 * Original signature : <code>void xcb_str_next(xcb_str_iterator_t*)</code><br>
	 * @param i <<br>
	 * <i>native declaration : xcb/xproto.h:6583</i>
	 */
	void xcb_str_next(xcb_str_iterator_t i);
	/**
	 * Return the iterator pointing to the last element<br>
	 * @param i An xcb_str_iterator_t<br>
	 * @return  The iterator pointing to the last element<br>
	 * Set the current element in the iterator to the last element.<br>
	 * The member rem is set to 0. The member data points to the<br>
	 * last element.<br>
	 * Original signature : <code>xcb_generic_iterator_t xcb_str_end(xcb_str_iterator_t)</code><br>
	 * @param i <<br>
	 * <i>native declaration : xcb/xproto.h:6594</i>
	 */
	xcb.xcb_generic_iterator_t.ByValue xcb_str_end(xcb_str_iterator_t.ByValue i);
	/**
	 * Original signature : <code>int xcb_list_fonts_sizeof(const void*)</code><br>
	 * @param _buffer <<br>
	 * <i>native declaration : xcb/xproto.h:6599</i>
	 */
	int xcb_list_fonts_sizeof(Pointer _buffer);
	/**
	 * @brief get matching font names<br>
	 * @param c The connection<br>
	 * @param max_names The maximum number of fonts to be returned.<br>
	 * @param pattern_len The length (in bytes) of \a pattern.<br>
	 * @param pattern A font pattern, for example "-misc-fixed-*".<br>
	 * \n<br>
	 * The asterisk (*) is a wildcard for any number of characters. The question mark<br>
	 * (?) is a wildcard for a single character. Use of uppercase or lowercase does<br>
	 * not matter.<br>
	 * @return A cookie<br>
	 * Gets a list of available font names which match the given \a pattern.<br>
	 * Original signature : <code>xcb_list_fonts_cookie_t xcb_list_fonts(xcb_connection_t*, uint16_t, uint16_t, const char*)</code><br>
	 * @param c <<br>
	 * @param max_names <<br>
	 * @param pattern_len <<br>
	 * @param pattern <<br>
	 * <i>native declaration : xcb/xproto.h:6618</i><br>
	 * @deprecated use the safer methods {@link #xcb_list_fonts(com.sun.jna.ptr.PointerByReference, short, short, java.lang.String)} and {@link #xcb_list_fonts(com.sun.jna.ptr.PointerByReference, short, short, com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	xcb.xcb_list_fonts_cookie_t.ByValue xcb_list_fonts(Pointer c, short max_names, short pattern_len, Pointer pattern);
	/**
	 * @brief get matching font names<br>
	 * @param c The connection<br>
	 * @param max_names The maximum number of fonts to be returned.<br>
	 * @param pattern_len The length (in bytes) of \a pattern.<br>
	 * @param pattern A font pattern, for example "-misc-fixed-*".<br>
	 * \n<br>
	 * The asterisk (*) is a wildcard for any number of characters. The question mark<br>
	 * (?) is a wildcard for a single character. Use of uppercase or lowercase does<br>
	 * not matter.<br>
	 * @return A cookie<br>
	 * Gets a list of available font names which match the given \a pattern.<br>
	 * Original signature : <code>xcb_list_fonts_cookie_t xcb_list_fonts(xcb_connection_t*, uint16_t, uint16_t, const char*)</code><br>
	 * @param c <<br>
	 * @param max_names <<br>
	 * @param pattern_len <<br>
	 * @param pattern <<br>
	 * <i>native declaration : xcb/xproto.h:6618</i>
	 */
	xcb.xcb_list_fonts_cookie_t.ByValue xcb_list_fonts(PointerByReference c, short max_names, short pattern_len, String pattern);
	/**
	 * @brief get matching font names<br>
	 * @param c The connection<br>
	 * @param max_names The maximum number of fonts to be returned.<br>
	 * @param pattern_len The length (in bytes) of \a pattern.<br>
	 * @param pattern A font pattern, for example "-misc-fixed-*".<br>
	 * \n<br>
	 * The asterisk (*) is a wildcard for any number of characters. The question mark<br>
	 * (?) is a wildcard for a single character. Use of uppercase or lowercase does<br>
	 * not matter.<br>
	 * @return A cookie<br>
	 * Gets a list of available font names which match the given \a pattern.<br>
	 * Original signature : <code>xcb_list_fonts_cookie_t xcb_list_fonts(xcb_connection_t*, uint16_t, uint16_t, const char*)</code><br>
	 * @param c <<br>
	 * @param max_names <<br>
	 * @param pattern_len <<br>
	 * @param pattern <<br>
	 * <i>native declaration : xcb/xproto.h:6618</i>
	 */
	xcb.xcb_list_fonts_cookie_t.ByValue xcb_list_fonts(PointerByReference c, short max_names, short pattern_len, Pointer pattern);
	/**
	 * @brief get matching font names<br>
	 * @param c The connection<br>
	 * @param max_names The maximum number of fonts to be returned.<br>
	 * @param pattern_len The length (in bytes) of \a pattern.<br>
	 * @param pattern A font pattern, for example "-misc-fixed-*".<br>
	 * \n<br>
	 * The asterisk (*) is a wildcard for any number of characters. The question mark<br>
	 * (?) is a wildcard for a single character. Use of uppercase or lowercase does<br>
	 * not matter.<br>
	 * @return A cookie<br>
	 * Gets a list of available font names which match the given \a pattern.<br>
	 * This form can be used only if the request will cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * placed in the event queue.<br>
	 * Original signature : <code>xcb_list_fonts_cookie_t xcb_list_fonts_unchecked(xcb_connection_t*, uint16_t, uint16_t, const char*)</code><br>
	 * @param c <<br>
	 * @param max_names <<br>
	 * @param pattern_len <<br>
	 * @param pattern <<br>
	 * <i>native declaration : xcb/xproto.h:6640</i><br>
	 * @deprecated use the safer methods {@link #xcb_list_fonts_unchecked(com.sun.jna.ptr.PointerByReference, short, short, java.lang.String)} and {@link #xcb_list_fonts_unchecked(com.sun.jna.ptr.PointerByReference, short, short, com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	xcb.xcb_list_fonts_cookie_t.ByValue xcb_list_fonts_unchecked(Pointer c, short max_names, short pattern_len, Pointer pattern);
	/**
	 * @brief get matching font names<br>
	 * @param c The connection<br>
	 * @param max_names The maximum number of fonts to be returned.<br>
	 * @param pattern_len The length (in bytes) of \a pattern.<br>
	 * @param pattern A font pattern, for example "-misc-fixed-*".<br>
	 * \n<br>
	 * The asterisk (*) is a wildcard for any number of characters. The question mark<br>
	 * (?) is a wildcard for a single character. Use of uppercase or lowercase does<br>
	 * not matter.<br>
	 * @return A cookie<br>
	 * Gets a list of available font names which match the given \a pattern.<br>
	 * This form can be used only if the request will cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * placed in the event queue.<br>
	 * Original signature : <code>xcb_list_fonts_cookie_t xcb_list_fonts_unchecked(xcb_connection_t*, uint16_t, uint16_t, const char*)</code><br>
	 * @param c <<br>
	 * @param max_names <<br>
	 * @param pattern_len <<br>
	 * @param pattern <<br>
	 * <i>native declaration : xcb/xproto.h:6640</i>
	 */
	xcb.xcb_list_fonts_cookie_t.ByValue xcb_list_fonts_unchecked(PointerByReference c, short max_names, short pattern_len, String pattern);
	/**
	 * @brief get matching font names<br>
	 * @param c The connection<br>
	 * @param max_names The maximum number of fonts to be returned.<br>
	 * @param pattern_len The length (in bytes) of \a pattern.<br>
	 * @param pattern A font pattern, for example "-misc-fixed-*".<br>
	 * \n<br>
	 * The asterisk (*) is a wildcard for any number of characters. The question mark<br>
	 * (?) is a wildcard for a single character. Use of uppercase or lowercase does<br>
	 * not matter.<br>
	 * @return A cookie<br>
	 * Gets a list of available font names which match the given \a pattern.<br>
	 * This form can be used only if the request will cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * placed in the event queue.<br>
	 * Original signature : <code>xcb_list_fonts_cookie_t xcb_list_fonts_unchecked(xcb_connection_t*, uint16_t, uint16_t, const char*)</code><br>
	 * @param c <<br>
	 * @param max_names <<br>
	 * @param pattern_len <<br>
	 * @param pattern <<br>
	 * <i>native declaration : xcb/xproto.h:6640</i>
	 */
	xcb.xcb_list_fonts_cookie_t.ByValue xcb_list_fonts_unchecked(PointerByReference c, short max_names, short pattern_len, Pointer pattern);
	/**
	 * Original signature : <code>int xcb_list_fonts_names_length(const xcb_list_fonts_reply_t*)</code><br>
	 * @param R <<br>
	 * <i>native declaration : xcb/xproto.h:6645</i>
	 */
	int xcb_list_fonts_names_length(xcb_list_fonts_reply_t R);
	/**
	 * Original signature : <code>xcb_str_iterator_t xcb_list_fonts_names_iterator(const xcb_list_fonts_reply_t*)</code><br>
	 * @param R <<br>
	 * <i>native declaration : xcb/xproto.h:6650</i>
	 */
	xcb_str_iterator_t.ByValue xcb_list_fonts_names_iterator(xcb_list_fonts_reply_t R);
	/**
	 * Return the reply<br>
	 * @param c      The connection<br>
	 * @param cookie The cookie<br>
	 * @param e      The xcb_generic_error_t supplied<br>
	 * Returns the reply of the request asked by<br>
	 * The parameter @p e supplied to this function must be NULL if<br>
	 * xcb_list_fonts_unchecked(). is used.<br>
	 * Otherwise, it stores the error if any.<br>
	 * The returned value must be freed by the caller using free().<br>
	 * Original signature : <code>xcb_list_fonts_reply_t* xcb_list_fonts_reply(xcb_connection_t*, xcb_list_fonts_cookie_t, xcb_generic_error_t**)</code><br>
	 * @param c <<br>
	 * @param cookie <<br>
	 * @param e <<br>
	 * <i>native declaration : xcb/xproto.h:6666</i><br>
	 * @deprecated use the safer method {@link #xcb_list_fonts_reply(com.sun.jna.ptr.PointerByReference, xcb.xcb_list_fonts_cookie_t.ByValue, xcb.xcb_generic_error_t.ByReference[])} instead
	 */
	@Deprecated 
	xcb_list_fonts_reply_t xcb_list_fonts_reply(Pointer c, xcb.xcb_list_fonts_cookie_t.ByValue cookie, PointerByReference e);
	/**
	 * Return the reply<br>
	 * @param c      The connection<br>
	 * @param cookie The cookie<br>
	 * @param e      The xcb_generic_error_t supplied<br>
	 * Returns the reply of the request asked by<br>
	 * The parameter @p e supplied to this function must be NULL if<br>
	 * xcb_list_fonts_unchecked(). is used.<br>
	 * Otherwise, it stores the error if any.<br>
	 * The returned value must be freed by the caller using free().<br>
	 * Original signature : <code>xcb_list_fonts_reply_t* xcb_list_fonts_reply(xcb_connection_t*, xcb_list_fonts_cookie_t, xcb_generic_error_t**)</code><br>
	 * @param c <<br>
	 * @param cookie <<br>
	 * @param e <<br>
	 * <i>native declaration : xcb/xproto.h:6666</i>
	 */
	xcb_list_fonts_reply_t xcb_list_fonts_reply(PointerByReference c, xcb.xcb_list_fonts_cookie_t.ByValue cookie, xcb_generic_error_t.ByReference e[]);
	/**
	 * Original signature : <code>int xcb_list_fonts_with_info_sizeof(const void*)</code><br>
	 * @param _buffer <<br>
	 * <i>native declaration : xcb/xproto.h:6671</i>
	 */
	int xcb_list_fonts_with_info_sizeof(Pointer _buffer);
	/**
	 * @brief get matching font names and information<br>
	 * @param c The connection<br>
	 * @param max_names The maximum number of fonts to be returned.<br>
	 * @param pattern_len The length (in bytes) of \a pattern.<br>
	 * @param pattern A font pattern, for example "-misc-fixed-*".<br>
	 * \n<br>
	 * The asterisk (*) is a wildcard for any number of characters. The question mark<br>
	 * (?) is a wildcard for a single character. Use of uppercase or lowercase does<br>
	 * not matter.<br>
	 * @return A cookie<br>
	 * Gets a list of available font names which match the given \a pattern.<br>
	 * Original signature : <code>xcb_list_fonts_with_info_cookie_t xcb_list_fonts_with_info(xcb_connection_t*, uint16_t, uint16_t, const char*)</code><br>
	 * @param c <<br>
	 * @param max_names <<br>
	 * @param pattern_len <<br>
	 * @param pattern <<br>
	 * <i>native declaration : xcb/xproto.h:6690</i><br>
	 * @deprecated use the safer methods {@link #xcb_list_fonts_with_info(com.sun.jna.ptr.PointerByReference, short, short, java.lang.String)} and {@link #xcb_list_fonts_with_info(com.sun.jna.ptr.PointerByReference, short, short, com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	xcb.xcb_list_fonts_with_info_cookie_t.ByValue xcb_list_fonts_with_info(Pointer c, short max_names, short pattern_len, Pointer pattern);
	/**
	 * @brief get matching font names and information<br>
	 * @param c The connection<br>
	 * @param max_names The maximum number of fonts to be returned.<br>
	 * @param pattern_len The length (in bytes) of \a pattern.<br>
	 * @param pattern A font pattern, for example "-misc-fixed-*".<br>
	 * \n<br>
	 * The asterisk (*) is a wildcard for any number of characters. The question mark<br>
	 * (?) is a wildcard for a single character. Use of uppercase or lowercase does<br>
	 * not matter.<br>
	 * @return A cookie<br>
	 * Gets a list of available font names which match the given \a pattern.<br>
	 * Original signature : <code>xcb_list_fonts_with_info_cookie_t xcb_list_fonts_with_info(xcb_connection_t*, uint16_t, uint16_t, const char*)</code><br>
	 * @param c <<br>
	 * @param max_names <<br>
	 * @param pattern_len <<br>
	 * @param pattern <<br>
	 * <i>native declaration : xcb/xproto.h:6690</i>
	 */
	xcb.xcb_list_fonts_with_info_cookie_t.ByValue xcb_list_fonts_with_info(PointerByReference c, short max_names, short pattern_len, String pattern);
	/**
	 * @brief get matching font names and information<br>
	 * @param c The connection<br>
	 * @param max_names The maximum number of fonts to be returned.<br>
	 * @param pattern_len The length (in bytes) of \a pattern.<br>
	 * @param pattern A font pattern, for example "-misc-fixed-*".<br>
	 * \n<br>
	 * The asterisk (*) is a wildcard for any number of characters. The question mark<br>
	 * (?) is a wildcard for a single character. Use of uppercase or lowercase does<br>
	 * not matter.<br>
	 * @return A cookie<br>
	 * Gets a list of available font names which match the given \a pattern.<br>
	 * Original signature : <code>xcb_list_fonts_with_info_cookie_t xcb_list_fonts_with_info(xcb_connection_t*, uint16_t, uint16_t, const char*)</code><br>
	 * @param c <<br>
	 * @param max_names <<br>
	 * @param pattern_len <<br>
	 * @param pattern <<br>
	 * <i>native declaration : xcb/xproto.h:6690</i>
	 */
	xcb.xcb_list_fonts_with_info_cookie_t.ByValue xcb_list_fonts_with_info(PointerByReference c, short max_names, short pattern_len, Pointer pattern);
	/**
	 * @brief get matching font names and information<br>
	 * @param c The connection<br>
	 * @param max_names The maximum number of fonts to be returned.<br>
	 * @param pattern_len The length (in bytes) of \a pattern.<br>
	 * @param pattern A font pattern, for example "-misc-fixed-*".<br>
	 * \n<br>
	 * The asterisk (*) is a wildcard for any number of characters. The question mark<br>
	 * (?) is a wildcard for a single character. Use of uppercase or lowercase does<br>
	 * not matter.<br>
	 * @return A cookie<br>
	 * Gets a list of available font names which match the given \a pattern.<br>
	 * This form can be used only if the request will cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * placed in the event queue.<br>
	 * Original signature : <code>xcb_list_fonts_with_info_cookie_t xcb_list_fonts_with_info_unchecked(xcb_connection_t*, uint16_t, uint16_t, const char*)</code><br>
	 * @param c <<br>
	 * @param max_names <<br>
	 * @param pattern_len <<br>
	 * @param pattern <<br>
	 * <i>native declaration : xcb/xproto.h:6712</i><br>
	 * @deprecated use the safer methods {@link #xcb_list_fonts_with_info_unchecked(com.sun.jna.ptr.PointerByReference, short, short, java.lang.String)} and {@link #xcb_list_fonts_with_info_unchecked(com.sun.jna.ptr.PointerByReference, short, short, com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	xcb.xcb_list_fonts_with_info_cookie_t.ByValue xcb_list_fonts_with_info_unchecked(Pointer c, short max_names, short pattern_len, Pointer pattern);
	/**
	 * @brief get matching font names and information<br>
	 * @param c The connection<br>
	 * @param max_names The maximum number of fonts to be returned.<br>
	 * @param pattern_len The length (in bytes) of \a pattern.<br>
	 * @param pattern A font pattern, for example "-misc-fixed-*".<br>
	 * \n<br>
	 * The asterisk (*) is a wildcard for any number of characters. The question mark<br>
	 * (?) is a wildcard for a single character. Use of uppercase or lowercase does<br>
	 * not matter.<br>
	 * @return A cookie<br>
	 * Gets a list of available font names which match the given \a pattern.<br>
	 * This form can be used only if the request will cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * placed in the event queue.<br>
	 * Original signature : <code>xcb_list_fonts_with_info_cookie_t xcb_list_fonts_with_info_unchecked(xcb_connection_t*, uint16_t, uint16_t, const char*)</code><br>
	 * @param c <<br>
	 * @param max_names <<br>
	 * @param pattern_len <<br>
	 * @param pattern <<br>
	 * <i>native declaration : xcb/xproto.h:6712</i>
	 */
	xcb.xcb_list_fonts_with_info_cookie_t.ByValue xcb_list_fonts_with_info_unchecked(PointerByReference c, short max_names, short pattern_len, String pattern);
	/**
	 * @brief get matching font names and information<br>
	 * @param c The connection<br>
	 * @param max_names The maximum number of fonts to be returned.<br>
	 * @param pattern_len The length (in bytes) of \a pattern.<br>
	 * @param pattern A font pattern, for example "-misc-fixed-*".<br>
	 * \n<br>
	 * The asterisk (*) is a wildcard for any number of characters. The question mark<br>
	 * (?) is a wildcard for a single character. Use of uppercase or lowercase does<br>
	 * not matter.<br>
	 * @return A cookie<br>
	 * Gets a list of available font names which match the given \a pattern.<br>
	 * This form can be used only if the request will cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * placed in the event queue.<br>
	 * Original signature : <code>xcb_list_fonts_with_info_cookie_t xcb_list_fonts_with_info_unchecked(xcb_connection_t*, uint16_t, uint16_t, const char*)</code><br>
	 * @param c <<br>
	 * @param max_names <<br>
	 * @param pattern_len <<br>
	 * @param pattern <<br>
	 * <i>native declaration : xcb/xproto.h:6712</i>
	 */
	xcb.xcb_list_fonts_with_info_cookie_t.ByValue xcb_list_fonts_with_info_unchecked(PointerByReference c, short max_names, short pattern_len, Pointer pattern);
	/**
	 * Original signature : <code>xcb_fontprop_t* xcb_list_fonts_with_info_properties(const xcb_list_fonts_with_info_reply_t*)</code><br>
	 * @param R <<br>
	 * <i>native declaration : xcb/xproto.h:6717</i>
	 */
	xcb_fontprop_t xcb_list_fonts_with_info_properties(xcb_list_fonts_with_info_reply_t R);
	/**
	 * Original signature : <code>int xcb_list_fonts_with_info_properties_length(const xcb_list_fonts_with_info_reply_t*)</code><br>
	 * @param R <<br>
	 * <i>native declaration : xcb/xproto.h:6722</i>
	 */
	int xcb_list_fonts_with_info_properties_length(xcb_list_fonts_with_info_reply_t R);
	/**
	 * Original signature : <code>xcb_fontprop_iterator_t xcb_list_fonts_with_info_properties_iterator(const xcb_list_fonts_with_info_reply_t*)</code><br>
	 * @param R <<br>
	 * <i>native declaration : xcb/xproto.h:6727</i>
	 */
	xcb_fontprop_iterator_t.ByValue xcb_list_fonts_with_info_properties_iterator(xcb_list_fonts_with_info_reply_t R);
	/**
	 * Original signature : <code>char* xcb_list_fonts_with_info_name(const xcb_list_fonts_with_info_reply_t*)</code><br>
	 * @param R <<br>
	 * <i>native declaration : xcb/xproto.h:6732</i>
	 */
	Pointer xcb_list_fonts_with_info_name(xcb_list_fonts_with_info_reply_t R);
	/**
	 * Original signature : <code>int xcb_list_fonts_with_info_name_length(const xcb_list_fonts_with_info_reply_t*)</code><br>
	 * @param R <<br>
	 * <i>native declaration : xcb/xproto.h:6737</i>
	 */
	int xcb_list_fonts_with_info_name_length(xcb_list_fonts_with_info_reply_t R);
	/**
	 * Original signature : <code>xcb_generic_iterator_t xcb_list_fonts_with_info_name_end(const xcb_list_fonts_with_info_reply_t*)</code><br>
	 * @param R <<br>
	 * <i>native declaration : xcb/xproto.h:6742</i>
	 */
	xcb.xcb_generic_iterator_t.ByValue xcb_list_fonts_with_info_name_end(xcb_list_fonts_with_info_reply_t R);
	/**
	 * Return the reply<br>
	 * @param c      The connection<br>
	 * @param cookie The cookie<br>
	 * @param e      The xcb_generic_error_t supplied<br>
	 * Returns the reply of the request asked by<br>
	 * The parameter @p e supplied to this function must be NULL if<br>
	 * xcb_list_fonts_with_info_unchecked(). is used.<br>
	 * Otherwise, it stores the error if any.<br>
	 * The returned value must be freed by the caller using free().<br>
	 * Original signature : <code>xcb_list_fonts_with_info_reply_t* xcb_list_fonts_with_info_reply(xcb_connection_t*, xcb_list_fonts_with_info_cookie_t, xcb_generic_error_t**)</code><br>
	 * @param c <<br>
	 * @param cookie <<br>
	 * @param e <<br>
	 * <i>native declaration : xcb/xproto.h:6758</i><br>
	 * @deprecated use the safer method {@link #xcb_list_fonts_with_info_reply(com.sun.jna.ptr.PointerByReference, xcb.xcb_list_fonts_with_info_cookie_t.ByValue, xcb.xcb_generic_error_t.ByReference[])} instead
	 */
	@Deprecated 
	xcb_list_fonts_with_info_reply_t xcb_list_fonts_with_info_reply(Pointer c, xcb.xcb_list_fonts_with_info_cookie_t.ByValue cookie, PointerByReference e);
	/**
	 * Return the reply<br>
	 * @param c      The connection<br>
	 * @param cookie The cookie<br>
	 * @param e      The xcb_generic_error_t supplied<br>
	 * Returns the reply of the request asked by<br>
	 * The parameter @p e supplied to this function must be NULL if<br>
	 * xcb_list_fonts_with_info_unchecked(). is used.<br>
	 * Otherwise, it stores the error if any.<br>
	 * The returned value must be freed by the caller using free().<br>
	 * Original signature : <code>xcb_list_fonts_with_info_reply_t* xcb_list_fonts_with_info_reply(xcb_connection_t*, xcb_list_fonts_with_info_cookie_t, xcb_generic_error_t**)</code><br>
	 * @param c <<br>
	 * @param cookie <<br>
	 * @param e <<br>
	 * <i>native declaration : xcb/xproto.h:6758</i>
	 */
	xcb_list_fonts_with_info_reply_t xcb_list_fonts_with_info_reply(PointerByReference c, xcb.xcb_list_fonts_with_info_cookie_t.ByValue cookie, xcb_generic_error_t.ByReference e[]);
	/**
	 * Original signature : <code>int xcb_set_font_path_sizeof(const void*)</code><br>
	 * @param _buffer <<br>
	 * <i>native declaration : xcb/xproto.h:6763</i>
	 */
	int xcb_set_font_path_sizeof(Pointer _buffer);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_set_font_path_checked(xcb_connection_t*, uint16_t, const xcb_str_t*)</code><br>
	 * @param c <<br>
	 * @param font_qty <<br>
	 * @param font <<br>
	 * <i>native declaration : xcb/xproto.h:6776</i><br>
	 * @deprecated use the safer method {@link #xcb_set_font_path_checked(com.sun.jna.ptr.PointerByReference, short, xcb.xcb_str_t)} instead
	 */
	@Deprecated 
	xcb.xcb_void_cookie_t.ByValue xcb_set_font_path_checked(Pointer c, short font_qty, xcb_str_t font);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_set_font_path_checked(xcb_connection_t*, uint16_t, const xcb_str_t*)</code><br>
	 * @param c <<br>
	 * @param font_qty <<br>
	 * @param font <<br>
	 * <i>native declaration : xcb/xproto.h:6776</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_set_font_path_checked(PointerByReference c, short font_qty, xcb_str_t font);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_set_font_path(xcb_connection_t*, uint16_t, const xcb_str_t*)</code><br>
	 * @param c <<br>
	 * @param font_qty <<br>
	 * @param font <<br>
	 * <i>native declaration : xcb/xproto.h:6786</i><br>
	 * @deprecated use the safer method {@link #xcb_set_font_path(com.sun.jna.ptr.PointerByReference, short, xcb.xcb_str_t)} instead
	 */
	@Deprecated 
	xcb.xcb_void_cookie_t.ByValue xcb_set_font_path(Pointer c, short font_qty, xcb_str_t font);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_set_font_path(xcb_connection_t*, uint16_t, const xcb_str_t*)</code><br>
	 * @param c <<br>
	 * @param font_qty <<br>
	 * @param font <<br>
	 * <i>native declaration : xcb/xproto.h:6786</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_set_font_path(PointerByReference c, short font_qty, xcb_str_t font);
	/**
	 * Original signature : <code>int xcb_get_font_path_sizeof(const void*)</code><br>
	 * @param _buffer <<br>
	 * <i>native declaration : xcb/xproto.h:6791</i>
	 */
	int xcb_get_font_path_sizeof(Pointer _buffer);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_get_font_path_cookie_t xcb_get_font_path(xcb_connection_t*)</code><br>
	 * @param c <<br>
	 * <i>native declaration : xcb/xproto.h:6799</i><br>
	 * @deprecated use the safer method {@link #xcb_get_font_path(com.sun.jna.ptr.PointerByReference)} instead
	 */
	@Deprecated 
	xcb.xcb_get_font_path_cookie_t.ByValue xcb_get_font_path(Pointer c);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_get_font_path_cookie_t xcb_get_font_path(xcb_connection_t*)</code><br>
	 * @param c <<br>
	 * <i>native declaration : xcb/xproto.h:6799</i>
	 */
	xcb.xcb_get_font_path_cookie_t.ByValue xcb_get_font_path(PointerByReference c);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * placed in the event queue.<br>
	 * Original signature : <code>xcb_get_font_path_cookie_t xcb_get_font_path_unchecked(xcb_connection_t*)</code><br>
	 * @param c <<br>
	 * <i>native declaration : xcb/xproto.h:6810</i><br>
	 * @deprecated use the safer method {@link #xcb_get_font_path_unchecked(com.sun.jna.ptr.PointerByReference)} instead
	 */
	@Deprecated 
	xcb.xcb_get_font_path_cookie_t.ByValue xcb_get_font_path_unchecked(Pointer c);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * placed in the event queue.<br>
	 * Original signature : <code>xcb_get_font_path_cookie_t xcb_get_font_path_unchecked(xcb_connection_t*)</code><br>
	 * @param c <<br>
	 * <i>native declaration : xcb/xproto.h:6810</i>
	 */
	xcb.xcb_get_font_path_cookie_t.ByValue xcb_get_font_path_unchecked(PointerByReference c);
	/**
	 * Original signature : <code>int xcb_get_font_path_path_length(const xcb_get_font_path_reply_t*)</code><br>
	 * @param R <<br>
	 * <i>native declaration : xcb/xproto.h:6815</i>
	 */
	int xcb_get_font_path_path_length(xcb_get_font_path_reply_t R);
	/**
	 * Original signature : <code>xcb_str_iterator_t xcb_get_font_path_path_iterator(const xcb_get_font_path_reply_t*)</code><br>
	 * @param R <<br>
	 * <i>native declaration : xcb/xproto.h:6820</i>
	 */
	xcb_str_iterator_t.ByValue xcb_get_font_path_path_iterator(xcb_get_font_path_reply_t R);
	/**
	 * Return the reply<br>
	 * @param c      The connection<br>
	 * @param cookie The cookie<br>
	 * @param e      The xcb_generic_error_t supplied<br>
	 * Returns the reply of the request asked by<br>
	 * The parameter @p e supplied to this function must be NULL if<br>
	 * xcb_get_font_path_unchecked(). is used.<br>
	 * Otherwise, it stores the error if any.<br>
	 * The returned value must be freed by the caller using free().<br>
	 * Original signature : <code>xcb_get_font_path_reply_t* xcb_get_font_path_reply(xcb_connection_t*, xcb_get_font_path_cookie_t, xcb_generic_error_t**)</code><br>
	 * @param c <<br>
	 * @param cookie <<br>
	 * @param e <<br>
	 * <i>native declaration : xcb/xproto.h:6836</i><br>
	 * @deprecated use the safer method {@link #xcb_get_font_path_reply(com.sun.jna.ptr.PointerByReference, xcb.xcb_get_font_path_cookie_t.ByValue, xcb.xcb_generic_error_t.ByReference[])} instead
	 */
	@Deprecated 
	xcb_get_font_path_reply_t xcb_get_font_path_reply(Pointer c, xcb.xcb_get_font_path_cookie_t.ByValue cookie, PointerByReference e);
	/**
	 * Return the reply<br>
	 * @param c      The connection<br>
	 * @param cookie The cookie<br>
	 * @param e      The xcb_generic_error_t supplied<br>
	 * Returns the reply of the request asked by<br>
	 * The parameter @p e supplied to this function must be NULL if<br>
	 * xcb_get_font_path_unchecked(). is used.<br>
	 * Otherwise, it stores the error if any.<br>
	 * The returned value must be freed by the caller using free().<br>
	 * Original signature : <code>xcb_get_font_path_reply_t* xcb_get_font_path_reply(xcb_connection_t*, xcb_get_font_path_cookie_t, xcb_generic_error_t**)</code><br>
	 * @param c <<br>
	 * @param cookie <<br>
	 * @param e <<br>
	 * <i>native declaration : xcb/xproto.h:6836</i>
	 */
	xcb_get_font_path_reply_t xcb_get_font_path_reply(PointerByReference c, xcb.xcb_get_font_path_cookie_t.ByValue cookie, xcb_generic_error_t.ByReference e[]);
	/**
	 * @brief Creates a pixmap<br>
	 * @param c The connection<br>
	 * @param depth TODO<br>
	 * @param pid The ID with which you will refer to the new pixmap, created by<br>
	 * `xcb_generate_id`.<br>
	 * @param drawable Drawable to get the screen from.<br>
	 * @param width The width of the new pixmap.<br>
	 * @param height The height of the new pixmap.<br>
	 * @return A cookie<br>
	 * Creates a pixmap. The pixmap can only be used on the same screen as \a drawable<br>
	 * is on and only with drawables of the same \a depth.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_create_pixmap_checked(xcb_connection_t*, uint8_t, xcb_pixmap_t, xcb_drawable_t, uint16_t, uint16_t)</code><br>
	 * @param c <<br>
	 * @param depth <<br>
	 * @param pid <<br>
	 * @param drawable <<br>
	 * @param width <<br>
	 * @param height <<br>
	 * <i>native declaration : xcb/xproto.h:6860</i><br>
	 * @deprecated use the safer method {@link #xcb_create_pixmap_checked(com.sun.jna.ptr.PointerByReference, byte, int, int, short, short)} instead
	 */
	@Deprecated 
	xcb.xcb_void_cookie_t.ByValue xcb_create_pixmap_checked(Pointer c, byte depth, int pid, int drawable, short width, short height);
	/**
	 * @brief Creates a pixmap<br>
	 * @param c The connection<br>
	 * @param depth TODO<br>
	 * @param pid The ID with which you will refer to the new pixmap, created by<br>
	 * `xcb_generate_id`.<br>
	 * @param drawable Drawable to get the screen from.<br>
	 * @param width The width of the new pixmap.<br>
	 * @param height The height of the new pixmap.<br>
	 * @return A cookie<br>
	 * Creates a pixmap. The pixmap can only be used on the same screen as \a drawable<br>
	 * is on and only with drawables of the same \a depth.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_create_pixmap_checked(xcb_connection_t*, uint8_t, xcb_pixmap_t, xcb_drawable_t, uint16_t, uint16_t)</code><br>
	 * @param c <<br>
	 * @param depth <<br>
	 * @param pid <<br>
	 * @param drawable <<br>
	 * @param width <<br>
	 * @param height <<br>
	 * <i>native declaration : xcb/xproto.h:6860</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_create_pixmap_checked(PointerByReference c, byte depth, int pid, int drawable, short width, short height);
	/**
	 * @brief Creates a pixmap<br>
	 * @param c The connection<br>
	 * @param depth TODO<br>
	 * @param pid The ID with which you will refer to the new pixmap, created by<br>
	 * `xcb_generate_id`.<br>
	 * @param drawable Drawable to get the screen from.<br>
	 * @param width The width of the new pixmap.<br>
	 * @param height The height of the new pixmap.<br>
	 * @return A cookie<br>
	 * Creates a pixmap. The pixmap can only be used on the same screen as \a drawable<br>
	 * is on and only with drawables of the same \a depth.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_create_pixmap(xcb_connection_t*, uint8_t, xcb_pixmap_t, xcb_drawable_t, uint16_t, uint16_t)</code><br>
	 * @param c <<br>
	 * @param depth <<br>
	 * @param pid <<br>
	 * @param drawable <<br>
	 * @param width <<br>
	 * @param height <<br>
	 * <i>native declaration : xcb/xproto.h:6881</i><br>
	 * @deprecated use the safer method {@link #xcb_create_pixmap(com.sun.jna.ptr.PointerByReference, byte, int, int, short, short)} instead
	 */
	@Deprecated 
	xcb.xcb_void_cookie_t.ByValue xcb_create_pixmap(Pointer c, byte depth, int pid, int drawable, short width, short height);
	/**
	 * @brief Creates a pixmap<br>
	 * @param c The connection<br>
	 * @param depth TODO<br>
	 * @param pid The ID with which you will refer to the new pixmap, created by<br>
	 * `xcb_generate_id`.<br>
	 * @param drawable Drawable to get the screen from.<br>
	 * @param width The width of the new pixmap.<br>
	 * @param height The height of the new pixmap.<br>
	 * @return A cookie<br>
	 * Creates a pixmap. The pixmap can only be used on the same screen as \a drawable<br>
	 * is on and only with drawables of the same \a depth.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_create_pixmap(xcb_connection_t*, uint8_t, xcb_pixmap_t, xcb_drawable_t, uint16_t, uint16_t)</code><br>
	 * @param c <<br>
	 * @param depth <<br>
	 * @param pid <<br>
	 * @param drawable <<br>
	 * @param width <<br>
	 * @param height <<br>
	 * <i>native declaration : xcb/xproto.h:6881</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_create_pixmap(PointerByReference c, byte depth, int pid, int drawable, short width, short height);
	/**
	 * @brief Destroys a pixmap<br>
	 * @param c The connection<br>
	 * @param pixmap The pixmap to destroy.<br>
	 * @return A cookie<br>
	 * Deletes the association between the pixmap ID and the pixmap. The pixmap<br>
	 * storage will be freed when there are no more references to it.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_free_pixmap_checked(xcb_connection_t*, xcb_pixmap_t)</code><br>
	 * @param c <<br>
	 * @param pixmap <<br>
	 * <i>native declaration : xcb/xproto.h:6896</i><br>
	 * @deprecated use the safer method {@link #xcb_free_pixmap_checked(com.sun.jna.ptr.PointerByReference, int)} instead
	 */
	@Deprecated 
	xcb.xcb_void_cookie_t.ByValue xcb_free_pixmap_checked(Pointer c, int pixmap);
	/**
	 * @brief Destroys a pixmap<br>
	 * @param c The connection<br>
	 * @param pixmap The pixmap to destroy.<br>
	 * @return A cookie<br>
	 * Deletes the association between the pixmap ID and the pixmap. The pixmap<br>
	 * storage will be freed when there are no more references to it.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_free_pixmap_checked(xcb_connection_t*, xcb_pixmap_t)</code><br>
	 * @param c <<br>
	 * @param pixmap <<br>
	 * <i>native declaration : xcb/xproto.h:6896</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_free_pixmap_checked(PointerByReference c, int pixmap);
	/**
	 * @brief Destroys a pixmap<br>
	 * @param c The connection<br>
	 * @param pixmap The pixmap to destroy.<br>
	 * @return A cookie<br>
	 * Deletes the association between the pixmap ID and the pixmap. The pixmap<br>
	 * storage will be freed when there are no more references to it.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_free_pixmap(xcb_connection_t*, xcb_pixmap_t)</code><br>
	 * @param c <<br>
	 * @param pixmap <<br>
	 * <i>native declaration : xcb/xproto.h:6908</i><br>
	 * @deprecated use the safer method {@link #xcb_free_pixmap(com.sun.jna.ptr.PointerByReference, int)} instead
	 */
	@Deprecated 
	xcb.xcb_void_cookie_t.ByValue xcb_free_pixmap(Pointer c, int pixmap);
	/**
	 * @brief Destroys a pixmap<br>
	 * @param c The connection<br>
	 * @param pixmap The pixmap to destroy.<br>
	 * @return A cookie<br>
	 * Deletes the association between the pixmap ID and the pixmap. The pixmap<br>
	 * storage will be freed when there are no more references to it.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_free_pixmap(xcb_connection_t*, xcb_pixmap_t)</code><br>
	 * @param c <<br>
	 * @param pixmap <<br>
	 * <i>native declaration : xcb/xproto.h:6908</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_free_pixmap(PointerByReference c, int pixmap);
	/**
	 * Original signature : <code>int xcb_create_gc_sizeof(const void*)</code><br>
	 * @param _buffer <<br>
	 * <i>native declaration : xcb/xproto.h:6913</i>
	 */
	int xcb_create_gc_sizeof(Pointer _buffer);
	/**
	 * @brief Creates a graphics context<br>
	 * @param c The connection<br>
	 * @param cid The ID with which you will refer to the graphics context, created by<br>
	 * `xcb_generate_id`.<br>
	 * @param drawable Drawable to get the root/depth from.<br>
	 * @return A cookie<br>
	 * Creates a graphics context. The graphics context can be used with any drawable<br>
	 * that has the same root and depth as the specified drawable.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_create_gc_checked(xcb_connection_t*, xcb_gcontext_t, xcb_drawable_t, uint32_t, const uint32_t*)</code><br>
	 * @param c <<br>
	 * @param cid <<br>
	 * @param drawable <<br>
	 * @param value_mask <<br>
	 * @param value_list <<br>
	 * <i>native declaration : xcb/xproto.h:6933</i><br>
	 * @deprecated use the safer methods {@link #xcb_create_gc_checked(com.sun.jna.ptr.PointerByReference, int, int, int, int[])} and {@link #xcb_create_gc_checked(com.sun.jna.ptr.PointerByReference, int, int, int, com.sun.jna.ptr.IntByReference)} instead
	 */
	@Deprecated 
	xcb.xcb_void_cookie_t.ByValue xcb_create_gc_checked(Pointer c, int cid, int drawable, int value_mask, IntByReference value_list);
	/**
	 * @brief Creates a graphics context<br>
	 * @param c The connection<br>
	 * @param cid The ID with which you will refer to the graphics context, created by<br>
	 * `xcb_generate_id`.<br>
	 * @param drawable Drawable to get the root/depth from.<br>
	 * @return A cookie<br>
	 * Creates a graphics context. The graphics context can be used with any drawable<br>
	 * that has the same root and depth as the specified drawable.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_create_gc_checked(xcb_connection_t*, xcb_gcontext_t, xcb_drawable_t, uint32_t, const uint32_t*)</code><br>
	 * @param c <<br>
	 * @param cid <<br>
	 * @param drawable <<br>
	 * @param value_mask <<br>
	 * @param value_list <<br>
	 * <i>native declaration : xcb/xproto.h:6933</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_create_gc_checked(PointerByReference c, int cid, int drawable, int value_mask, int value_list[]);
	/**
	 * @brief Creates a graphics context<br>
	 * @param c The connection<br>
	 * @param cid The ID with which you will refer to the graphics context, created by<br>
	 * `xcb_generate_id`.<br>
	 * @param drawable Drawable to get the root/depth from.<br>
	 * @return A cookie<br>
	 * Creates a graphics context. The graphics context can be used with any drawable<br>
	 * that has the same root and depth as the specified drawable.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_create_gc_checked(xcb_connection_t*, xcb_gcontext_t, xcb_drawable_t, uint32_t, const uint32_t*)</code><br>
	 * @param c <<br>
	 * @param cid <<br>
	 * @param drawable <<br>
	 * @param value_mask <<br>
	 * @param value_list <<br>
	 * <i>native declaration : xcb/xproto.h:6933</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_create_gc_checked(PointerByReference c, int cid, int drawable, int value_mask, IntByReference value_list);
	/**
	 * @brief Creates a graphics context<br>
	 * @param c The connection<br>
	 * @param cid The ID with which you will refer to the graphics context, created by<br>
	 * `xcb_generate_id`.<br>
	 * @param drawable Drawable to get the root/depth from.<br>
	 * @return A cookie<br>
	 * Creates a graphics context. The graphics context can be used with any drawable<br>
	 * that has the same root and depth as the specified drawable.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_create_gc(xcb_connection_t*, xcb_gcontext_t, xcb_drawable_t, uint32_t, const uint32_t*)</code><br>
	 * @param c <<br>
	 * @param cid <<br>
	 * @param drawable <<br>
	 * @param value_mask <<br>
	 * @param value_list <<br>
	 * <i>native declaration : xcb/xproto.h:6950</i><br>
	 * @deprecated use the safer methods {@link #xcb_create_gc(com.sun.jna.ptr.PointerByReference, int, int, int, int[])} and {@link #xcb_create_gc(com.sun.jna.ptr.PointerByReference, int, int, int, com.sun.jna.ptr.IntByReference)} instead
	 */
	@Deprecated 
	xcb.xcb_void_cookie_t.ByValue xcb_create_gc(Pointer c, int cid, int drawable, int value_mask, IntByReference value_list);
	/**
	 * @brief Creates a graphics context<br>
	 * @param c The connection<br>
	 * @param cid The ID with which you will refer to the graphics context, created by<br>
	 * `xcb_generate_id`.<br>
	 * @param drawable Drawable to get the root/depth from.<br>
	 * @return A cookie<br>
	 * Creates a graphics context. The graphics context can be used with any drawable<br>
	 * that has the same root and depth as the specified drawable.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_create_gc(xcb_connection_t*, xcb_gcontext_t, xcb_drawable_t, uint32_t, const uint32_t*)</code><br>
	 * @param c <<br>
	 * @param cid <<br>
	 * @param drawable <<br>
	 * @param value_mask <<br>
	 * @param value_list <<br>
	 * <i>native declaration : xcb/xproto.h:6950</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_create_gc(PointerByReference c, int cid, int drawable, int value_mask, int value_list[]);
	/**
	 * @brief Creates a graphics context<br>
	 * @param c The connection<br>
	 * @param cid The ID with which you will refer to the graphics context, created by<br>
	 * `xcb_generate_id`.<br>
	 * @param drawable Drawable to get the root/depth from.<br>
	 * @return A cookie<br>
	 * Creates a graphics context. The graphics context can be used with any drawable<br>
	 * that has the same root and depth as the specified drawable.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_create_gc(xcb_connection_t*, xcb_gcontext_t, xcb_drawable_t, uint32_t, const uint32_t*)</code><br>
	 * @param c <<br>
	 * @param cid <<br>
	 * @param drawable <<br>
	 * @param value_mask <<br>
	 * @param value_list <<br>
	 * <i>native declaration : xcb/xproto.h:6950</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_create_gc(PointerByReference c, int cid, int drawable, int value_mask, IntByReference value_list);
	/**
	 * Original signature : <code>int xcb_change_gc_sizeof(const void*)</code><br>
	 * @param _buffer <<br>
	 * <i>native declaration : xcb/xproto.h:6955</i>
	 */
	int xcb_change_gc_sizeof(Pointer _buffer);
	/**
	 * @brief change graphics context components<br>
	 * @param c The connection<br>
	 * @param gc The graphics context to change.<br>
	 * @param value_mask A bitmask of #xcb_gc_t values.<br>
	 * @param value_mask \n<br>
	 * @param value_list Values for each of the components specified in the bitmask \a value_mask. The<br>
	 * order has to correspond to the order of possible \a value_mask bits. See the<br>
	 * example.<br>
	 * @return A cookie<br>
	 * Changes the components specified by \a value_mask for the specified graphics context.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_change_gc_checked(xcb_connection_t*, xcb_gcontext_t, uint32_t, const uint32_t*)</code><br>
	 * @param c <<br>
	 * @param gc <<br>
	 * @param value_mask <<br>
	 * @param value_list <<br>
	 * <i>native declaration : xcb/xproto.h:6976</i><br>
	 * @deprecated use the safer methods {@link #xcb_change_gc_checked(com.sun.jna.ptr.PointerByReference, int, int, int[])} and {@link #xcb_change_gc_checked(com.sun.jna.ptr.PointerByReference, int, int, com.sun.jna.ptr.IntByReference)} instead
	 */
	@Deprecated 
	xcb.xcb_void_cookie_t.ByValue xcb_change_gc_checked(Pointer c, int gc, int value_mask, IntByReference value_list);
	/**
	 * @brief change graphics context components<br>
	 * @param c The connection<br>
	 * @param gc The graphics context to change.<br>
	 * @param value_mask A bitmask of #xcb_gc_t values.<br>
	 * @param value_mask \n<br>
	 * @param value_list Values for each of the components specified in the bitmask \a value_mask. The<br>
	 * order has to correspond to the order of possible \a value_mask bits. See the<br>
	 * example.<br>
	 * @return A cookie<br>
	 * Changes the components specified by \a value_mask for the specified graphics context.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_change_gc_checked(xcb_connection_t*, xcb_gcontext_t, uint32_t, const uint32_t*)</code><br>
	 * @param c <<br>
	 * @param gc <<br>
	 * @param value_mask <<br>
	 * @param value_list <<br>
	 * <i>native declaration : xcb/xproto.h:6976</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_change_gc_checked(PointerByReference c, int gc, int value_mask, int value_list[]);
	/**
	 * @brief change graphics context components<br>
	 * @param c The connection<br>
	 * @param gc The graphics context to change.<br>
	 * @param value_mask A bitmask of #xcb_gc_t values.<br>
	 * @param value_mask \n<br>
	 * @param value_list Values for each of the components specified in the bitmask \a value_mask. The<br>
	 * order has to correspond to the order of possible \a value_mask bits. See the<br>
	 * example.<br>
	 * @return A cookie<br>
	 * Changes the components specified by \a value_mask for the specified graphics context.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_change_gc_checked(xcb_connection_t*, xcb_gcontext_t, uint32_t, const uint32_t*)</code><br>
	 * @param c <<br>
	 * @param gc <<br>
	 * @param value_mask <<br>
	 * @param value_list <<br>
	 * <i>native declaration : xcb/xproto.h:6976</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_change_gc_checked(PointerByReference c, int gc, int value_mask, IntByReference value_list);
	/**
	 * @brief change graphics context components<br>
	 * @param c The connection<br>
	 * @param gc The graphics context to change.<br>
	 * @param value_mask A bitmask of #xcb_gc_t values.<br>
	 * @param value_mask \n<br>
	 * @param value_list Values for each of the components specified in the bitmask \a value_mask. The<br>
	 * order has to correspond to the order of possible \a value_mask bits. See the<br>
	 * example.<br>
	 * @return A cookie<br>
	 * Changes the components specified by \a value_mask for the specified graphics context.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_change_gc(xcb_connection_t*, xcb_gcontext_t, uint32_t, const uint32_t*)</code><br>
	 * @param c <<br>
	 * @param gc <<br>
	 * @param value_mask <<br>
	 * @param value_list <<br>
	 * <i>native declaration : xcb/xproto.h:6994</i><br>
	 * @deprecated use the safer methods {@link #xcb_change_gc(com.sun.jna.ptr.PointerByReference, int, int, int[])} and {@link #xcb_change_gc(com.sun.jna.ptr.PointerByReference, int, int, com.sun.jna.ptr.IntByReference)} instead
	 */
	@Deprecated 
	xcb.xcb_void_cookie_t.ByValue xcb_change_gc(Pointer c, int gc, int value_mask, IntByReference value_list);
	/**
	 * @brief change graphics context components<br>
	 * @param c The connection<br>
	 * @param gc The graphics context to change.<br>
	 * @param value_mask A bitmask of #xcb_gc_t values.<br>
	 * @param value_mask \n<br>
	 * @param value_list Values for each of the components specified in the bitmask \a value_mask. The<br>
	 * order has to correspond to the order of possible \a value_mask bits. See the<br>
	 * example.<br>
	 * @return A cookie<br>
	 * Changes the components specified by \a value_mask for the specified graphics context.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_change_gc(xcb_connection_t*, xcb_gcontext_t, uint32_t, const uint32_t*)</code><br>
	 * @param c <<br>
	 * @param gc <<br>
	 * @param value_mask <<br>
	 * @param value_list <<br>
	 * <i>native declaration : xcb/xproto.h:6994</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_change_gc(PointerByReference c, int gc, int value_mask, int value_list[]);
	/**
	 * @brief change graphics context components<br>
	 * @param c The connection<br>
	 * @param gc The graphics context to change.<br>
	 * @param value_mask A bitmask of #xcb_gc_t values.<br>
	 * @param value_mask \n<br>
	 * @param value_list Values for each of the components specified in the bitmask \a value_mask. The<br>
	 * order has to correspond to the order of possible \a value_mask bits. See the<br>
	 * example.<br>
	 * @return A cookie<br>
	 * Changes the components specified by \a value_mask for the specified graphics context.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_change_gc(xcb_connection_t*, xcb_gcontext_t, uint32_t, const uint32_t*)</code><br>
	 * @param c <<br>
	 * @param gc <<br>
	 * @param value_mask <<br>
	 * @param value_list <<br>
	 * <i>native declaration : xcb/xproto.h:6994</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_change_gc(PointerByReference c, int gc, int value_mask, IntByReference value_list);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_copy_gc_checked(xcb_connection_t*, xcb_gcontext_t, xcb_gcontext_t, uint32_t)</code><br>
	 * @param c <<br>
	 * @param src_gc <<br>
	 * @param dst_gc <<br>
	 * @param value_mask <<br>
	 * <i>native declaration : xcb/xproto.h:7008</i><br>
	 * @deprecated use the safer method {@link #xcb_copy_gc_checked(com.sun.jna.ptr.PointerByReference, int, int, int)} instead
	 */
	@Deprecated 
	xcb.xcb_void_cookie_t.ByValue xcb_copy_gc_checked(Pointer c, int src_gc, int dst_gc, int value_mask);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_copy_gc_checked(xcb_connection_t*, xcb_gcontext_t, xcb_gcontext_t, uint32_t)</code><br>
	 * @param c <<br>
	 * @param src_gc <<br>
	 * @param dst_gc <<br>
	 * @param value_mask <<br>
	 * <i>native declaration : xcb/xproto.h:7008</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_copy_gc_checked(PointerByReference c, int src_gc, int dst_gc, int value_mask);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_copy_gc(xcb_connection_t*, xcb_gcontext_t, xcb_gcontext_t, uint32_t)</code><br>
	 * @param c <<br>
	 * @param src_gc <<br>
	 * @param dst_gc <<br>
	 * @param value_mask <<br>
	 * <i>native declaration : xcb/xproto.h:7019</i><br>
	 * @deprecated use the safer method {@link #xcb_copy_gc(com.sun.jna.ptr.PointerByReference, int, int, int)} instead
	 */
	@Deprecated 
	xcb.xcb_void_cookie_t.ByValue xcb_copy_gc(Pointer c, int src_gc, int dst_gc, int value_mask);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_copy_gc(xcb_connection_t*, xcb_gcontext_t, xcb_gcontext_t, uint32_t)</code><br>
	 * @param c <<br>
	 * @param src_gc <<br>
	 * @param dst_gc <<br>
	 * @param value_mask <<br>
	 * <i>native declaration : xcb/xproto.h:7019</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_copy_gc(PointerByReference c, int src_gc, int dst_gc, int value_mask);
	/**
	 * Original signature : <code>int xcb_set_dashes_sizeof(const void*)</code><br>
	 * @param _buffer <<br>
	 * <i>native declaration : xcb/xproto.h:7024</i>
	 */
	int xcb_set_dashes_sizeof(Pointer _buffer);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_set_dashes_checked(xcb_connection_t*, xcb_gcontext_t, uint16_t, uint16_t, const uint8_t*)</code><br>
	 * @param c <<br>
	 * @param gc <<br>
	 * @param dash_offset <<br>
	 * @param dashes_len <<br>
	 * @param dashes <<br>
	 * <i>native declaration : xcb/xproto.h:7039</i><br>
	 * @deprecated use the safer methods {@link #xcb_set_dashes_checked(com.sun.jna.ptr.PointerByReference, int, short, short, byte[])} and {@link #xcb_set_dashes_checked(com.sun.jna.ptr.PointerByReference, int, short, short, com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	xcb.xcb_void_cookie_t.ByValue xcb_set_dashes_checked(Pointer c, int gc, short dash_offset, short dashes_len, Pointer dashes);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_set_dashes_checked(xcb_connection_t*, xcb_gcontext_t, uint16_t, uint16_t, const uint8_t*)</code><br>
	 * @param c <<br>
	 * @param gc <<br>
	 * @param dash_offset <<br>
	 * @param dashes_len <<br>
	 * @param dashes <<br>
	 * <i>native declaration : xcb/xproto.h:7039</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_set_dashes_checked(PointerByReference c, int gc, short dash_offset, short dashes_len, byte dashes[]);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_set_dashes_checked(xcb_connection_t*, xcb_gcontext_t, uint16_t, uint16_t, const uint8_t*)</code><br>
	 * @param c <<br>
	 * @param gc <<br>
	 * @param dash_offset <<br>
	 * @param dashes_len <<br>
	 * @param dashes <<br>
	 * <i>native declaration : xcb/xproto.h:7039</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_set_dashes_checked(PointerByReference c, int gc, short dash_offset, short dashes_len, Pointer dashes);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_set_dashes(xcb_connection_t*, xcb_gcontext_t, uint16_t, uint16_t, const uint8_t*)</code><br>
	 * @param c <<br>
	 * @param gc <<br>
	 * @param dash_offset <<br>
	 * @param dashes_len <<br>
	 * @param dashes <<br>
	 * <i>native declaration : xcb/xproto.h:7051</i><br>
	 * @deprecated use the safer methods {@link #xcb_set_dashes(com.sun.jna.ptr.PointerByReference, int, short, short, byte[])} and {@link #xcb_set_dashes(com.sun.jna.ptr.PointerByReference, int, short, short, com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	xcb.xcb_void_cookie_t.ByValue xcb_set_dashes(Pointer c, int gc, short dash_offset, short dashes_len, Pointer dashes);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_set_dashes(xcb_connection_t*, xcb_gcontext_t, uint16_t, uint16_t, const uint8_t*)</code><br>
	 * @param c <<br>
	 * @param gc <<br>
	 * @param dash_offset <<br>
	 * @param dashes_len <<br>
	 * @param dashes <<br>
	 * <i>native declaration : xcb/xproto.h:7051</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_set_dashes(PointerByReference c, int gc, short dash_offset, short dashes_len, byte dashes[]);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_set_dashes(xcb_connection_t*, xcb_gcontext_t, uint16_t, uint16_t, const uint8_t*)</code><br>
	 * @param c <<br>
	 * @param gc <<br>
	 * @param dash_offset <<br>
	 * @param dashes_len <<br>
	 * @param dashes <<br>
	 * <i>native declaration : xcb/xproto.h:7051</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_set_dashes(PointerByReference c, int gc, short dash_offset, short dashes_len, Pointer dashes);
	/**
	 * Original signature : <code>int xcb_set_clip_rectangles_sizeof(const void*, uint32_t)</code><br>
	 * @param _buffer <<br>
	 * @param rectangles_len <<br>
	 * <i>native declaration : xcb/xproto.h:7057</i>
	 */
	int xcb_set_clip_rectangles_sizeof(Pointer _buffer, int rectangles_len);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_set_clip_rectangles_checked(xcb_connection_t*, uint8_t, xcb_gcontext_t, int16_t, int16_t, uint32_t, const xcb_rectangle_t*)</code><br>
	 * @param c <<br>
	 * @param ordering <<br>
	 * @param gc <<br>
	 * @param clip_x_origin <<br>
	 * @param clip_y_origin <<br>
	 * @param rectangles_len <<br>
	 * @param rectangles <<br>
	 * <i>native declaration : xcb/xproto.h:7074</i><br>
	 * @deprecated use the safer method {@link #xcb_set_clip_rectangles_checked(com.sun.jna.ptr.PointerByReference, byte, int, short, short, int, xcb.xcb_rectangle_t)} instead
	 */
	@Deprecated 
	xcb.xcb_void_cookie_t.ByValue xcb_set_clip_rectangles_checked(Pointer c, byte ordering, int gc, short clip_x_origin, short clip_y_origin, int rectangles_len, xcb_rectangle_t rectangles);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_set_clip_rectangles_checked(xcb_connection_t*, uint8_t, xcb_gcontext_t, int16_t, int16_t, uint32_t, const xcb_rectangle_t*)</code><br>
	 * @param c <<br>
	 * @param ordering <<br>
	 * @param gc <<br>
	 * @param clip_x_origin <<br>
	 * @param clip_y_origin <<br>
	 * @param rectangles_len <<br>
	 * @param rectangles <<br>
	 * <i>native declaration : xcb/xproto.h:7074</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_set_clip_rectangles_checked(PointerByReference c, byte ordering, int gc, short clip_x_origin, short clip_y_origin, int rectangles_len, xcb_rectangle_t rectangles);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_set_clip_rectangles(xcb_connection_t*, uint8_t, xcb_gcontext_t, int16_t, int16_t, uint32_t, const xcb_rectangle_t*)</code><br>
	 * @param c <<br>
	 * @param ordering <<br>
	 * @param gc <<br>
	 * @param clip_x_origin <<br>
	 * @param clip_y_origin <<br>
	 * @param rectangles_len <<br>
	 * @param rectangles <<br>
	 * <i>native declaration : xcb/xproto.h:7088</i><br>
	 * @deprecated use the safer method {@link #xcb_set_clip_rectangles(com.sun.jna.ptr.PointerByReference, byte, int, short, short, int, xcb.xcb_rectangle_t)} instead
	 */
	@Deprecated 
	xcb.xcb_void_cookie_t.ByValue xcb_set_clip_rectangles(Pointer c, byte ordering, int gc, short clip_x_origin, short clip_y_origin, int rectangles_len, xcb_rectangle_t rectangles);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_set_clip_rectangles(xcb_connection_t*, uint8_t, xcb_gcontext_t, int16_t, int16_t, uint32_t, const xcb_rectangle_t*)</code><br>
	 * @param c <<br>
	 * @param ordering <<br>
	 * @param gc <<br>
	 * @param clip_x_origin <<br>
	 * @param clip_y_origin <<br>
	 * @param rectangles_len <<br>
	 * @param rectangles <<br>
	 * <i>native declaration : xcb/xproto.h:7088</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_set_clip_rectangles(PointerByReference c, byte ordering, int gc, short clip_x_origin, short clip_y_origin, int rectangles_len, xcb_rectangle_t rectangles);
	/**
	 * @brief Destroys a graphics context<br>
	 * @param c The connection<br>
	 * @param gc The graphics context to destroy.<br>
	 * @return A cookie<br>
	 * Destroys the specified \a gc and all associated storage.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_free_gc_checked(xcb_connection_t*, xcb_gcontext_t)</code><br>
	 * @param c <<br>
	 * @param gc <<br>
	 * <i>native declaration : xcb/xproto.h:7102</i><br>
	 * @deprecated use the safer method {@link #xcb_free_gc_checked(com.sun.jna.ptr.PointerByReference, int)} instead
	 */
	@Deprecated 
	xcb.xcb_void_cookie_t.ByValue xcb_free_gc_checked(Pointer c, int gc);
	/**
	 * @brief Destroys a graphics context<br>
	 * @param c The connection<br>
	 * @param gc The graphics context to destroy.<br>
	 * @return A cookie<br>
	 * Destroys the specified \a gc and all associated storage.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_free_gc_checked(xcb_connection_t*, xcb_gcontext_t)</code><br>
	 * @param c <<br>
	 * @param gc <<br>
	 * <i>native declaration : xcb/xproto.h:7102</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_free_gc_checked(PointerByReference c, int gc);
	/**
	 * @brief Destroys a graphics context<br>
	 * @param c The connection<br>
	 * @param gc The graphics context to destroy.<br>
	 * @return A cookie<br>
	 * Destroys the specified \a gc and all associated storage.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_free_gc(xcb_connection_t*, xcb_gcontext_t)</code><br>
	 * @param c <<br>
	 * @param gc <<br>
	 * <i>native declaration : xcb/xproto.h:7113</i><br>
	 * @deprecated use the safer method {@link #xcb_free_gc(com.sun.jna.ptr.PointerByReference, int)} instead
	 */
	@Deprecated 
	xcb.xcb_void_cookie_t.ByValue xcb_free_gc(Pointer c, int gc);
	/**
	 * @brief Destroys a graphics context<br>
	 * @param c The connection<br>
	 * @param gc The graphics context to destroy.<br>
	 * @return A cookie<br>
	 * Destroys the specified \a gc and all associated storage.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_free_gc(xcb_connection_t*, xcb_gcontext_t)</code><br>
	 * @param c <<br>
	 * @param gc <<br>
	 * <i>native declaration : xcb/xproto.h:7113</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_free_gc(PointerByReference c, int gc);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_clear_area_checked(xcb_connection_t*, uint8_t, xcb_window_t, int16_t, int16_t, uint16_t, uint16_t)</code><br>
	 * @param c <<br>
	 * @param exposures <<br>
	 * @param window <<br>
	 * @param x <<br>
	 * @param y <<br>
	 * @param width <<br>
	 * @param height <<br>
	 * <i>native declaration : xcb/xproto.h:7130</i><br>
	 * @deprecated use the safer method {@link #xcb_clear_area_checked(com.sun.jna.ptr.PointerByReference, byte, int, short, short, short, short)} instead
	 */
	@Deprecated 
	xcb.xcb_void_cookie_t.ByValue xcb_clear_area_checked(Pointer c, byte exposures, int window, short x, short y, short width, short height);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_clear_area_checked(xcb_connection_t*, uint8_t, xcb_window_t, int16_t, int16_t, uint16_t, uint16_t)</code><br>
	 * @param c <<br>
	 * @param exposures <<br>
	 * @param window <<br>
	 * @param x <<br>
	 * @param y <<br>
	 * @param width <<br>
	 * @param height <<br>
	 * <i>native declaration : xcb/xproto.h:7130</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_clear_area_checked(PointerByReference c, byte exposures, int window, short x, short y, short width, short height);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_clear_area(xcb_connection_t*, uint8_t, xcb_window_t, int16_t, int16_t, uint16_t, uint16_t)</code><br>
	 * @param c <<br>
	 * @param exposures <<br>
	 * @param window <<br>
	 * @param x <<br>
	 * @param y <<br>
	 * @param width <<br>
	 * @param height <<br>
	 * <i>native declaration : xcb/xproto.h:7144</i><br>
	 * @deprecated use the safer method {@link #xcb_clear_area(com.sun.jna.ptr.PointerByReference, byte, int, short, short, short, short)} instead
	 */
	@Deprecated 
	xcb.xcb_void_cookie_t.ByValue xcb_clear_area(Pointer c, byte exposures, int window, short x, short y, short width, short height);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_clear_area(xcb_connection_t*, uint8_t, xcb_window_t, int16_t, int16_t, uint16_t, uint16_t)</code><br>
	 * @param c <<br>
	 * @param exposures <<br>
	 * @param window <<br>
	 * @param x <<br>
	 * @param y <<br>
	 * @param width <<br>
	 * @param height <<br>
	 * <i>native declaration : xcb/xproto.h:7144</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_clear_area(PointerByReference c, byte exposures, int window, short x, short y, short width, short height);
	/**
	 * @brief copy areas<br>
	 * @param c The connection<br>
	 * @param src_drawable The source drawable (Window or Pixmap).<br>
	 * @param dst_drawable The destination drawable (Window or Pixmap).<br>
	 * @param gc The graphics context to use.<br>
	 * @param src_x The source X coordinate.<br>
	 * @param src_y The source Y coordinate.<br>
	 * @param dst_x The destination X coordinate.<br>
	 * @param dst_y The destination Y coordinate.<br>
	 * @param width The width of the area to copy (in pixels).<br>
	 * @param height The height of the area to copy (in pixels).<br>
	 * @return A cookie<br>
	 * Copies the specified rectangle from \a src_drawable to \a dst_drawable.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_copy_area_checked(xcb_connection_t*, xcb_drawable_t, xcb_drawable_t, xcb_gcontext_t, int16_t, int16_t, int16_t, int16_t, uint16_t, uint16_t)</code><br>
	 * @param c <<br>
	 * @param src_drawable <<br>
	 * @param dst_drawable <<br>
	 * @param gc <<br>
	 * @param src_x <<br>
	 * @param src_y <<br>
	 * @param dst_x <<br>
	 * @param dst_y <<br>
	 * @param width <<br>
	 * @param height <<br>
	 * <i>native declaration : xcb/xproto.h:7174</i><br>
	 * @deprecated use the safer method {@link #xcb_copy_area_checked(com.sun.jna.ptr.PointerByReference, int, int, int, short, short, short, short, short, short)} instead
	 */
	@Deprecated 
	xcb.xcb_void_cookie_t.ByValue xcb_copy_area_checked(Pointer c, int src_drawable, int dst_drawable, int gc, short src_x, short src_y, short dst_x, short dst_y, short width, short height);
	/**
	 * @brief copy areas<br>
	 * @param c The connection<br>
	 * @param src_drawable The source drawable (Window or Pixmap).<br>
	 * @param dst_drawable The destination drawable (Window or Pixmap).<br>
	 * @param gc The graphics context to use.<br>
	 * @param src_x The source X coordinate.<br>
	 * @param src_y The source Y coordinate.<br>
	 * @param dst_x The destination X coordinate.<br>
	 * @param dst_y The destination Y coordinate.<br>
	 * @param width The width of the area to copy (in pixels).<br>
	 * @param height The height of the area to copy (in pixels).<br>
	 * @return A cookie<br>
	 * Copies the specified rectangle from \a src_drawable to \a dst_drawable.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_copy_area_checked(xcb_connection_t*, xcb_drawable_t, xcb_drawable_t, xcb_gcontext_t, int16_t, int16_t, int16_t, int16_t, uint16_t, uint16_t)</code><br>
	 * @param c <<br>
	 * @param src_drawable <<br>
	 * @param dst_drawable <<br>
	 * @param gc <<br>
	 * @param src_x <<br>
	 * @param src_y <<br>
	 * @param dst_x <<br>
	 * @param dst_y <<br>
	 * @param width <<br>
	 * @param height <<br>
	 * <i>native declaration : xcb/xproto.h:7174</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_copy_area_checked(PointerByReference c, int src_drawable, int dst_drawable, int gc, short src_x, short src_y, short dst_x, short dst_y, short width, short height);
	/**
	 * @brief copy areas<br>
	 * @param c The connection<br>
	 * @param src_drawable The source drawable (Window or Pixmap).<br>
	 * @param dst_drawable The destination drawable (Window or Pixmap).<br>
	 * @param gc The graphics context to use.<br>
	 * @param src_x The source X coordinate.<br>
	 * @param src_y The source Y coordinate.<br>
	 * @param dst_x The destination X coordinate.<br>
	 * @param dst_y The destination Y coordinate.<br>
	 * @param width The width of the area to copy (in pixels).<br>
	 * @param height The height of the area to copy (in pixels).<br>
	 * @return A cookie<br>
	 * Copies the specified rectangle from \a src_drawable to \a dst_drawable.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_copy_area(xcb_connection_t*, xcb_drawable_t, xcb_drawable_t, xcb_gcontext_t, int16_t, int16_t, int16_t, int16_t, uint16_t, uint16_t)</code><br>
	 * @param c <<br>
	 * @param src_drawable <<br>
	 * @param dst_drawable <<br>
	 * @param gc <<br>
	 * @param src_x <<br>
	 * @param src_y <<br>
	 * @param dst_x <<br>
	 * @param dst_y <<br>
	 * @param width <<br>
	 * @param height <<br>
	 * <i>native declaration : xcb/xproto.h:7201</i><br>
	 * @deprecated use the safer method {@link #xcb_copy_area(com.sun.jna.ptr.PointerByReference, int, int, int, short, short, short, short, short, short)} instead
	 */
	@Deprecated 
	xcb.xcb_void_cookie_t.ByValue xcb_copy_area(Pointer c, int src_drawable, int dst_drawable, int gc, short src_x, short src_y, short dst_x, short dst_y, short width, short height);
	/**
	 * @brief copy areas<br>
	 * @param c The connection<br>
	 * @param src_drawable The source drawable (Window or Pixmap).<br>
	 * @param dst_drawable The destination drawable (Window or Pixmap).<br>
	 * @param gc The graphics context to use.<br>
	 * @param src_x The source X coordinate.<br>
	 * @param src_y The source Y coordinate.<br>
	 * @param dst_x The destination X coordinate.<br>
	 * @param dst_y The destination Y coordinate.<br>
	 * @param width The width of the area to copy (in pixels).<br>
	 * @param height The height of the area to copy (in pixels).<br>
	 * @return A cookie<br>
	 * Copies the specified rectangle from \a src_drawable to \a dst_drawable.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_copy_area(xcb_connection_t*, xcb_drawable_t, xcb_drawable_t, xcb_gcontext_t, int16_t, int16_t, int16_t, int16_t, uint16_t, uint16_t)</code><br>
	 * @param c <<br>
	 * @param src_drawable <<br>
	 * @param dst_drawable <<br>
	 * @param gc <<br>
	 * @param src_x <<br>
	 * @param src_y <<br>
	 * @param dst_x <<br>
	 * @param dst_y <<br>
	 * @param width <<br>
	 * @param height <<br>
	 * <i>native declaration : xcb/xproto.h:7201</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_copy_area(PointerByReference c, int src_drawable, int dst_drawable, int gc, short src_x, short src_y, short dst_x, short dst_y, short width, short height);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_copy_plane_checked(xcb_connection_t*, xcb_drawable_t, xcb_drawable_t, xcb_gcontext_t, int16_t, int16_t, int16_t, int16_t, uint16_t, uint16_t, uint32_t)</code><br>
	 * @param c <<br>
	 * @param src_drawable <<br>
	 * @param dst_drawable <<br>
	 * @param gc <<br>
	 * @param src_x <<br>
	 * @param src_y <<br>
	 * @param dst_x <<br>
	 * @param dst_y <<br>
	 * @param width <<br>
	 * @param height <<br>
	 * @param bit_plane <<br>
	 * <i>native declaration : xcb/xproto.h:7222</i><br>
	 * @deprecated use the safer method {@link #xcb_copy_plane_checked(com.sun.jna.ptr.PointerByReference, int, int, int, short, short, short, short, short, short, int)} instead
	 */
	@Deprecated 
	xcb.xcb_void_cookie_t.ByValue xcb_copy_plane_checked(Pointer c, int src_drawable, int dst_drawable, int gc, short src_x, short src_y, short dst_x, short dst_y, short width, short height, int bit_plane);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_copy_plane_checked(xcb_connection_t*, xcb_drawable_t, xcb_drawable_t, xcb_gcontext_t, int16_t, int16_t, int16_t, int16_t, uint16_t, uint16_t, uint32_t)</code><br>
	 * @param c <<br>
	 * @param src_drawable <<br>
	 * @param dst_drawable <<br>
	 * @param gc <<br>
	 * @param src_x <<br>
	 * @param src_y <<br>
	 * @param dst_x <<br>
	 * @param dst_y <<br>
	 * @param width <<br>
	 * @param height <<br>
	 * @param bit_plane <<br>
	 * <i>native declaration : xcb/xproto.h:7222</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_copy_plane_checked(PointerByReference c, int src_drawable, int dst_drawable, int gc, short src_x, short src_y, short dst_x, short dst_y, short width, short height, int bit_plane);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_copy_plane(xcb_connection_t*, xcb_drawable_t, xcb_drawable_t, xcb_gcontext_t, int16_t, int16_t, int16_t, int16_t, uint16_t, uint16_t, uint32_t)</code><br>
	 * @param c <<br>
	 * @param src_drawable <<br>
	 * @param dst_drawable <<br>
	 * @param gc <<br>
	 * @param src_x <<br>
	 * @param src_y <<br>
	 * @param dst_x <<br>
	 * @param dst_y <<br>
	 * @param width <<br>
	 * @param height <<br>
	 * @param bit_plane <<br>
	 * <i>native declaration : xcb/xproto.h:7240</i><br>
	 * @deprecated use the safer method {@link #xcb_copy_plane(com.sun.jna.ptr.PointerByReference, int, int, int, short, short, short, short, short, short, int)} instead
	 */
	@Deprecated 
	xcb.xcb_void_cookie_t.ByValue xcb_copy_plane(Pointer c, int src_drawable, int dst_drawable, int gc, short src_x, short src_y, short dst_x, short dst_y, short width, short height, int bit_plane);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_copy_plane(xcb_connection_t*, xcb_drawable_t, xcb_drawable_t, xcb_gcontext_t, int16_t, int16_t, int16_t, int16_t, uint16_t, uint16_t, uint32_t)</code><br>
	 * @param c <<br>
	 * @param src_drawable <<br>
	 * @param dst_drawable <<br>
	 * @param gc <<br>
	 * @param src_x <<br>
	 * @param src_y <<br>
	 * @param dst_x <<br>
	 * @param dst_y <<br>
	 * @param width <<br>
	 * @param height <<br>
	 * @param bit_plane <<br>
	 * <i>native declaration : xcb/xproto.h:7240</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_copy_plane(PointerByReference c, int src_drawable, int dst_drawable, int gc, short src_x, short src_y, short dst_x, short dst_y, short width, short height, int bit_plane);
	/**
	 * Original signature : <code>int xcb_poly_point_sizeof(const void*, uint32_t)</code><br>
	 * @param _buffer <<br>
	 * @param points_len <<br>
	 * <i>native declaration : xcb/xproto.h:7246</i>
	 */
	int xcb_poly_point_sizeof(Pointer _buffer, int points_len);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_poly_point_checked(xcb_connection_t*, uint8_t, xcb_drawable_t, xcb_gcontext_t, uint32_t, const xcb_point_t*)</code><br>
	 * @param c <<br>
	 * @param coordinate_mode <<br>
	 * @param drawable <<br>
	 * @param gc <<br>
	 * @param points_len <<br>
	 * @param points <<br>
	 * <i>native declaration : xcb/xproto.h:7262</i><br>
	 * @deprecated use the safer method {@link #xcb_poly_point_checked(com.sun.jna.ptr.PointerByReference, byte, int, int, int, xcb.xcb_point_t)} instead
	 */
	@Deprecated 
	xcb.xcb_void_cookie_t.ByValue xcb_poly_point_checked(Pointer c, byte coordinate_mode, int drawable, int gc, int points_len, xcb_point_t points);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_poly_point_checked(xcb_connection_t*, uint8_t, xcb_drawable_t, xcb_gcontext_t, uint32_t, const xcb_point_t*)</code><br>
	 * @param c <<br>
	 * @param coordinate_mode <<br>
	 * @param drawable <<br>
	 * @param gc <<br>
	 * @param points_len <<br>
	 * @param points <<br>
	 * <i>native declaration : xcb/xproto.h:7262</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_poly_point_checked(PointerByReference c, byte coordinate_mode, int drawable, int gc, int points_len, xcb_point_t points);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_poly_point(xcb_connection_t*, uint8_t, xcb_drawable_t, xcb_gcontext_t, uint32_t, const xcb_point_t*)</code><br>
	 * @param c <<br>
	 * @param coordinate_mode <<br>
	 * @param drawable <<br>
	 * @param gc <<br>
	 * @param points_len <<br>
	 * @param points <<br>
	 * <i>native declaration : xcb/xproto.h:7275</i><br>
	 * @deprecated use the safer method {@link #xcb_poly_point(com.sun.jna.ptr.PointerByReference, byte, int, int, int, xcb.xcb_point_t)} instead
	 */
	@Deprecated 
	xcb.xcb_void_cookie_t.ByValue xcb_poly_point(Pointer c, byte coordinate_mode, int drawable, int gc, int points_len, xcb_point_t points);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_poly_point(xcb_connection_t*, uint8_t, xcb_drawable_t, xcb_gcontext_t, uint32_t, const xcb_point_t*)</code><br>
	 * @param c <<br>
	 * @param coordinate_mode <<br>
	 * @param drawable <<br>
	 * @param gc <<br>
	 * @param points_len <<br>
	 * @param points <<br>
	 * <i>native declaration : xcb/xproto.h:7275</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_poly_point(PointerByReference c, byte coordinate_mode, int drawable, int gc, int points_len, xcb_point_t points);
	/**
	 * Original signature : <code>int xcb_poly_line_sizeof(const void*, uint32_t)</code><br>
	 * @param _buffer <<br>
	 * @param points_len <<br>
	 * <i>native declaration : xcb/xproto.h:7281</i>
	 */
	int xcb_poly_line_sizeof(Pointer _buffer, int points_len);
	/**
	 * @brief draw lines<br>
	 * @param c The connection<br>
	 * @param coordinate_mode A bitmask of #xcb_coord_mode_t values.<br>
	 * @param coordinate_mode \n<br>
	 * @param drawable The drawable to draw the line(s) on.<br>
	 * @param gc The graphics context to use.<br>
	 * @param points_len The number of `xcb_point_t` structures in \a points.<br>
	 * @param points An array of points.<br>
	 * @return A cookie<br>
	 * Draws \a points_len-1 lines between each pair of points (point[i], point[i+1])<br>
	 * in the \a points array. The lines are drawn in the order listed in the array.<br>
	 * They join correctly at all intermediate points, and if the first and last<br>
	 * points coincide, the first and last lines also join correctly. For any given<br>
	 * line, a pixel is not drawn more than once. If thin (zero line-width) lines<br>
	 * intersect, the intersecting pixels are drawn multiple times. If wide lines<br>
	 * intersect, the intersecting pixels are drawn only once, as though the entire<br>
	 * request were a single, filled shape.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_poly_line_checked(xcb_connection_t*, uint8_t, xcb_drawable_t, xcb_gcontext_t, uint32_t, const xcb_point_t*)</code><br>
	 * @param c <<br>
	 * @param coordinate_mode <<br>
	 * @param drawable <<br>
	 * @param gc <<br>
	 * @param points_len <<br>
	 * @param points <<br>
	 * <i>native declaration : xcb/xproto.h:7311</i><br>
	 * @deprecated use the safer method {@link #xcb_poly_line_checked(com.sun.jna.ptr.PointerByReference, byte, int, int, int, xcb.xcb_point_t)} instead
	 */
	@Deprecated 
	xcb.xcb_void_cookie_t.ByValue xcb_poly_line_checked(Pointer c, byte coordinate_mode, int drawable, int gc, int points_len, xcb_point_t points);
	/**
	 * @brief draw lines<br>
	 * @param c The connection<br>
	 * @param coordinate_mode A bitmask of #xcb_coord_mode_t values.<br>
	 * @param coordinate_mode \n<br>
	 * @param drawable The drawable to draw the line(s) on.<br>
	 * @param gc The graphics context to use.<br>
	 * @param points_len The number of `xcb_point_t` structures in \a points.<br>
	 * @param points An array of points.<br>
	 * @return A cookie<br>
	 * Draws \a points_len-1 lines between each pair of points (point[i], point[i+1])<br>
	 * in the \a points array. The lines are drawn in the order listed in the array.<br>
	 * They join correctly at all intermediate points, and if the first and last<br>
	 * points coincide, the first and last lines also join correctly. For any given<br>
	 * line, a pixel is not drawn more than once. If thin (zero line-width) lines<br>
	 * intersect, the intersecting pixels are drawn multiple times. If wide lines<br>
	 * intersect, the intersecting pixels are drawn only once, as though the entire<br>
	 * request were a single, filled shape.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_poly_line_checked(xcb_connection_t*, uint8_t, xcb_drawable_t, xcb_gcontext_t, uint32_t, const xcb_point_t*)</code><br>
	 * @param c <<br>
	 * @param coordinate_mode <<br>
	 * @param drawable <<br>
	 * @param gc <<br>
	 * @param points_len <<br>
	 * @param points <<br>
	 * <i>native declaration : xcb/xproto.h:7311</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_poly_line_checked(PointerByReference c, byte coordinate_mode, int drawable, int gc, int points_len, xcb_point_t points);
	/**
	 * @brief draw lines<br>
	 * @param c The connection<br>
	 * @param coordinate_mode A bitmask of #xcb_coord_mode_t values.<br>
	 * @param coordinate_mode \n<br>
	 * @param drawable The drawable to draw the line(s) on.<br>
	 * @param gc The graphics context to use.<br>
	 * @param points_len The number of `xcb_point_t` structures in \a points.<br>
	 * @param points An array of points.<br>
	 * @return A cookie<br>
	 * Draws \a points_len-1 lines between each pair of points (point[i], point[i+1])<br>
	 * in the \a points array. The lines are drawn in the order listed in the array.<br>
	 * They join correctly at all intermediate points, and if the first and last<br>
	 * points coincide, the first and last lines also join correctly. For any given<br>
	 * line, a pixel is not drawn more than once. If thin (zero line-width) lines<br>
	 * intersect, the intersecting pixels are drawn multiple times. If wide lines<br>
	 * intersect, the intersecting pixels are drawn only once, as though the entire<br>
	 * request were a single, filled shape.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_poly_line(xcb_connection_t*, uint8_t, xcb_drawable_t, xcb_gcontext_t, uint32_t, const xcb_point_t*)</code><br>
	 * @param c <<br>
	 * @param coordinate_mode <<br>
	 * @param drawable <<br>
	 * @param gc <<br>
	 * @param points_len <<br>
	 * @param points <<br>
	 * <i>native declaration : xcb/xproto.h:7338</i><br>
	 * @deprecated use the safer method {@link #xcb_poly_line(com.sun.jna.ptr.PointerByReference, byte, int, int, int, xcb.xcb_point_t)} instead
	 */
	@Deprecated 
	xcb.xcb_void_cookie_t.ByValue xcb_poly_line(Pointer c, byte coordinate_mode, int drawable, int gc, int points_len, xcb_point_t points);
	/**
	 * @brief draw lines<br>
	 * @param c The connection<br>
	 * @param coordinate_mode A bitmask of #xcb_coord_mode_t values.<br>
	 * @param coordinate_mode \n<br>
	 * @param drawable The drawable to draw the line(s) on.<br>
	 * @param gc The graphics context to use.<br>
	 * @param points_len The number of `xcb_point_t` structures in \a points.<br>
	 * @param points An array of points.<br>
	 * @return A cookie<br>
	 * Draws \a points_len-1 lines between each pair of points (point[i], point[i+1])<br>
	 * in the \a points array. The lines are drawn in the order listed in the array.<br>
	 * They join correctly at all intermediate points, and if the first and last<br>
	 * points coincide, the first and last lines also join correctly. For any given<br>
	 * line, a pixel is not drawn more than once. If thin (zero line-width) lines<br>
	 * intersect, the intersecting pixels are drawn multiple times. If wide lines<br>
	 * intersect, the intersecting pixels are drawn only once, as though the entire<br>
	 * request were a single, filled shape.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_poly_line(xcb_connection_t*, uint8_t, xcb_drawable_t, xcb_gcontext_t, uint32_t, const xcb_point_t*)</code><br>
	 * @param c <<br>
	 * @param coordinate_mode <<br>
	 * @param drawable <<br>
	 * @param gc <<br>
	 * @param points_len <<br>
	 * @param points <<br>
	 * <i>native declaration : xcb/xproto.h:7338</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_poly_line(PointerByReference c, byte coordinate_mode, int drawable, int gc, int points_len, xcb_point_t points);
	/**
	 * Get the next element of the iterator<br>
	 * @param i Pointer to a xcb_segment_iterator_t<br>
	 * Get the next element in the iterator. The member rem is<br>
	 * decreased by one. The member data points to the next<br>
	 * element. The member index is increased by sizeof(xcb_segment_t)<br>
	 * Original signature : <code>void xcb_segment_next(xcb_segment_iterator_t*)</code><br>
	 * @param i <<br>
	 * <i>native declaration : xcb/xproto.h:7348</i>
	 */
	void xcb_segment_next(xcb_segment_iterator_t i);
	/**
	 * Return the iterator pointing to the last element<br>
	 * @param i An xcb_segment_iterator_t<br>
	 * @return  The iterator pointing to the last element<br>
	 * Set the current element in the iterator to the last element.<br>
	 * The member rem is set to 0. The member data points to the<br>
	 * last element.<br>
	 * Original signature : <code>xcb_generic_iterator_t xcb_segment_end(xcb_segment_iterator_t)</code><br>
	 * @param i <<br>
	 * <i>native declaration : xcb/xproto.h:7359</i>
	 */
	xcb.xcb_generic_iterator_t.ByValue xcb_segment_end(xcb_segment_iterator_t.ByValue i);
	/**
	 * Original signature : <code>int xcb_poly_segment_sizeof(const void*, uint32_t)</code><br>
	 * @param _buffer <<br>
	 * @param segments_len <<br>
	 * <i>native declaration : xcb/xproto.h:7365</i>
	 */
	int xcb_poly_segment_sizeof(Pointer _buffer, int segments_len);
	/**
	 * @brief draw lines<br>
	 * @param c The connection<br>
	 * @param drawable A drawable (Window or Pixmap) to draw on.<br>
	 * @param gc The graphics context to use.<br>
	 * \n<br>
	 * TODO: document which attributes of a gc are used<br>
	 * @param segments_len The number of `xcb_segment_t` structures in \a segments.<br>
	 * @param segments An array of `xcb_segment_t` structures.<br>
	 * @return A cookie<br>
	 * Draws multiple, unconnected lines. For each segment, a line is drawn between<br>
	 * (x1, y1) and (x2, y2). The lines are drawn in the order listed in the array of<br>
	 * `xcb_segment_t` structures and does not perform joining at coincident<br>
	 * endpoints. For any given line, a pixel is not drawn more than once. If lines<br>
	 * intersect, the intersecting pixels are drawn multiple times.<br>
	 * <br>
	 * TODO: include the xcb_segment_t data structure<br>
	 * <br>
	 * TODO: an example<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_poly_segment_checked(xcb_connection_t*, xcb_drawable_t, xcb_gcontext_t, uint32_t, const xcb_segment_t*)</code><br>
	 * @param c <<br>
	 * @param drawable <<br>
	 * @param gc <<br>
	 * @param segments_len <<br>
	 * @param segments <<br>
	 * <i>native declaration : xcb/xproto.h:7395</i><br>
	 * @deprecated use the safer method {@link #xcb_poly_segment_checked(com.sun.jna.ptr.PointerByReference, int, int, int, xcb.xcb_segment_t)} instead
	 */
	@Deprecated 
	xcb.xcb_void_cookie_t.ByValue xcb_poly_segment_checked(Pointer c, int drawable, int gc, int segments_len, xcb_segment_t segments);
	/**
	 * @brief draw lines<br>
	 * @param c The connection<br>
	 * @param drawable A drawable (Window or Pixmap) to draw on.<br>
	 * @param gc The graphics context to use.<br>
	 * \n<br>
	 * TODO: document which attributes of a gc are used<br>
	 * @param segments_len The number of `xcb_segment_t` structures in \a segments.<br>
	 * @param segments An array of `xcb_segment_t` structures.<br>
	 * @return A cookie<br>
	 * Draws multiple, unconnected lines. For each segment, a line is drawn between<br>
	 * (x1, y1) and (x2, y2). The lines are drawn in the order listed in the array of<br>
	 * `xcb_segment_t` structures and does not perform joining at coincident<br>
	 * endpoints. For any given line, a pixel is not drawn more than once. If lines<br>
	 * intersect, the intersecting pixels are drawn multiple times.<br>
	 * <br>
	 * TODO: include the xcb_segment_t data structure<br>
	 * <br>
	 * TODO: an example<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_poly_segment_checked(xcb_connection_t*, xcb_drawable_t, xcb_gcontext_t, uint32_t, const xcb_segment_t*)</code><br>
	 * @param c <<br>
	 * @param drawable <<br>
	 * @param gc <<br>
	 * @param segments_len <<br>
	 * @param segments <<br>
	 * <i>native declaration : xcb/xproto.h:7395</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_poly_segment_checked(PointerByReference c, int drawable, int gc, int segments_len, xcb_segment_t segments);
	/**
	 * @brief draw lines<br>
	 * @param c The connection<br>
	 * @param drawable A drawable (Window or Pixmap) to draw on.<br>
	 * @param gc The graphics context to use.<br>
	 * \n<br>
	 * TODO: document which attributes of a gc are used<br>
	 * @param segments_len The number of `xcb_segment_t` structures in \a segments.<br>
	 * @param segments An array of `xcb_segment_t` structures.<br>
	 * @return A cookie<br>
	 * Draws multiple, unconnected lines. For each segment, a line is drawn between<br>
	 * (x1, y1) and (x2, y2). The lines are drawn in the order listed in the array of<br>
	 * `xcb_segment_t` structures and does not perform joining at coincident<br>
	 * endpoints. For any given line, a pixel is not drawn more than once. If lines<br>
	 * intersect, the intersecting pixels are drawn multiple times.<br>
	 * <br>
	 * TODO: include the xcb_segment_t data structure<br>
	 * <br>
	 * TODO: an example<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_poly_segment(xcb_connection_t*, xcb_drawable_t, xcb_gcontext_t, uint32_t, const xcb_segment_t*)</code><br>
	 * @param c <<br>
	 * @param drawable <<br>
	 * @param gc <<br>
	 * @param segments_len <<br>
	 * @param segments <<br>
	 * <i>native declaration : xcb/xproto.h:7422</i><br>
	 * @deprecated use the safer method {@link #xcb_poly_segment(com.sun.jna.ptr.PointerByReference, int, int, int, xcb.xcb_segment_t)} instead
	 */
	@Deprecated 
	xcb.xcb_void_cookie_t.ByValue xcb_poly_segment(Pointer c, int drawable, int gc, int segments_len, xcb_segment_t segments);
	/**
	 * @brief draw lines<br>
	 * @param c The connection<br>
	 * @param drawable A drawable (Window or Pixmap) to draw on.<br>
	 * @param gc The graphics context to use.<br>
	 * \n<br>
	 * TODO: document which attributes of a gc are used<br>
	 * @param segments_len The number of `xcb_segment_t` structures in \a segments.<br>
	 * @param segments An array of `xcb_segment_t` structures.<br>
	 * @return A cookie<br>
	 * Draws multiple, unconnected lines. For each segment, a line is drawn between<br>
	 * (x1, y1) and (x2, y2). The lines are drawn in the order listed in the array of<br>
	 * `xcb_segment_t` structures and does not perform joining at coincident<br>
	 * endpoints. For any given line, a pixel is not drawn more than once. If lines<br>
	 * intersect, the intersecting pixels are drawn multiple times.<br>
	 * <br>
	 * TODO: include the xcb_segment_t data structure<br>
	 * <br>
	 * TODO: an example<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_poly_segment(xcb_connection_t*, xcb_drawable_t, xcb_gcontext_t, uint32_t, const xcb_segment_t*)</code><br>
	 * @param c <<br>
	 * @param drawable <<br>
	 * @param gc <<br>
	 * @param segments_len <<br>
	 * @param segments <<br>
	 * <i>native declaration : xcb/xproto.h:7422</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_poly_segment(PointerByReference c, int drawable, int gc, int segments_len, xcb_segment_t segments);
	/**
	 * Original signature : <code>int xcb_poly_rectangle_sizeof(const void*, uint32_t)</code><br>
	 * @param _buffer <<br>
	 * @param rectangles_len <<br>
	 * <i>native declaration : xcb/xproto.h:7428</i>
	 */
	int xcb_poly_rectangle_sizeof(Pointer _buffer, int rectangles_len);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_poly_rectangle_checked(xcb_connection_t*, xcb_drawable_t, xcb_gcontext_t, uint32_t, const xcb_rectangle_t*)</code><br>
	 * @param c <<br>
	 * @param drawable <<br>
	 * @param gc <<br>
	 * @param rectangles_len <<br>
	 * @param rectangles <<br>
	 * <i>native declaration : xcb/xproto.h:7443</i><br>
	 * @deprecated use the safer method {@link #xcb_poly_rectangle_checked(com.sun.jna.ptr.PointerByReference, int, int, int, xcb.xcb_rectangle_t)} instead
	 */
	@Deprecated 
	xcb.xcb_void_cookie_t.ByValue xcb_poly_rectangle_checked(Pointer c, int drawable, int gc, int rectangles_len, xcb_rectangle_t rectangles);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_poly_rectangle_checked(xcb_connection_t*, xcb_drawable_t, xcb_gcontext_t, uint32_t, const xcb_rectangle_t*)</code><br>
	 * @param c <<br>
	 * @param drawable <<br>
	 * @param gc <<br>
	 * @param rectangles_len <<br>
	 * @param rectangles <<br>
	 * <i>native declaration : xcb/xproto.h:7443</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_poly_rectangle_checked(PointerByReference c, int drawable, int gc, int rectangles_len, xcb_rectangle_t rectangles);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_poly_rectangle(xcb_connection_t*, xcb_drawable_t, xcb_gcontext_t, uint32_t, const xcb_rectangle_t*)</code><br>
	 * @param c <<br>
	 * @param drawable <<br>
	 * @param gc <<br>
	 * @param rectangles_len <<br>
	 * @param rectangles <<br>
	 * <i>native declaration : xcb/xproto.h:7455</i><br>
	 * @deprecated use the safer method {@link #xcb_poly_rectangle(com.sun.jna.ptr.PointerByReference, int, int, int, xcb.xcb_rectangle_t)} instead
	 */
	@Deprecated 
	xcb.xcb_void_cookie_t.ByValue xcb_poly_rectangle(Pointer c, int drawable, int gc, int rectangles_len, xcb_rectangle_t rectangles);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_poly_rectangle(xcb_connection_t*, xcb_drawable_t, xcb_gcontext_t, uint32_t, const xcb_rectangle_t*)</code><br>
	 * @param c <<br>
	 * @param drawable <<br>
	 * @param gc <<br>
	 * @param rectangles_len <<br>
	 * @param rectangles <<br>
	 * <i>native declaration : xcb/xproto.h:7455</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_poly_rectangle(PointerByReference c, int drawable, int gc, int rectangles_len, xcb_rectangle_t rectangles);
	/**
	 * Original signature : <code>int xcb_poly_arc_sizeof(const void*, uint32_t)</code><br>
	 * @param _buffer <<br>
	 * @param arcs_len <<br>
	 * <i>native declaration : xcb/xproto.h:7461</i>
	 */
	int xcb_poly_arc_sizeof(Pointer _buffer, int arcs_len);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_poly_arc_checked(xcb_connection_t*, xcb_drawable_t, xcb_gcontext_t, uint32_t, const xcb_arc_t*)</code><br>
	 * @param c <<br>
	 * @param drawable <<br>
	 * @param gc <<br>
	 * @param arcs_len <<br>
	 * @param arcs <<br>
	 * <i>native declaration : xcb/xproto.h:7476</i><br>
	 * @deprecated use the safer method {@link #xcb_poly_arc_checked(com.sun.jna.ptr.PointerByReference, int, int, int, xcb.xcb_arc_t)} instead
	 */
	@Deprecated 
	xcb.xcb_void_cookie_t.ByValue xcb_poly_arc_checked(Pointer c, int drawable, int gc, int arcs_len, xcb_arc_t arcs);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_poly_arc_checked(xcb_connection_t*, xcb_drawable_t, xcb_gcontext_t, uint32_t, const xcb_arc_t*)</code><br>
	 * @param c <<br>
	 * @param drawable <<br>
	 * @param gc <<br>
	 * @param arcs_len <<br>
	 * @param arcs <<br>
	 * <i>native declaration : xcb/xproto.h:7476</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_poly_arc_checked(PointerByReference c, int drawable, int gc, int arcs_len, xcb_arc_t arcs);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_poly_arc(xcb_connection_t*, xcb_drawable_t, xcb_gcontext_t, uint32_t, const xcb_arc_t*)</code><br>
	 * @param c <<br>
	 * @param drawable <<br>
	 * @param gc <<br>
	 * @param arcs_len <<br>
	 * @param arcs <<br>
	 * <i>native declaration : xcb/xproto.h:7488</i><br>
	 * @deprecated use the safer method {@link #xcb_poly_arc(com.sun.jna.ptr.PointerByReference, int, int, int, xcb.xcb_arc_t)} instead
	 */
	@Deprecated 
	xcb.xcb_void_cookie_t.ByValue xcb_poly_arc(Pointer c, int drawable, int gc, int arcs_len, xcb_arc_t arcs);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_poly_arc(xcb_connection_t*, xcb_drawable_t, xcb_gcontext_t, uint32_t, const xcb_arc_t*)</code><br>
	 * @param c <<br>
	 * @param drawable <<br>
	 * @param gc <<br>
	 * @param arcs_len <<br>
	 * @param arcs <<br>
	 * <i>native declaration : xcb/xproto.h:7488</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_poly_arc(PointerByReference c, int drawable, int gc, int arcs_len, xcb_arc_t arcs);
	/**
	 * Original signature : <code>int xcb_fill_poly_sizeof(const void*, uint32_t)</code><br>
	 * @param _buffer <<br>
	 * @param points_len <<br>
	 * <i>native declaration : xcb/xproto.h:7494</i>
	 */
	int xcb_fill_poly_sizeof(Pointer _buffer, int points_len);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_fill_poly_checked(xcb_connection_t*, xcb_drawable_t, xcb_gcontext_t, uint8_t, uint8_t, uint32_t, const xcb_point_t*)</code><br>
	 * @param c <<br>
	 * @param drawable <<br>
	 * @param gc <<br>
	 * @param shape <<br>
	 * @param coordinate_mode <<br>
	 * @param points_len <<br>
	 * @param points <<br>
	 * <i>native declaration : xcb/xproto.h:7511</i><br>
	 * @deprecated use the safer method {@link #xcb_fill_poly_checked(com.sun.jna.ptr.PointerByReference, int, int, byte, byte, int, xcb.xcb_point_t)} instead
	 */
	@Deprecated 
	xcb.xcb_void_cookie_t.ByValue xcb_fill_poly_checked(Pointer c, int drawable, int gc, byte shape, byte coordinate_mode, int points_len, xcb_point_t points);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_fill_poly_checked(xcb_connection_t*, xcb_drawable_t, xcb_gcontext_t, uint8_t, uint8_t, uint32_t, const xcb_point_t*)</code><br>
	 * @param c <<br>
	 * @param drawable <<br>
	 * @param gc <<br>
	 * @param shape <<br>
	 * @param coordinate_mode <<br>
	 * @param points_len <<br>
	 * @param points <<br>
	 * <i>native declaration : xcb/xproto.h:7511</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_fill_poly_checked(PointerByReference c, int drawable, int gc, byte shape, byte coordinate_mode, int points_len, xcb_point_t points);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_fill_poly(xcb_connection_t*, xcb_drawable_t, xcb_gcontext_t, uint8_t, uint8_t, uint32_t, const xcb_point_t*)</code><br>
	 * @param c <<br>
	 * @param drawable <<br>
	 * @param gc <<br>
	 * @param shape <<br>
	 * @param coordinate_mode <<br>
	 * @param points_len <<br>
	 * @param points <<br>
	 * <i>native declaration : xcb/xproto.h:7525</i><br>
	 * @deprecated use the safer method {@link #xcb_fill_poly(com.sun.jna.ptr.PointerByReference, int, int, byte, byte, int, xcb.xcb_point_t)} instead
	 */
	@Deprecated 
	xcb.xcb_void_cookie_t.ByValue xcb_fill_poly(Pointer c, int drawable, int gc, byte shape, byte coordinate_mode, int points_len, xcb_point_t points);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_fill_poly(xcb_connection_t*, xcb_drawable_t, xcb_gcontext_t, uint8_t, uint8_t, uint32_t, const xcb_point_t*)</code><br>
	 * @param c <<br>
	 * @param drawable <<br>
	 * @param gc <<br>
	 * @param shape <<br>
	 * @param coordinate_mode <<br>
	 * @param points_len <<br>
	 * @param points <<br>
	 * <i>native declaration : xcb/xproto.h:7525</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_fill_poly(PointerByReference c, int drawable, int gc, byte shape, byte coordinate_mode, int points_len, xcb_point_t points);
	/**
	 * Original signature : <code>int xcb_poly_fill_rectangle_sizeof(const void*, uint32_t)</code><br>
	 * @param _buffer <<br>
	 * @param rectangles_len <<br>
	 * <i>native declaration : xcb/xproto.h:7531</i>
	 */
	int xcb_poly_fill_rectangle_sizeof(Pointer _buffer, int rectangles_len);
	/**
	 * @brief Fills rectangles<br>
	 * @param c The connection<br>
	 * @param drawable The drawable (Window or Pixmap) to draw on.<br>
	 * @param gc The graphics context to use.<br>
	 * \n<br>
	 * The following graphics context components are used: function, plane-mask,<br>
	 * fill-style, subwindow-mode, clip-x-origin, clip-y-origin, and clip-mask.<br>
	 * \n<br>
	 * The following graphics context mode-dependent components are used:<br>
	 * foreground, background, tile, stipple, tile-stipple-x-origin, and<br>
	 * tile-stipple-y-origin.<br>
	 * @param rectangles_len The number of `xcb_rectangle_t` structures in \a rectangles.<br>
	 * @param rectangles The rectangles to fill.<br>
	 * @return A cookie<br>
	 * Fills the specified rectangle(s) in the order listed in the array. For any<br>
	 * given rectangle, each pixel is not drawn more than once. If rectangles<br>
	 * intersect, the intersecting pixels are drawn multiple times.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_poly_fill_rectangle_checked(xcb_connection_t*, xcb_drawable_t, xcb_gcontext_t, uint32_t, const xcb_rectangle_t*)</code><br>
	 * @param c <<br>
	 * @param drawable <<br>
	 * @param gc <<br>
	 * @param rectangles_len <<br>
	 * @param rectangles <<br>
	 * <i>native declaration : xcb/xproto.h:7560</i><br>
	 * @deprecated use the safer method {@link #xcb_poly_fill_rectangle_checked(com.sun.jna.ptr.PointerByReference, int, int, int, xcb.xcb_rectangle_t)} instead
	 */
	@Deprecated 
	xcb.xcb_void_cookie_t.ByValue xcb_poly_fill_rectangle_checked(Pointer c, int drawable, int gc, int rectangles_len, xcb_rectangle_t rectangles);
	/**
	 * @brief Fills rectangles<br>
	 * @param c The connection<br>
	 * @param drawable The drawable (Window or Pixmap) to draw on.<br>
	 * @param gc The graphics context to use.<br>
	 * \n<br>
	 * The following graphics context components are used: function, plane-mask,<br>
	 * fill-style, subwindow-mode, clip-x-origin, clip-y-origin, and clip-mask.<br>
	 * \n<br>
	 * The following graphics context mode-dependent components are used:<br>
	 * foreground, background, tile, stipple, tile-stipple-x-origin, and<br>
	 * tile-stipple-y-origin.<br>
	 * @param rectangles_len The number of `xcb_rectangle_t` structures in \a rectangles.<br>
	 * @param rectangles The rectangles to fill.<br>
	 * @return A cookie<br>
	 * Fills the specified rectangle(s) in the order listed in the array. For any<br>
	 * given rectangle, each pixel is not drawn more than once. If rectangles<br>
	 * intersect, the intersecting pixels are drawn multiple times.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_poly_fill_rectangle_checked(xcb_connection_t*, xcb_drawable_t, xcb_gcontext_t, uint32_t, const xcb_rectangle_t*)</code><br>
	 * @param c <<br>
	 * @param drawable <<br>
	 * @param gc <<br>
	 * @param rectangles_len <<br>
	 * @param rectangles <<br>
	 * <i>native declaration : xcb/xproto.h:7560</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_poly_fill_rectangle_checked(PointerByReference c, int drawable, int gc, int rectangles_len, xcb_rectangle_t rectangles);
	/**
	 * @brief Fills rectangles<br>
	 * @param c The connection<br>
	 * @param drawable The drawable (Window or Pixmap) to draw on.<br>
	 * @param gc The graphics context to use.<br>
	 * \n<br>
	 * The following graphics context components are used: function, plane-mask,<br>
	 * fill-style, subwindow-mode, clip-x-origin, clip-y-origin, and clip-mask.<br>
	 * \n<br>
	 * The following graphics context mode-dependent components are used:<br>
	 * foreground, background, tile, stipple, tile-stipple-x-origin, and<br>
	 * tile-stipple-y-origin.<br>
	 * @param rectangles_len The number of `xcb_rectangle_t` structures in \a rectangles.<br>
	 * @param rectangles The rectangles to fill.<br>
	 * @return A cookie<br>
	 * Fills the specified rectangle(s) in the order listed in the array. For any<br>
	 * given rectangle, each pixel is not drawn more than once. If rectangles<br>
	 * intersect, the intersecting pixels are drawn multiple times.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_poly_fill_rectangle(xcb_connection_t*, xcb_drawable_t, xcb_gcontext_t, uint32_t, const xcb_rectangle_t*)</code><br>
	 * @param c <<br>
	 * @param drawable <<br>
	 * @param gc <<br>
	 * @param rectangles_len <<br>
	 * @param rectangles <<br>
	 * <i>native declaration : xcb/xproto.h:7586</i><br>
	 * @deprecated use the safer method {@link #xcb_poly_fill_rectangle(com.sun.jna.ptr.PointerByReference, int, int, int, xcb.xcb_rectangle_t)} instead
	 */
	@Deprecated 
	xcb.xcb_void_cookie_t.ByValue xcb_poly_fill_rectangle(Pointer c, int drawable, int gc, int rectangles_len, xcb_rectangle_t rectangles);
	/**
	 * @brief Fills rectangles<br>
	 * @param c The connection<br>
	 * @param drawable The drawable (Window or Pixmap) to draw on.<br>
	 * @param gc The graphics context to use.<br>
	 * \n<br>
	 * The following graphics context components are used: function, plane-mask,<br>
	 * fill-style, subwindow-mode, clip-x-origin, clip-y-origin, and clip-mask.<br>
	 * \n<br>
	 * The following graphics context mode-dependent components are used:<br>
	 * foreground, background, tile, stipple, tile-stipple-x-origin, and<br>
	 * tile-stipple-y-origin.<br>
	 * @param rectangles_len The number of `xcb_rectangle_t` structures in \a rectangles.<br>
	 * @param rectangles The rectangles to fill.<br>
	 * @return A cookie<br>
	 * Fills the specified rectangle(s) in the order listed in the array. For any<br>
	 * given rectangle, each pixel is not drawn more than once. If rectangles<br>
	 * intersect, the intersecting pixels are drawn multiple times.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_poly_fill_rectangle(xcb_connection_t*, xcb_drawable_t, xcb_gcontext_t, uint32_t, const xcb_rectangle_t*)</code><br>
	 * @param c <<br>
	 * @param drawable <<br>
	 * @param gc <<br>
	 * @param rectangles_len <<br>
	 * @param rectangles <<br>
	 * <i>native declaration : xcb/xproto.h:7586</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_poly_fill_rectangle(PointerByReference c, int drawable, int gc, int rectangles_len, xcb_rectangle_t rectangles);
	/**
	 * Original signature : <code>int xcb_poly_fill_arc_sizeof(const void*, uint32_t)</code><br>
	 * @param _buffer <<br>
	 * @param arcs_len <<br>
	 * <i>native declaration : xcb/xproto.h:7592</i>
	 */
	int xcb_poly_fill_arc_sizeof(Pointer _buffer, int arcs_len);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_poly_fill_arc_checked(xcb_connection_t*, xcb_drawable_t, xcb_gcontext_t, uint32_t, const xcb_arc_t*)</code><br>
	 * @param c <<br>
	 * @param drawable <<br>
	 * @param gc <<br>
	 * @param arcs_len <<br>
	 * @param arcs <<br>
	 * <i>native declaration : xcb/xproto.h:7607</i><br>
	 * @deprecated use the safer method {@link #xcb_poly_fill_arc_checked(com.sun.jna.ptr.PointerByReference, int, int, int, xcb.xcb_arc_t)} instead
	 */
	@Deprecated 
	xcb.xcb_void_cookie_t.ByValue xcb_poly_fill_arc_checked(Pointer c, int drawable, int gc, int arcs_len, xcb_arc_t arcs);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_poly_fill_arc_checked(xcb_connection_t*, xcb_drawable_t, xcb_gcontext_t, uint32_t, const xcb_arc_t*)</code><br>
	 * @param c <<br>
	 * @param drawable <<br>
	 * @param gc <<br>
	 * @param arcs_len <<br>
	 * @param arcs <<br>
	 * <i>native declaration : xcb/xproto.h:7607</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_poly_fill_arc_checked(PointerByReference c, int drawable, int gc, int arcs_len, xcb_arc_t arcs);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_poly_fill_arc(xcb_connection_t*, xcb_drawable_t, xcb_gcontext_t, uint32_t, const xcb_arc_t*)</code><br>
	 * @param c <<br>
	 * @param drawable <<br>
	 * @param gc <<br>
	 * @param arcs_len <<br>
	 * @param arcs <<br>
	 * <i>native declaration : xcb/xproto.h:7619</i><br>
	 * @deprecated use the safer method {@link #xcb_poly_fill_arc(com.sun.jna.ptr.PointerByReference, int, int, int, xcb.xcb_arc_t)} instead
	 */
	@Deprecated 
	xcb.xcb_void_cookie_t.ByValue xcb_poly_fill_arc(Pointer c, int drawable, int gc, int arcs_len, xcb_arc_t arcs);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_poly_fill_arc(xcb_connection_t*, xcb_drawable_t, xcb_gcontext_t, uint32_t, const xcb_arc_t*)</code><br>
	 * @param c <<br>
	 * @param drawable <<br>
	 * @param gc <<br>
	 * @param arcs_len <<br>
	 * @param arcs <<br>
	 * <i>native declaration : xcb/xproto.h:7619</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_poly_fill_arc(PointerByReference c, int drawable, int gc, int arcs_len, xcb_arc_t arcs);
	/**
	 * Original signature : <code>int xcb_put_image_sizeof(const void*, uint32_t)</code><br>
	 * @param _buffer <<br>
	 * @param data_len <<br>
	 * <i>native declaration : xcb/xproto.h:7625</i>
	 */
	int xcb_put_image_sizeof(Pointer _buffer, int data_len);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_put_image_checked(xcb_connection_t*, uint8_t, xcb_drawable_t, xcb_gcontext_t, uint16_t, uint16_t, int16_t, int16_t, uint8_t, uint8_t, uint32_t, const uint8_t*)</code><br>
	 * @param c <<br>
	 * @param format <<br>
	 * @param drawable <<br>
	 * @param gc <<br>
	 * @param width <<br>
	 * @param height <<br>
	 * @param dst_x <<br>
	 * @param dst_y <<br>
	 * @param left_pad <<br>
	 * @param depth <<br>
	 * @param data_len <<br>
	 * @param data <<br>
	 * <i>native declaration : xcb/xproto.h:7647</i><br>
	 * @deprecated use the safer methods {@link #xcb_put_image_checked(com.sun.jna.ptr.PointerByReference, byte, int, int, short, short, short, short, byte, byte, int, byte[])} and {@link #xcb_put_image_checked(com.sun.jna.ptr.PointerByReference, byte, int, int, short, short, short, short, byte, byte, int, com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	xcb.xcb_void_cookie_t.ByValue xcb_put_image_checked(Pointer c, byte format, int drawable, int gc, short width, short height, short dst_x, short dst_y, byte left_pad, byte depth, int data_len, Pointer data);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_put_image_checked(xcb_connection_t*, uint8_t, xcb_drawable_t, xcb_gcontext_t, uint16_t, uint16_t, int16_t, int16_t, uint8_t, uint8_t, uint32_t, const uint8_t*)</code><br>
	 * @param c <<br>
	 * @param format <<br>
	 * @param drawable <<br>
	 * @param gc <<br>
	 * @param width <<br>
	 * @param height <<br>
	 * @param dst_x <<br>
	 * @param dst_y <<br>
	 * @param left_pad <<br>
	 * @param depth <<br>
	 * @param data_len <<br>
	 * @param data <<br>
	 * <i>native declaration : xcb/xproto.h:7647</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_put_image_checked(PointerByReference c, byte format, int drawable, int gc, short width, short height, short dst_x, short dst_y, byte left_pad, byte depth, int data_len, byte data[]);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_put_image_checked(xcb_connection_t*, uint8_t, xcb_drawable_t, xcb_gcontext_t, uint16_t, uint16_t, int16_t, int16_t, uint8_t, uint8_t, uint32_t, const uint8_t*)</code><br>
	 * @param c <<br>
	 * @param format <<br>
	 * @param drawable <<br>
	 * @param gc <<br>
	 * @param width <<br>
	 * @param height <<br>
	 * @param dst_x <<br>
	 * @param dst_y <<br>
	 * @param left_pad <<br>
	 * @param depth <<br>
	 * @param data_len <<br>
	 * @param data <<br>
	 * <i>native declaration : xcb/xproto.h:7647</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_put_image_checked(PointerByReference c, byte format, int drawable, int gc, short width, short height, short dst_x, short dst_y, byte left_pad, byte depth, int data_len, Pointer data);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_put_image(xcb_connection_t*, uint8_t, xcb_drawable_t, xcb_gcontext_t, uint16_t, uint16_t, int16_t, int16_t, uint8_t, uint8_t, uint32_t, const uint8_t*)</code><br>
	 * @param c <<br>
	 * @param format <<br>
	 * @param drawable <<br>
	 * @param gc <<br>
	 * @param width <<br>
	 * @param height <<br>
	 * @param dst_x <<br>
	 * @param dst_y <<br>
	 * @param left_pad <<br>
	 * @param depth <<br>
	 * @param data_len <<br>
	 * @param data <<br>
	 * <i>native declaration : xcb/xproto.h:7666</i><br>
	 * @deprecated use the safer methods {@link #xcb_put_image(com.sun.jna.ptr.PointerByReference, byte, int, int, short, short, short, short, byte, byte, int, byte[])} and {@link #xcb_put_image(com.sun.jna.ptr.PointerByReference, byte, int, int, short, short, short, short, byte, byte, int, com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	xcb.xcb_void_cookie_t.ByValue xcb_put_image(Pointer c, byte format, int drawable, int gc, short width, short height, short dst_x, short dst_y, byte left_pad, byte depth, int data_len, Pointer data);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_put_image(xcb_connection_t*, uint8_t, xcb_drawable_t, xcb_gcontext_t, uint16_t, uint16_t, int16_t, int16_t, uint8_t, uint8_t, uint32_t, const uint8_t*)</code><br>
	 * @param c <<br>
	 * @param format <<br>
	 * @param drawable <<br>
	 * @param gc <<br>
	 * @param width <<br>
	 * @param height <<br>
	 * @param dst_x <<br>
	 * @param dst_y <<br>
	 * @param left_pad <<br>
	 * @param depth <<br>
	 * @param data_len <<br>
	 * @param data <<br>
	 * <i>native declaration : xcb/xproto.h:7666</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_put_image(PointerByReference c, byte format, int drawable, int gc, short width, short height, short dst_x, short dst_y, byte left_pad, byte depth, int data_len, byte data[]);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_put_image(xcb_connection_t*, uint8_t, xcb_drawable_t, xcb_gcontext_t, uint16_t, uint16_t, int16_t, int16_t, uint8_t, uint8_t, uint32_t, const uint8_t*)</code><br>
	 * @param c <<br>
	 * @param format <<br>
	 * @param drawable <<br>
	 * @param gc <<br>
	 * @param width <<br>
	 * @param height <<br>
	 * @param dst_x <<br>
	 * @param dst_y <<br>
	 * @param left_pad <<br>
	 * @param depth <<br>
	 * @param data_len <<br>
	 * @param data <<br>
	 * <i>native declaration : xcb/xproto.h:7666</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_put_image(PointerByReference c, byte format, int drawable, int gc, short width, short height, short dst_x, short dst_y, byte left_pad, byte depth, int data_len, Pointer data);
	/**
	 * Original signature : <code>int xcb_get_image_sizeof(const void*)</code><br>
	 * @param _buffer <<br>
	 * <i>native declaration : xcb/xproto.h:7671</i>
	 */
	int xcb_get_image_sizeof(Pointer _buffer);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_get_image_cookie_t xcb_get_image(xcb_connection_t*, uint8_t, xcb_drawable_t, int16_t, int16_t, uint16_t, uint16_t, uint32_t)</code><br>
	 * @param c <<br>
	 * @param format <<br>
	 * @param drawable <<br>
	 * @param x <<br>
	 * @param y <<br>
	 * @param width <<br>
	 * @param height <<br>
	 * @param plane_mask <<br>
	 * <i>native declaration : xcb/xproto.h:7686</i><br>
	 * @deprecated use the safer method {@link #xcb_get_image(com.sun.jna.ptr.PointerByReference, byte, int, short, short, short, short, int)} instead
	 */
	@Deprecated 
	xcb.xcb_get_image_cookie_t.ByValue xcb_get_image(Pointer c, byte format, int drawable, short x, short y, short width, short height, int plane_mask);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_get_image_cookie_t xcb_get_image(xcb_connection_t*, uint8_t, xcb_drawable_t, int16_t, int16_t, uint16_t, uint16_t, uint32_t)</code><br>
	 * @param c <<br>
	 * @param format <<br>
	 * @param drawable <<br>
	 * @param x <<br>
	 * @param y <<br>
	 * @param width <<br>
	 * @param height <<br>
	 * @param plane_mask <<br>
	 * <i>native declaration : xcb/xproto.h:7686</i>
	 */
	xcb.xcb_get_image_cookie_t.ByValue xcb_get_image(PointerByReference c, byte format, int drawable, short x, short y, short width, short height, int plane_mask);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * placed in the event queue.<br>
	 * Original signature : <code>xcb_get_image_cookie_t xcb_get_image_unchecked(xcb_connection_t*, uint8_t, xcb_drawable_t, int16_t, int16_t, uint16_t, uint16_t, uint32_t)</code><br>
	 * @param c <<br>
	 * @param format <<br>
	 * @param drawable <<br>
	 * @param x <<br>
	 * @param y <<br>
	 * @param width <<br>
	 * @param height <<br>
	 * @param plane_mask <<br>
	 * <i>native declaration : xcb/xproto.h:7704</i><br>
	 * @deprecated use the safer method {@link #xcb_get_image_unchecked(com.sun.jna.ptr.PointerByReference, byte, int, short, short, short, short, int)} instead
	 */
	@Deprecated 
	xcb.xcb_get_image_cookie_t.ByValue xcb_get_image_unchecked(Pointer c, byte format, int drawable, short x, short y, short width, short height, int plane_mask);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * placed in the event queue.<br>
	 * Original signature : <code>xcb_get_image_cookie_t xcb_get_image_unchecked(xcb_connection_t*, uint8_t, xcb_drawable_t, int16_t, int16_t, uint16_t, uint16_t, uint32_t)</code><br>
	 * @param c <<br>
	 * @param format <<br>
	 * @param drawable <<br>
	 * @param x <<br>
	 * @param y <<br>
	 * @param width <<br>
	 * @param height <<br>
	 * @param plane_mask <<br>
	 * <i>native declaration : xcb/xproto.h:7704</i>
	 */
	xcb.xcb_get_image_cookie_t.ByValue xcb_get_image_unchecked(PointerByReference c, byte format, int drawable, short x, short y, short width, short height, int plane_mask);
	/**
	 * Original signature : <code>uint8_t* xcb_get_image_data(const xcb_get_image_reply_t*)</code><br>
	 * @param R <<br>
	 * <i>native declaration : xcb/xproto.h:7709</i>
	 */
	Pointer xcb_get_image_data(xcb_get_image_reply_t R);
	/**
	 * Original signature : <code>int xcb_get_image_data_length(const xcb_get_image_reply_t*)</code><br>
	 * @param R <<br>
	 * <i>native declaration : xcb/xproto.h:7714</i>
	 */
	int xcb_get_image_data_length(xcb_get_image_reply_t R);
	/**
	 * Original signature : <code>xcb_generic_iterator_t xcb_get_image_data_end(const xcb_get_image_reply_t*)</code><br>
	 * @param R <<br>
	 * <i>native declaration : xcb/xproto.h:7719</i>
	 */
	xcb.xcb_generic_iterator_t.ByValue xcb_get_image_data_end(xcb_get_image_reply_t R);
	/**
	 * Return the reply<br>
	 * @param c      The connection<br>
	 * @param cookie The cookie<br>
	 * @param e      The xcb_generic_error_t supplied<br>
	 * Returns the reply of the request asked by<br>
	 * The parameter @p e supplied to this function must be NULL if<br>
	 * xcb_get_image_unchecked(). is used.<br>
	 * Otherwise, it stores the error if any.<br>
	 * The returned value must be freed by the caller using free().<br>
	 * Original signature : <code>xcb_get_image_reply_t* xcb_get_image_reply(xcb_connection_t*, xcb_get_image_cookie_t, xcb_generic_error_t**)</code><br>
	 * @param c <<br>
	 * @param cookie <<br>
	 * @param e <<br>
	 * <i>native declaration : xcb/xproto.h:7735</i><br>
	 * @deprecated use the safer method {@link #xcb_get_image_reply(com.sun.jna.ptr.PointerByReference, xcb.xcb_get_image_cookie_t.ByValue, xcb.xcb_generic_error_t.ByReference[])} instead
	 */
	@Deprecated 
	xcb_get_image_reply_t xcb_get_image_reply(Pointer c, xcb.xcb_get_image_cookie_t.ByValue cookie, PointerByReference e);
	/**
	 * Return the reply<br>
	 * @param c      The connection<br>
	 * @param cookie The cookie<br>
	 * @param e      The xcb_generic_error_t supplied<br>
	 * Returns the reply of the request asked by<br>
	 * The parameter @p e supplied to this function must be NULL if<br>
	 * xcb_get_image_unchecked(). is used.<br>
	 * Otherwise, it stores the error if any.<br>
	 * The returned value must be freed by the caller using free().<br>
	 * Original signature : <code>xcb_get_image_reply_t* xcb_get_image_reply(xcb_connection_t*, xcb_get_image_cookie_t, xcb_generic_error_t**)</code><br>
	 * @param c <<br>
	 * @param cookie <<br>
	 * @param e <<br>
	 * <i>native declaration : xcb/xproto.h:7735</i>
	 */
	xcb_get_image_reply_t xcb_get_image_reply(PointerByReference c, xcb.xcb_get_image_cookie_t.ByValue cookie, xcb_generic_error_t.ByReference e[]);
	/**
	 * Original signature : <code>int xcb_poly_text_8_sizeof(const void*, uint32_t)</code><br>
	 * @param _buffer <<br>
	 * @param items_len <<br>
	 * <i>native declaration : xcb/xproto.h:7741</i>
	 */
	int xcb_poly_text_8_sizeof(Pointer _buffer, int items_len);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_poly_text_8_checked(xcb_connection_t*, xcb_drawable_t, xcb_gcontext_t, int16_t, int16_t, uint32_t, const uint8_t*)</code><br>
	 * @param c <<br>
	 * @param drawable <<br>
	 * @param gc <<br>
	 * @param x <<br>
	 * @param y <<br>
	 * @param items_len <<br>
	 * @param items <<br>
	 * <i>native declaration : xcb/xproto.h:7758</i><br>
	 * @deprecated use the safer methods {@link #xcb_poly_text_8_checked(com.sun.jna.ptr.PointerByReference, int, int, short, short, int, byte[])} and {@link #xcb_poly_text_8_checked(com.sun.jna.ptr.PointerByReference, int, int, short, short, int, com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	xcb.xcb_void_cookie_t.ByValue xcb_poly_text_8_checked(Pointer c, int drawable, int gc, short x, short y, int items_len, Pointer items);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_poly_text_8_checked(xcb_connection_t*, xcb_drawable_t, xcb_gcontext_t, int16_t, int16_t, uint32_t, const uint8_t*)</code><br>
	 * @param c <<br>
	 * @param drawable <<br>
	 * @param gc <<br>
	 * @param x <<br>
	 * @param y <<br>
	 * @param items_len <<br>
	 * @param items <<br>
	 * <i>native declaration : xcb/xproto.h:7758</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_poly_text_8_checked(PointerByReference c, int drawable, int gc, short x, short y, int items_len, byte items[]);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_poly_text_8_checked(xcb_connection_t*, xcb_drawable_t, xcb_gcontext_t, int16_t, int16_t, uint32_t, const uint8_t*)</code><br>
	 * @param c <<br>
	 * @param drawable <<br>
	 * @param gc <<br>
	 * @param x <<br>
	 * @param y <<br>
	 * @param items_len <<br>
	 * @param items <<br>
	 * <i>native declaration : xcb/xproto.h:7758</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_poly_text_8_checked(PointerByReference c, int drawable, int gc, short x, short y, int items_len, Pointer items);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_poly_text_8(xcb_connection_t*, xcb_drawable_t, xcb_gcontext_t, int16_t, int16_t, uint32_t, const uint8_t*)</code><br>
	 * @param c <<br>
	 * @param drawable <<br>
	 * @param gc <<br>
	 * @param x <<br>
	 * @param y <<br>
	 * @param items_len <<br>
	 * @param items <<br>
	 * <i>native declaration : xcb/xproto.h:7772</i><br>
	 * @deprecated use the safer methods {@link #xcb_poly_text_8(com.sun.jna.ptr.PointerByReference, int, int, short, short, int, byte[])} and {@link #xcb_poly_text_8(com.sun.jna.ptr.PointerByReference, int, int, short, short, int, com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	xcb.xcb_void_cookie_t.ByValue xcb_poly_text_8(Pointer c, int drawable, int gc, short x, short y, int items_len, Pointer items);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_poly_text_8(xcb_connection_t*, xcb_drawable_t, xcb_gcontext_t, int16_t, int16_t, uint32_t, const uint8_t*)</code><br>
	 * @param c <<br>
	 * @param drawable <<br>
	 * @param gc <<br>
	 * @param x <<br>
	 * @param y <<br>
	 * @param items_len <<br>
	 * @param items <<br>
	 * <i>native declaration : xcb/xproto.h:7772</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_poly_text_8(PointerByReference c, int drawable, int gc, short x, short y, int items_len, byte items[]);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_poly_text_8(xcb_connection_t*, xcb_drawable_t, xcb_gcontext_t, int16_t, int16_t, uint32_t, const uint8_t*)</code><br>
	 * @param c <<br>
	 * @param drawable <<br>
	 * @param gc <<br>
	 * @param x <<br>
	 * @param y <<br>
	 * @param items_len <<br>
	 * @param items <<br>
	 * <i>native declaration : xcb/xproto.h:7772</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_poly_text_8(PointerByReference c, int drawable, int gc, short x, short y, int items_len, Pointer items);
	/**
	 * Original signature : <code>int xcb_poly_text_16_sizeof(const void*, uint32_t)</code><br>
	 * @param _buffer <<br>
	 * @param items_len <<br>
	 * <i>native declaration : xcb/xproto.h:7778</i>
	 */
	int xcb_poly_text_16_sizeof(Pointer _buffer, int items_len);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_poly_text_16_checked(xcb_connection_t*, xcb_drawable_t, xcb_gcontext_t, int16_t, int16_t, uint32_t, const uint8_t*)</code><br>
	 * @param c <<br>
	 * @param drawable <<br>
	 * @param gc <<br>
	 * @param x <<br>
	 * @param y <<br>
	 * @param items_len <<br>
	 * @param items <<br>
	 * <i>native declaration : xcb/xproto.h:7795</i><br>
	 * @deprecated use the safer methods {@link #xcb_poly_text_16_checked(com.sun.jna.ptr.PointerByReference, int, int, short, short, int, byte[])} and {@link #xcb_poly_text_16_checked(com.sun.jna.ptr.PointerByReference, int, int, short, short, int, com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	xcb.xcb_void_cookie_t.ByValue xcb_poly_text_16_checked(Pointer c, int drawable, int gc, short x, short y, int items_len, Pointer items);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_poly_text_16_checked(xcb_connection_t*, xcb_drawable_t, xcb_gcontext_t, int16_t, int16_t, uint32_t, const uint8_t*)</code><br>
	 * @param c <<br>
	 * @param drawable <<br>
	 * @param gc <<br>
	 * @param x <<br>
	 * @param y <<br>
	 * @param items_len <<br>
	 * @param items <<br>
	 * <i>native declaration : xcb/xproto.h:7795</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_poly_text_16_checked(PointerByReference c, int drawable, int gc, short x, short y, int items_len, byte items[]);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_poly_text_16_checked(xcb_connection_t*, xcb_drawable_t, xcb_gcontext_t, int16_t, int16_t, uint32_t, const uint8_t*)</code><br>
	 * @param c <<br>
	 * @param drawable <<br>
	 * @param gc <<br>
	 * @param x <<br>
	 * @param y <<br>
	 * @param items_len <<br>
	 * @param items <<br>
	 * <i>native declaration : xcb/xproto.h:7795</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_poly_text_16_checked(PointerByReference c, int drawable, int gc, short x, short y, int items_len, Pointer items);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_poly_text_16(xcb_connection_t*, xcb_drawable_t, xcb_gcontext_t, int16_t, int16_t, uint32_t, const uint8_t*)</code><br>
	 * @param c <<br>
	 * @param drawable <<br>
	 * @param gc <<br>
	 * @param x <<br>
	 * @param y <<br>
	 * @param items_len <<br>
	 * @param items <<br>
	 * <i>native declaration : xcb/xproto.h:7809</i><br>
	 * @deprecated use the safer methods {@link #xcb_poly_text_16(com.sun.jna.ptr.PointerByReference, int, int, short, short, int, byte[])} and {@link #xcb_poly_text_16(com.sun.jna.ptr.PointerByReference, int, int, short, short, int, com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	xcb.xcb_void_cookie_t.ByValue xcb_poly_text_16(Pointer c, int drawable, int gc, short x, short y, int items_len, Pointer items);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_poly_text_16(xcb_connection_t*, xcb_drawable_t, xcb_gcontext_t, int16_t, int16_t, uint32_t, const uint8_t*)</code><br>
	 * @param c <<br>
	 * @param drawable <<br>
	 * @param gc <<br>
	 * @param x <<br>
	 * @param y <<br>
	 * @param items_len <<br>
	 * @param items <<br>
	 * <i>native declaration : xcb/xproto.h:7809</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_poly_text_16(PointerByReference c, int drawable, int gc, short x, short y, int items_len, byte items[]);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_poly_text_16(xcb_connection_t*, xcb_drawable_t, xcb_gcontext_t, int16_t, int16_t, uint32_t, const uint8_t*)</code><br>
	 * @param c <<br>
	 * @param drawable <<br>
	 * @param gc <<br>
	 * @param x <<br>
	 * @param y <<br>
	 * @param items_len <<br>
	 * @param items <<br>
	 * <i>native declaration : xcb/xproto.h:7809</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_poly_text_16(PointerByReference c, int drawable, int gc, short x, short y, int items_len, Pointer items);
	/**
	 * Original signature : <code>int xcb_image_text_8_sizeof(const void*)</code><br>
	 * @param _buffer <<br>
	 * <i>native declaration : xcb/xproto.h:7814</i>
	 */
	int xcb_image_text_8_sizeof(Pointer _buffer);
	/**
	 * @brief Draws text<br>
	 * @param c The connection<br>
	 * @param string_len The length of the \a string. Note that this parameter limited by 255 due to<br>
	 * using 8 bits!<br>
	 * @param drawable The drawable (Window or Pixmap) to draw text on.<br>
	 * @param gc The graphics context to use.<br>
	 * \n<br>
	 * The following graphics context components are used: plane-mask, foreground,<br>
	 * background, font, subwindow-mode, clip-x-origin, clip-y-origin, and clip-mask.<br>
	 * @param x The x coordinate of the first character, relative to the origin of \a drawable.<br>
	 * @param y The y coordinate of the first character, relative to the origin of \a drawable.<br>
	 * @param string The string to draw. Only the first 255 characters are relevant due to the data<br>
	 * type of \a string_len.<br>
	 * @return A cookie<br>
	 * Fills the destination rectangle with the background pixel from \a gc, then<br>
	 * paints the text with the foreground pixel from \a gc. The upper-left corner of<br>
	 * the filled rectangle is at [x, y - font-ascent]. The width is overall-width,<br>
	 * the height is font-ascent + font-descent. The overall-width, font-ascent and<br>
	 * font-descent are as returned by `xcb_query_text_extents` (TODO).<br>
	 * <br>
	 * Note that using X core fonts is deprecated (but still supported) in favor of<br>
	 * client-side rendering using Xft.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_image_text_8_checked(xcb_connection_t*, uint8_t, xcb_drawable_t, xcb_gcontext_t, int16_t, int16_t, const char*)</code><br>
	 * @param c <<br>
	 * @param string_len <<br>
	 * @param drawable <<br>
	 * @param gc <<br>
	 * @param x <<br>
	 * @param y <<br>
	 * @param string <<br>
	 * <i>native declaration : xcb/xproto.h:7850</i><br>
	 * @deprecated use the safer methods {@link #xcb_image_text_8_checked(com.sun.jna.ptr.PointerByReference, byte, int, int, short, short, java.lang.String)} and {@link #xcb_image_text_8_checked(com.sun.jna.ptr.PointerByReference, byte, int, int, short, short, com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	xcb.xcb_void_cookie_t.ByValue xcb_image_text_8_checked(Pointer c, byte string_len, int drawable, int gc, short x, short y, Pointer string);
	/**
	 * @brief Draws text<br>
	 * @param c The connection<br>
	 * @param string_len The length of the \a string. Note that this parameter limited by 255 due to<br>
	 * using 8 bits!<br>
	 * @param drawable The drawable (Window or Pixmap) to draw text on.<br>
	 * @param gc The graphics context to use.<br>
	 * \n<br>
	 * The following graphics context components are used: plane-mask, foreground,<br>
	 * background, font, subwindow-mode, clip-x-origin, clip-y-origin, and clip-mask.<br>
	 * @param x The x coordinate of the first character, relative to the origin of \a drawable.<br>
	 * @param y The y coordinate of the first character, relative to the origin of \a drawable.<br>
	 * @param string The string to draw. Only the first 255 characters are relevant due to the data<br>
	 * type of \a string_len.<br>
	 * @return A cookie<br>
	 * Fills the destination rectangle with the background pixel from \a gc, then<br>
	 * paints the text with the foreground pixel from \a gc. The upper-left corner of<br>
	 * the filled rectangle is at [x, y - font-ascent]. The width is overall-width,<br>
	 * the height is font-ascent + font-descent. The overall-width, font-ascent and<br>
	 * font-descent are as returned by `xcb_query_text_extents` (TODO).<br>
	 * <br>
	 * Note that using X core fonts is deprecated (but still supported) in favor of<br>
	 * client-side rendering using Xft.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_image_text_8_checked(xcb_connection_t*, uint8_t, xcb_drawable_t, xcb_gcontext_t, int16_t, int16_t, const char*)</code><br>
	 * @param c <<br>
	 * @param string_len <<br>
	 * @param drawable <<br>
	 * @param gc <<br>
	 * @param x <<br>
	 * @param y <<br>
	 * @param string <<br>
	 * <i>native declaration : xcb/xproto.h:7850</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_image_text_8_checked(PointerByReference c, byte string_len, int drawable, int gc, short x, short y, String string);
	/**
	 * @brief Draws text<br>
	 * @param c The connection<br>
	 * @param string_len The length of the \a string. Note that this parameter limited by 255 due to<br>
	 * using 8 bits!<br>
	 * @param drawable The drawable (Window or Pixmap) to draw text on.<br>
	 * @param gc The graphics context to use.<br>
	 * \n<br>
	 * The following graphics context components are used: plane-mask, foreground,<br>
	 * background, font, subwindow-mode, clip-x-origin, clip-y-origin, and clip-mask.<br>
	 * @param x The x coordinate of the first character, relative to the origin of \a drawable.<br>
	 * @param y The y coordinate of the first character, relative to the origin of \a drawable.<br>
	 * @param string The string to draw. Only the first 255 characters are relevant due to the data<br>
	 * type of \a string_len.<br>
	 * @return A cookie<br>
	 * Fills the destination rectangle with the background pixel from \a gc, then<br>
	 * paints the text with the foreground pixel from \a gc. The upper-left corner of<br>
	 * the filled rectangle is at [x, y - font-ascent]. The width is overall-width,<br>
	 * the height is font-ascent + font-descent. The overall-width, font-ascent and<br>
	 * font-descent are as returned by `xcb_query_text_extents` (TODO).<br>
	 * <br>
	 * Note that using X core fonts is deprecated (but still supported) in favor of<br>
	 * client-side rendering using Xft.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_image_text_8_checked(xcb_connection_t*, uint8_t, xcb_drawable_t, xcb_gcontext_t, int16_t, int16_t, const char*)</code><br>
	 * @param c <<br>
	 * @param string_len <<br>
	 * @param drawable <<br>
	 * @param gc <<br>
	 * @param x <<br>
	 * @param y <<br>
	 * @param string <<br>
	 * <i>native declaration : xcb/xproto.h:7850</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_image_text_8_checked(PointerByReference c, byte string_len, int drawable, int gc, short x, short y, Pointer string);
	/**
	 * @brief Draws text<br>
	 * @param c The connection<br>
	 * @param string_len The length of the \a string. Note that this parameter limited by 255 due to<br>
	 * using 8 bits!<br>
	 * @param drawable The drawable (Window or Pixmap) to draw text on.<br>
	 * @param gc The graphics context to use.<br>
	 * \n<br>
	 * The following graphics context components are used: plane-mask, foreground,<br>
	 * background, font, subwindow-mode, clip-x-origin, clip-y-origin, and clip-mask.<br>
	 * @param x The x coordinate of the first character, relative to the origin of \a drawable.<br>
	 * @param y The y coordinate of the first character, relative to the origin of \a drawable.<br>
	 * @param string The string to draw. Only the first 255 characters are relevant due to the data<br>
	 * type of \a string_len.<br>
	 * @return A cookie<br>
	 * Fills the destination rectangle with the background pixel from \a gc, then<br>
	 * paints the text with the foreground pixel from \a gc. The upper-left corner of<br>
	 * the filled rectangle is at [x, y - font-ascent]. The width is overall-width,<br>
	 * the height is font-ascent + font-descent. The overall-width, font-ascent and<br>
	 * font-descent are as returned by `xcb_query_text_extents` (TODO).<br>
	 * <br>
	 * Note that using X core fonts is deprecated (but still supported) in favor of<br>
	 * client-side rendering using Xft.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_image_text_8(xcb_connection_t*, uint8_t, xcb_drawable_t, xcb_gcontext_t, int16_t, int16_t, const char*)</code><br>
	 * @param c <<br>
	 * @param string_len <<br>
	 * @param drawable <<br>
	 * @param gc <<br>
	 * @param x <<br>
	 * @param y <<br>
	 * @param string <<br>
	 * <i>native declaration : xcb/xproto.h:7883</i><br>
	 * @deprecated use the safer methods {@link #xcb_image_text_8(com.sun.jna.ptr.PointerByReference, byte, int, int, short, short, java.lang.String)} and {@link #xcb_image_text_8(com.sun.jna.ptr.PointerByReference, byte, int, int, short, short, com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	xcb.xcb_void_cookie_t.ByValue xcb_image_text_8(Pointer c, byte string_len, int drawable, int gc, short x, short y, Pointer string);
	/**
	 * @brief Draws text<br>
	 * @param c The connection<br>
	 * @param string_len The length of the \a string. Note that this parameter limited by 255 due to<br>
	 * using 8 bits!<br>
	 * @param drawable The drawable (Window or Pixmap) to draw text on.<br>
	 * @param gc The graphics context to use.<br>
	 * \n<br>
	 * The following graphics context components are used: plane-mask, foreground,<br>
	 * background, font, subwindow-mode, clip-x-origin, clip-y-origin, and clip-mask.<br>
	 * @param x The x coordinate of the first character, relative to the origin of \a drawable.<br>
	 * @param y The y coordinate of the first character, relative to the origin of \a drawable.<br>
	 * @param string The string to draw. Only the first 255 characters are relevant due to the data<br>
	 * type of \a string_len.<br>
	 * @return A cookie<br>
	 * Fills the destination rectangle with the background pixel from \a gc, then<br>
	 * paints the text with the foreground pixel from \a gc. The upper-left corner of<br>
	 * the filled rectangle is at [x, y - font-ascent]. The width is overall-width,<br>
	 * the height is font-ascent + font-descent. The overall-width, font-ascent and<br>
	 * font-descent are as returned by `xcb_query_text_extents` (TODO).<br>
	 * <br>
	 * Note that using X core fonts is deprecated (but still supported) in favor of<br>
	 * client-side rendering using Xft.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_image_text_8(xcb_connection_t*, uint8_t, xcb_drawable_t, xcb_gcontext_t, int16_t, int16_t, const char*)</code><br>
	 * @param c <<br>
	 * @param string_len <<br>
	 * @param drawable <<br>
	 * @param gc <<br>
	 * @param x <<br>
	 * @param y <<br>
	 * @param string <<br>
	 * <i>native declaration : xcb/xproto.h:7883</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_image_text_8(PointerByReference c, byte string_len, int drawable, int gc, short x, short y, String string);
	/**
	 * @brief Draws text<br>
	 * @param c The connection<br>
	 * @param string_len The length of the \a string. Note that this parameter limited by 255 due to<br>
	 * using 8 bits!<br>
	 * @param drawable The drawable (Window or Pixmap) to draw text on.<br>
	 * @param gc The graphics context to use.<br>
	 * \n<br>
	 * The following graphics context components are used: plane-mask, foreground,<br>
	 * background, font, subwindow-mode, clip-x-origin, clip-y-origin, and clip-mask.<br>
	 * @param x The x coordinate of the first character, relative to the origin of \a drawable.<br>
	 * @param y The y coordinate of the first character, relative to the origin of \a drawable.<br>
	 * @param string The string to draw. Only the first 255 characters are relevant due to the data<br>
	 * type of \a string_len.<br>
	 * @return A cookie<br>
	 * Fills the destination rectangle with the background pixel from \a gc, then<br>
	 * paints the text with the foreground pixel from \a gc. The upper-left corner of<br>
	 * the filled rectangle is at [x, y - font-ascent]. The width is overall-width,<br>
	 * the height is font-ascent + font-descent. The overall-width, font-ascent and<br>
	 * font-descent are as returned by `xcb_query_text_extents` (TODO).<br>
	 * <br>
	 * Note that using X core fonts is deprecated (but still supported) in favor of<br>
	 * client-side rendering using Xft.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_image_text_8(xcb_connection_t*, uint8_t, xcb_drawable_t, xcb_gcontext_t, int16_t, int16_t, const char*)</code><br>
	 * @param c <<br>
	 * @param string_len <<br>
	 * @param drawable <<br>
	 * @param gc <<br>
	 * @param x <<br>
	 * @param y <<br>
	 * @param string <<br>
	 * <i>native declaration : xcb/xproto.h:7883</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_image_text_8(PointerByReference c, byte string_len, int drawable, int gc, short x, short y, Pointer string);
	/**
	 * Original signature : <code>int xcb_image_text_16_sizeof(const void*)</code><br>
	 * @param _buffer <<br>
	 * <i>native declaration : xcb/xproto.h:7888</i>
	 */
	int xcb_image_text_16_sizeof(Pointer _buffer);
	/**
	 * @brief Draws text<br>
	 * @param c The connection<br>
	 * @param string_len The length of the \a string in characters. Note that this parameter limited by<br>
	 * 255 due to using 8 bits!<br>
	 * @param drawable The drawable (Window or Pixmap) to draw text on.<br>
	 * @param gc The graphics context to use.<br>
	 * \n<br>
	 * The following graphics context components are used: plane-mask, foreground,<br>
	 * background, font, subwindow-mode, clip-x-origin, clip-y-origin, and clip-mask.<br>
	 * @param x The x coordinate of the first character, relative to the origin of \a drawable.<br>
	 * @param y The y coordinate of the first character, relative to the origin of \a drawable.<br>
	 * @param string The string to draw. Only the first 255 characters are relevant due to the data<br>
	 * type of \a string_len. Every character uses 2 bytes (hence the 16 in this<br>
	 * request's name).<br>
	 * @return A cookie<br>
	 * Fills the destination rectangle with the background pixel from \a gc, then<br>
	 * paints the text with the foreground pixel from \a gc. The upper-left corner of<br>
	 * the filled rectangle is at [x, y - font-ascent]. The width is overall-width,<br>
	 * the height is font-ascent + font-descent. The overall-width, font-ascent and<br>
	 * font-descent are as returned by `xcb_query_text_extents` (TODO).<br>
	 * <br>
	 * Note that using X core fonts is deprecated (but still supported) in favor of<br>
	 * client-side rendering using Xft.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_image_text_16_checked(xcb_connection_t*, uint8_t, xcb_drawable_t, xcb_gcontext_t, int16_t, int16_t, const xcb_char2b_t*)</code><br>
	 * @param c <<br>
	 * @param string_len <<br>
	 * @param drawable <<br>
	 * @param gc <<br>
	 * @param x <<br>
	 * @param y <<br>
	 * @param string <<br>
	 * <i>native declaration : xcb/xproto.h:7925</i><br>
	 * @deprecated use the safer method {@link #xcb_image_text_16_checked(com.sun.jna.ptr.PointerByReference, byte, int, int, short, short, xcb.xcb_char2b_t)} instead
	 */
	@Deprecated 
	xcb.xcb_void_cookie_t.ByValue xcb_image_text_16_checked(Pointer c, byte string_len, int drawable, int gc, short x, short y, xcb_char2b_t string);
	/**
	 * @brief Draws text<br>
	 * @param c The connection<br>
	 * @param string_len The length of the \a string in characters. Note that this parameter limited by<br>
	 * 255 due to using 8 bits!<br>
	 * @param drawable The drawable (Window or Pixmap) to draw text on.<br>
	 * @param gc The graphics context to use.<br>
	 * \n<br>
	 * The following graphics context components are used: plane-mask, foreground,<br>
	 * background, font, subwindow-mode, clip-x-origin, clip-y-origin, and clip-mask.<br>
	 * @param x The x coordinate of the first character, relative to the origin of \a drawable.<br>
	 * @param y The y coordinate of the first character, relative to the origin of \a drawable.<br>
	 * @param string The string to draw. Only the first 255 characters are relevant due to the data<br>
	 * type of \a string_len. Every character uses 2 bytes (hence the 16 in this<br>
	 * request's name).<br>
	 * @return A cookie<br>
	 * Fills the destination rectangle with the background pixel from \a gc, then<br>
	 * paints the text with the foreground pixel from \a gc. The upper-left corner of<br>
	 * the filled rectangle is at [x, y - font-ascent]. The width is overall-width,<br>
	 * the height is font-ascent + font-descent. The overall-width, font-ascent and<br>
	 * font-descent are as returned by `xcb_query_text_extents` (TODO).<br>
	 * <br>
	 * Note that using X core fonts is deprecated (but still supported) in favor of<br>
	 * client-side rendering using Xft.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_image_text_16_checked(xcb_connection_t*, uint8_t, xcb_drawable_t, xcb_gcontext_t, int16_t, int16_t, const xcb_char2b_t*)</code><br>
	 * @param c <<br>
	 * @param string_len <<br>
	 * @param drawable <<br>
	 * @param gc <<br>
	 * @param x <<br>
	 * @param y <<br>
	 * @param string <<br>
	 * <i>native declaration : xcb/xproto.h:7925</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_image_text_16_checked(PointerByReference c, byte string_len, int drawable, int gc, short x, short y, xcb_char2b_t string);
	/**
	 * @brief Draws text<br>
	 * @param c The connection<br>
	 * @param string_len The length of the \a string in characters. Note that this parameter limited by<br>
	 * 255 due to using 8 bits!<br>
	 * @param drawable The drawable (Window or Pixmap) to draw text on.<br>
	 * @param gc The graphics context to use.<br>
	 * \n<br>
	 * The following graphics context components are used: plane-mask, foreground,<br>
	 * background, font, subwindow-mode, clip-x-origin, clip-y-origin, and clip-mask.<br>
	 * @param x The x coordinate of the first character, relative to the origin of \a drawable.<br>
	 * @param y The y coordinate of the first character, relative to the origin of \a drawable.<br>
	 * @param string The string to draw. Only the first 255 characters are relevant due to the data<br>
	 * type of \a string_len. Every character uses 2 bytes (hence the 16 in this<br>
	 * request's name).<br>
	 * @return A cookie<br>
	 * Fills the destination rectangle with the background pixel from \a gc, then<br>
	 * paints the text with the foreground pixel from \a gc. The upper-left corner of<br>
	 * the filled rectangle is at [x, y - font-ascent]. The width is overall-width,<br>
	 * the height is font-ascent + font-descent. The overall-width, font-ascent and<br>
	 * font-descent are as returned by `xcb_query_text_extents` (TODO).<br>
	 * <br>
	 * Note that using X core fonts is deprecated (but still supported) in favor of<br>
	 * client-side rendering using Xft.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_image_text_16(xcb_connection_t*, uint8_t, xcb_drawable_t, xcb_gcontext_t, int16_t, int16_t, const xcb_char2b_t*)</code><br>
	 * @param c <<br>
	 * @param string_len <<br>
	 * @param drawable <<br>
	 * @param gc <<br>
	 * @param x <<br>
	 * @param y <<br>
	 * @param string <<br>
	 * <i>native declaration : xcb/xproto.h:7959</i><br>
	 * @deprecated use the safer method {@link #xcb_image_text_16(com.sun.jna.ptr.PointerByReference, byte, int, int, short, short, xcb.xcb_char2b_t)} instead
	 */
	@Deprecated 
	xcb.xcb_void_cookie_t.ByValue xcb_image_text_16(Pointer c, byte string_len, int drawable, int gc, short x, short y, xcb_char2b_t string);
	/**
	 * @brief Draws text<br>
	 * @param c The connection<br>
	 * @param string_len The length of the \a string in characters. Note that this parameter limited by<br>
	 * 255 due to using 8 bits!<br>
	 * @param drawable The drawable (Window or Pixmap) to draw text on.<br>
	 * @param gc The graphics context to use.<br>
	 * \n<br>
	 * The following graphics context components are used: plane-mask, foreground,<br>
	 * background, font, subwindow-mode, clip-x-origin, clip-y-origin, and clip-mask.<br>
	 * @param x The x coordinate of the first character, relative to the origin of \a drawable.<br>
	 * @param y The y coordinate of the first character, relative to the origin of \a drawable.<br>
	 * @param string The string to draw. Only the first 255 characters are relevant due to the data<br>
	 * type of \a string_len. Every character uses 2 bytes (hence the 16 in this<br>
	 * request's name).<br>
	 * @return A cookie<br>
	 * Fills the destination rectangle with the background pixel from \a gc, then<br>
	 * paints the text with the foreground pixel from \a gc. The upper-left corner of<br>
	 * the filled rectangle is at [x, y - font-ascent]. The width is overall-width,<br>
	 * the height is font-ascent + font-descent. The overall-width, font-ascent and<br>
	 * font-descent are as returned by `xcb_query_text_extents` (TODO).<br>
	 * <br>
	 * Note that using X core fonts is deprecated (but still supported) in favor of<br>
	 * client-side rendering using Xft.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_image_text_16(xcb_connection_t*, uint8_t, xcb_drawable_t, xcb_gcontext_t, int16_t, int16_t, const xcb_char2b_t*)</code><br>
	 * @param c <<br>
	 * @param string_len <<br>
	 * @param drawable <<br>
	 * @param gc <<br>
	 * @param x <<br>
	 * @param y <<br>
	 * @param string <<br>
	 * <i>native declaration : xcb/xproto.h:7959</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_image_text_16(PointerByReference c, byte string_len, int drawable, int gc, short x, short y, xcb_char2b_t string);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_create_colormap_checked(xcb_connection_t*, uint8_t, xcb_colormap_t, xcb_window_t, xcb_visualid_t)</code><br>
	 * @param c <<br>
	 * @param alloc <<br>
	 * @param mid <<br>
	 * @param window <<br>
	 * @param visual <<br>
	 * <i>native declaration : xcb/xproto.h:7974</i><br>
	 * @deprecated use the safer method {@link #xcb_create_colormap_checked(com.sun.jna.ptr.PointerByReference, byte, int, int, int)} instead
	 */
	@Deprecated 
	xcb.xcb_void_cookie_t.ByValue xcb_create_colormap_checked(Pointer c, byte alloc, int mid, int window, int visual);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_create_colormap_checked(xcb_connection_t*, uint8_t, xcb_colormap_t, xcb_window_t, xcb_visualid_t)</code><br>
	 * @param c <<br>
	 * @param alloc <<br>
	 * @param mid <<br>
	 * @param window <<br>
	 * @param visual <<br>
	 * <i>native declaration : xcb/xproto.h:7974</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_create_colormap_checked(PointerByReference c, byte alloc, int mid, int window, int visual);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_create_colormap(xcb_connection_t*, uint8_t, xcb_colormap_t, xcb_window_t, xcb_visualid_t)</code><br>
	 * @param c <<br>
	 * @param alloc <<br>
	 * @param mid <<br>
	 * @param window <<br>
	 * @param visual <<br>
	 * <i>native declaration : xcb/xproto.h:7986</i><br>
	 * @deprecated use the safer method {@link #xcb_create_colormap(com.sun.jna.ptr.PointerByReference, byte, int, int, int)} instead
	 */
	@Deprecated 
	xcb.xcb_void_cookie_t.ByValue xcb_create_colormap(Pointer c, byte alloc, int mid, int window, int visual);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_create_colormap(xcb_connection_t*, uint8_t, xcb_colormap_t, xcb_window_t, xcb_visualid_t)</code><br>
	 * @param c <<br>
	 * @param alloc <<br>
	 * @param mid <<br>
	 * @param window <<br>
	 * @param visual <<br>
	 * <i>native declaration : xcb/xproto.h:7986</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_create_colormap(PointerByReference c, byte alloc, int mid, int window, int visual);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_free_colormap_checked(xcb_connection_t*, xcb_colormap_t)</code><br>
	 * @param c <<br>
	 * @param cmap <<br>
	 * <i>native declaration : xcb/xproto.h:7998</i><br>
	 * @deprecated use the safer method {@link #xcb_free_colormap_checked(com.sun.jna.ptr.PointerByReference, int)} instead
	 */
	@Deprecated 
	xcb.xcb_void_cookie_t.ByValue xcb_free_colormap_checked(Pointer c, int cmap);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_free_colormap_checked(xcb_connection_t*, xcb_colormap_t)</code><br>
	 * @param c <<br>
	 * @param cmap <<br>
	 * <i>native declaration : xcb/xproto.h:7998</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_free_colormap_checked(PointerByReference c, int cmap);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_free_colormap(xcb_connection_t*, xcb_colormap_t)</code><br>
	 * @param c <<br>
	 * @param cmap <<br>
	 * <i>native declaration : xcb/xproto.h:8007</i><br>
	 * @deprecated use the safer method {@link #xcb_free_colormap(com.sun.jna.ptr.PointerByReference, int)} instead
	 */
	@Deprecated 
	xcb.xcb_void_cookie_t.ByValue xcb_free_colormap(Pointer c, int cmap);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_free_colormap(xcb_connection_t*, xcb_colormap_t)</code><br>
	 * @param c <<br>
	 * @param cmap <<br>
	 * <i>native declaration : xcb/xproto.h:8007</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_free_colormap(PointerByReference c, int cmap);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_copy_colormap_and_free_checked(xcb_connection_t*, xcb_colormap_t, xcb_colormap_t)</code><br>
	 * @param c <<br>
	 * @param mid <<br>
	 * @param src_cmap <<br>
	 * <i>native declaration : xcb/xproto.h:8020</i><br>
	 * @deprecated use the safer method {@link #xcb_copy_colormap_and_free_checked(com.sun.jna.ptr.PointerByReference, int, int)} instead
	 */
	@Deprecated 
	xcb.xcb_void_cookie_t.ByValue xcb_copy_colormap_and_free_checked(Pointer c, int mid, int src_cmap);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_copy_colormap_and_free_checked(xcb_connection_t*, xcb_colormap_t, xcb_colormap_t)</code><br>
	 * @param c <<br>
	 * @param mid <<br>
	 * @param src_cmap <<br>
	 * <i>native declaration : xcb/xproto.h:8020</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_copy_colormap_and_free_checked(PointerByReference c, int mid, int src_cmap);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_copy_colormap_and_free(xcb_connection_t*, xcb_colormap_t, xcb_colormap_t)</code><br>
	 * @param c <<br>
	 * @param mid <<br>
	 * @param src_cmap <<br>
	 * <i>native declaration : xcb/xproto.h:8030</i><br>
	 * @deprecated use the safer method {@link #xcb_copy_colormap_and_free(com.sun.jna.ptr.PointerByReference, int, int)} instead
	 */
	@Deprecated 
	xcb.xcb_void_cookie_t.ByValue xcb_copy_colormap_and_free(Pointer c, int mid, int src_cmap);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_copy_colormap_and_free(xcb_connection_t*, xcb_colormap_t, xcb_colormap_t)</code><br>
	 * @param c <<br>
	 * @param mid <<br>
	 * @param src_cmap <<br>
	 * <i>native declaration : xcb/xproto.h:8030</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_copy_colormap_and_free(PointerByReference c, int mid, int src_cmap);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_install_colormap_checked(xcb_connection_t*, xcb_colormap_t)</code><br>
	 * @param c <<br>
	 * @param cmap <<br>
	 * <i>native declaration : xcb/xproto.h:8042</i><br>
	 * @deprecated use the safer method {@link #xcb_install_colormap_checked(com.sun.jna.ptr.PointerByReference, int)} instead
	 */
	@Deprecated 
	xcb.xcb_void_cookie_t.ByValue xcb_install_colormap_checked(Pointer c, int cmap);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_install_colormap_checked(xcb_connection_t*, xcb_colormap_t)</code><br>
	 * @param c <<br>
	 * @param cmap <<br>
	 * <i>native declaration : xcb/xproto.h:8042</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_install_colormap_checked(PointerByReference c, int cmap);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_install_colormap(xcb_connection_t*, xcb_colormap_t)</code><br>
	 * @param c <<br>
	 * @param cmap <<br>
	 * <i>native declaration : xcb/xproto.h:8051</i><br>
	 * @deprecated use the safer method {@link #xcb_install_colormap(com.sun.jna.ptr.PointerByReference, int)} instead
	 */
	@Deprecated 
	xcb.xcb_void_cookie_t.ByValue xcb_install_colormap(Pointer c, int cmap);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_install_colormap(xcb_connection_t*, xcb_colormap_t)</code><br>
	 * @param c <<br>
	 * @param cmap <<br>
	 * <i>native declaration : xcb/xproto.h:8051</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_install_colormap(PointerByReference c, int cmap);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_uninstall_colormap_checked(xcb_connection_t*, xcb_colormap_t)</code><br>
	 * @param c <<br>
	 * @param cmap <<br>
	 * <i>native declaration : xcb/xproto.h:8063</i><br>
	 * @deprecated use the safer method {@link #xcb_uninstall_colormap_checked(com.sun.jna.ptr.PointerByReference, int)} instead
	 */
	@Deprecated 
	xcb.xcb_void_cookie_t.ByValue xcb_uninstall_colormap_checked(Pointer c, int cmap);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_uninstall_colormap_checked(xcb_connection_t*, xcb_colormap_t)</code><br>
	 * @param c <<br>
	 * @param cmap <<br>
	 * <i>native declaration : xcb/xproto.h:8063</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_uninstall_colormap_checked(PointerByReference c, int cmap);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_uninstall_colormap(xcb_connection_t*, xcb_colormap_t)</code><br>
	 * @param c <<br>
	 * @param cmap <<br>
	 * <i>native declaration : xcb/xproto.h:8072</i><br>
	 * @deprecated use the safer method {@link #xcb_uninstall_colormap(com.sun.jna.ptr.PointerByReference, int)} instead
	 */
	@Deprecated 
	xcb.xcb_void_cookie_t.ByValue xcb_uninstall_colormap(Pointer c, int cmap);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_uninstall_colormap(xcb_connection_t*, xcb_colormap_t)</code><br>
	 * @param c <<br>
	 * @param cmap <<br>
	 * <i>native declaration : xcb/xproto.h:8072</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_uninstall_colormap(PointerByReference c, int cmap);
	/**
	 * Original signature : <code>int xcb_list_installed_colormaps_sizeof(const void*)</code><br>
	 * @param _buffer <<br>
	 * <i>native declaration : xcb/xproto.h:8077</i>
	 */
	int xcb_list_installed_colormaps_sizeof(Pointer _buffer);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_list_installed_colormaps_cookie_t xcb_list_installed_colormaps(xcb_connection_t*, xcb_window_t)</code><br>
	 * @param c <<br>
	 * @param window <<br>
	 * <i>native declaration : xcb/xproto.h:8086</i><br>
	 * @deprecated use the safer method {@link #xcb_list_installed_colormaps(com.sun.jna.ptr.PointerByReference, int)} instead
	 */
	@Deprecated 
	xcb.xcb_list_installed_colormaps_cookie_t.ByValue xcb_list_installed_colormaps(Pointer c, int window);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_list_installed_colormaps_cookie_t xcb_list_installed_colormaps(xcb_connection_t*, xcb_window_t)</code><br>
	 * @param c <<br>
	 * @param window <<br>
	 * <i>native declaration : xcb/xproto.h:8086</i>
	 */
	xcb.xcb_list_installed_colormaps_cookie_t.ByValue xcb_list_installed_colormaps(PointerByReference c, int window);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * placed in the event queue.<br>
	 * Original signature : <code>xcb_list_installed_colormaps_cookie_t xcb_list_installed_colormaps_unchecked(xcb_connection_t*, xcb_window_t)</code><br>
	 * @param c <<br>
	 * @param window <<br>
	 * <i>native declaration : xcb/xproto.h:8098</i><br>
	 * @deprecated use the safer method {@link #xcb_list_installed_colormaps_unchecked(com.sun.jna.ptr.PointerByReference, int)} instead
	 */
	@Deprecated 
	xcb.xcb_list_installed_colormaps_cookie_t.ByValue xcb_list_installed_colormaps_unchecked(Pointer c, int window);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * placed in the event queue.<br>
	 * Original signature : <code>xcb_list_installed_colormaps_cookie_t xcb_list_installed_colormaps_unchecked(xcb_connection_t*, xcb_window_t)</code><br>
	 * @param c <<br>
	 * @param window <<br>
	 * <i>native declaration : xcb/xproto.h:8098</i>
	 */
	xcb.xcb_list_installed_colormaps_cookie_t.ByValue xcb_list_installed_colormaps_unchecked(PointerByReference c, int window);
	/**
	 * Original signature : <code>xcb_colormap_t* xcb_list_installed_colormaps_cmaps(const xcb_list_installed_colormaps_reply_t*)</code><br>
	 * @param R <<br>
	 * <i>native declaration : xcb/xproto.h:8103</i>
	 */
	IntByReference xcb_list_installed_colormaps_cmaps(xcb_list_installed_colormaps_reply_t R);
	/**
	 * Original signature : <code>int xcb_list_installed_colormaps_cmaps_length(const xcb_list_installed_colormaps_reply_t*)</code><br>
	 * @param R <<br>
	 * <i>native declaration : xcb/xproto.h:8108</i>
	 */
	int xcb_list_installed_colormaps_cmaps_length(xcb_list_installed_colormaps_reply_t R);
	/**
	 * Original signature : <code>xcb_generic_iterator_t xcb_list_installed_colormaps_cmaps_end(const xcb_list_installed_colormaps_reply_t*)</code><br>
	 * @param R <<br>
	 * <i>native declaration : xcb/xproto.h:8113</i>
	 */
	xcb.xcb_generic_iterator_t.ByValue xcb_list_installed_colormaps_cmaps_end(xcb_list_installed_colormaps_reply_t R);
	/**
	 * Return the reply<br>
	 * @param c      The connection<br>
	 * @param cookie The cookie<br>
	 * @param e      The xcb_generic_error_t supplied<br>
	 * Returns the reply of the request asked by<br>
	 * The parameter @p e supplied to this function must be NULL if<br>
	 * xcb_list_installed_colormaps_unchecked(). is used.<br>
	 * Otherwise, it stores the error if any.<br>
	 * The returned value must be freed by the caller using free().<br>
	 * Original signature : <code>xcb_list_installed_colormaps_reply_t* xcb_list_installed_colormaps_reply(xcb_connection_t*, xcb_list_installed_colormaps_cookie_t, xcb_generic_error_t**)</code><br>
	 * @param c <<br>
	 * @param cookie <<br>
	 * @param e <<br>
	 * <i>native declaration : xcb/xproto.h:8129</i><br>
	 * @deprecated use the safer method {@link #xcb_list_installed_colormaps_reply(com.sun.jna.ptr.PointerByReference, xcb.xcb_list_installed_colormaps_cookie_t.ByValue, xcb.xcb_generic_error_t.ByReference[])} instead
	 */
	@Deprecated 
	xcb_list_installed_colormaps_reply_t xcb_list_installed_colormaps_reply(Pointer c, xcb.xcb_list_installed_colormaps_cookie_t.ByValue cookie, PointerByReference e);
	/**
	 * Return the reply<br>
	 * @param c      The connection<br>
	 * @param cookie The cookie<br>
	 * @param e      The xcb_generic_error_t supplied<br>
	 * Returns the reply of the request asked by<br>
	 * The parameter @p e supplied to this function must be NULL if<br>
	 * xcb_list_installed_colormaps_unchecked(). is used.<br>
	 * Otherwise, it stores the error if any.<br>
	 * The returned value must be freed by the caller using free().<br>
	 * Original signature : <code>xcb_list_installed_colormaps_reply_t* xcb_list_installed_colormaps_reply(xcb_connection_t*, xcb_list_installed_colormaps_cookie_t, xcb_generic_error_t**)</code><br>
	 * @param c <<br>
	 * @param cookie <<br>
	 * @param e <<br>
	 * <i>native declaration : xcb/xproto.h:8129</i>
	 */
	xcb_list_installed_colormaps_reply_t xcb_list_installed_colormaps_reply(PointerByReference c, xcb.xcb_list_installed_colormaps_cookie_t.ByValue cookie, xcb_generic_error_t.ByReference e[]);
	/**
	 * @brief Allocate a color<br>
	 * @param c The connection<br>
	 * @param cmap TODO<br>
	 * @param red The red value of your color.<br>
	 * @param green The green value of your color.<br>
	 * @param blue The blue value of your color.<br>
	 * @return A cookie<br>
	 * Allocates a read-only colormap entry corresponding to the closest RGB value<br>
	 * supported by the hardware. If you are using TrueColor, you can take a shortcut<br>
	 * and directly calculate the color pixel value to avoid the round trip. But, for<br>
	 * example, on 16-bit color setups (VNC), you can easily get the closest supported<br>
	 * RGB value to the RGB value you are specifying.<br>
	 * Original signature : <code>xcb_alloc_color_cookie_t xcb_alloc_color(xcb_connection_t*, xcb_colormap_t, uint16_t, uint16_t, uint16_t)</code><br>
	 * @param c <<br>
	 * @param cmap <<br>
	 * @param red <<br>
	 * @param green <<br>
	 * @param blue <<br>
	 * <i>native declaration : xcb/xproto.h:8150</i><br>
	 * @deprecated use the safer method {@link #xcb_alloc_color(com.sun.jna.ptr.PointerByReference, int, short, short, short)} instead
	 */
	@Deprecated 
	xcb.xcb_alloc_color_cookie_t.ByValue xcb_alloc_color(Pointer c, int cmap, short red, short green, short blue);
	/**
	 * @brief Allocate a color<br>
	 * @param c The connection<br>
	 * @param cmap TODO<br>
	 * @param red The red value of your color.<br>
	 * @param green The green value of your color.<br>
	 * @param blue The blue value of your color.<br>
	 * @return A cookie<br>
	 * Allocates a read-only colormap entry corresponding to the closest RGB value<br>
	 * supported by the hardware. If you are using TrueColor, you can take a shortcut<br>
	 * and directly calculate the color pixel value to avoid the round trip. But, for<br>
	 * example, on 16-bit color setups (VNC), you can easily get the closest supported<br>
	 * RGB value to the RGB value you are specifying.<br>
	 * Original signature : <code>xcb_alloc_color_cookie_t xcb_alloc_color(xcb_connection_t*, xcb_colormap_t, uint16_t, uint16_t, uint16_t)</code><br>
	 * @param c <<br>
	 * @param cmap <<br>
	 * @param red <<br>
	 * @param green <<br>
	 * @param blue <<br>
	 * <i>native declaration : xcb/xproto.h:8150</i>
	 */
	xcb.xcb_alloc_color_cookie_t.ByValue xcb_alloc_color(PointerByReference c, int cmap, short red, short green, short blue);
	/**
	 * @brief Allocate a color<br>
	 * @param c The connection<br>
	 * @param cmap TODO<br>
	 * @param red The red value of your color.<br>
	 * @param green The green value of your color.<br>
	 * @param blue The blue value of your color.<br>
	 * @return A cookie<br>
	 * Allocates a read-only colormap entry corresponding to the closest RGB value<br>
	 * supported by the hardware. If you are using TrueColor, you can take a shortcut<br>
	 * and directly calculate the color pixel value to avoid the round trip. But, for<br>
	 * example, on 16-bit color setups (VNC), you can easily get the closest supported<br>
	 * RGB value to the RGB value you are specifying.<br>
	 * This form can be used only if the request will cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * placed in the event queue.<br>
	 * Original signature : <code>xcb_alloc_color_cookie_t xcb_alloc_color_unchecked(xcb_connection_t*, xcb_colormap_t, uint16_t, uint16_t, uint16_t)</code><br>
	 * @param c <<br>
	 * @param cmap <<br>
	 * @param red <<br>
	 * @param green <<br>
	 * @param blue <<br>
	 * <i>native declaration : xcb/xproto.h:8174</i><br>
	 * @deprecated use the safer method {@link #xcb_alloc_color_unchecked(com.sun.jna.ptr.PointerByReference, int, short, short, short)} instead
	 */
	@Deprecated 
	xcb.xcb_alloc_color_cookie_t.ByValue xcb_alloc_color_unchecked(Pointer c, int cmap, short red, short green, short blue);
	/**
	 * @brief Allocate a color<br>
	 * @param c The connection<br>
	 * @param cmap TODO<br>
	 * @param red The red value of your color.<br>
	 * @param green The green value of your color.<br>
	 * @param blue The blue value of your color.<br>
	 * @return A cookie<br>
	 * Allocates a read-only colormap entry corresponding to the closest RGB value<br>
	 * supported by the hardware. If you are using TrueColor, you can take a shortcut<br>
	 * and directly calculate the color pixel value to avoid the round trip. But, for<br>
	 * example, on 16-bit color setups (VNC), you can easily get the closest supported<br>
	 * RGB value to the RGB value you are specifying.<br>
	 * This form can be used only if the request will cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * placed in the event queue.<br>
	 * Original signature : <code>xcb_alloc_color_cookie_t xcb_alloc_color_unchecked(xcb_connection_t*, xcb_colormap_t, uint16_t, uint16_t, uint16_t)</code><br>
	 * @param c <<br>
	 * @param cmap <<br>
	 * @param red <<br>
	 * @param green <<br>
	 * @param blue <<br>
	 * <i>native declaration : xcb/xproto.h:8174</i>
	 */
	xcb.xcb_alloc_color_cookie_t.ByValue xcb_alloc_color_unchecked(PointerByReference c, int cmap, short red, short green, short blue);
	/**
	 * Return the reply<br>
	 * @param c      The connection<br>
	 * @param cookie The cookie<br>
	 * @param e      The xcb_generic_error_t supplied<br>
	 * Returns the reply of the request asked by<br>
	 * The parameter @p e supplied to this function must be NULL if<br>
	 * xcb_alloc_color_unchecked(). is used.<br>
	 * Otherwise, it stores the error if any.<br>
	 * The returned value must be freed by the caller using free().<br>
	 * Original signature : <code>xcb_alloc_color_reply_t* xcb_alloc_color_reply(xcb_connection_t*, xcb_alloc_color_cookie_t, xcb_generic_error_t**)</code><br>
	 * @param c <<br>
	 * @param cookie <<br>
	 * @param e <<br>
	 * <i>native declaration : xcb/xproto.h:8190</i><br>
	 * @deprecated use the safer method {@link #xcb_alloc_color_reply(com.sun.jna.ptr.PointerByReference, xcb.xcb_alloc_color_cookie_t.ByValue, xcb.xcb_generic_error_t.ByReference[])} instead
	 */
	@Deprecated 
	xcb_alloc_color_reply_t xcb_alloc_color_reply(Pointer c, xcb.xcb_alloc_color_cookie_t.ByValue cookie, PointerByReference e);
	/**
	 * Return the reply<br>
	 * @param c      The connection<br>
	 * @param cookie The cookie<br>
	 * @param e      The xcb_generic_error_t supplied<br>
	 * Returns the reply of the request asked by<br>
	 * The parameter @p e supplied to this function must be NULL if<br>
	 * xcb_alloc_color_unchecked(). is used.<br>
	 * Otherwise, it stores the error if any.<br>
	 * The returned value must be freed by the caller using free().<br>
	 * Original signature : <code>xcb_alloc_color_reply_t* xcb_alloc_color_reply(xcb_connection_t*, xcb_alloc_color_cookie_t, xcb_generic_error_t**)</code><br>
	 * @param c <<br>
	 * @param cookie <<br>
	 * @param e <<br>
	 * <i>native declaration : xcb/xproto.h:8190</i>
	 */
	xcb_alloc_color_reply_t xcb_alloc_color_reply(PointerByReference c, xcb.xcb_alloc_color_cookie_t.ByValue cookie, xcb_generic_error_t.ByReference e[]);
	/**
	 * Original signature : <code>int xcb_alloc_named_color_sizeof(const void*)</code><br>
	 * @param _buffer <<br>
	 * <i>native declaration : xcb/xproto.h:8195</i>
	 */
	int xcb_alloc_named_color_sizeof(Pointer _buffer);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_alloc_named_color_cookie_t xcb_alloc_named_color(xcb_connection_t*, xcb_colormap_t, uint16_t, const char*)</code><br>
	 * @param c <<br>
	 * @param cmap <<br>
	 * @param name_len <<br>
	 * @param name <<br>
	 * <i>native declaration : xcb/xproto.h:8206</i><br>
	 * @deprecated use the safer methods {@link #xcb_alloc_named_color(com.sun.jna.ptr.PointerByReference, int, short, java.lang.String)} and {@link #xcb_alloc_named_color(com.sun.jna.ptr.PointerByReference, int, short, com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	xcb.xcb_alloc_named_color_cookie_t.ByValue xcb_alloc_named_color(Pointer c, int cmap, short name_len, Pointer name);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_alloc_named_color_cookie_t xcb_alloc_named_color(xcb_connection_t*, xcb_colormap_t, uint16_t, const char*)</code><br>
	 * @param c <<br>
	 * @param cmap <<br>
	 * @param name_len <<br>
	 * @param name <<br>
	 * <i>native declaration : xcb/xproto.h:8206</i>
	 */
	xcb.xcb_alloc_named_color_cookie_t.ByValue xcb_alloc_named_color(PointerByReference c, int cmap, short name_len, String name);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_alloc_named_color_cookie_t xcb_alloc_named_color(xcb_connection_t*, xcb_colormap_t, uint16_t, const char*)</code><br>
	 * @param c <<br>
	 * @param cmap <<br>
	 * @param name_len <<br>
	 * @param name <<br>
	 * <i>native declaration : xcb/xproto.h:8206</i>
	 */
	xcb.xcb_alloc_named_color_cookie_t.ByValue xcb_alloc_named_color(PointerByReference c, int cmap, short name_len, Pointer name);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * placed in the event queue.<br>
	 * Original signature : <code>xcb_alloc_named_color_cookie_t xcb_alloc_named_color_unchecked(xcb_connection_t*, xcb_colormap_t, uint16_t, const char*)</code><br>
	 * @param c <<br>
	 * @param cmap <<br>
	 * @param name_len <<br>
	 * @param name <<br>
	 * <i>native declaration : xcb/xproto.h:8220</i><br>
	 * @deprecated use the safer methods {@link #xcb_alloc_named_color_unchecked(com.sun.jna.ptr.PointerByReference, int, short, java.lang.String)} and {@link #xcb_alloc_named_color_unchecked(com.sun.jna.ptr.PointerByReference, int, short, com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	xcb.xcb_alloc_named_color_cookie_t.ByValue xcb_alloc_named_color_unchecked(Pointer c, int cmap, short name_len, Pointer name);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * placed in the event queue.<br>
	 * Original signature : <code>xcb_alloc_named_color_cookie_t xcb_alloc_named_color_unchecked(xcb_connection_t*, xcb_colormap_t, uint16_t, const char*)</code><br>
	 * @param c <<br>
	 * @param cmap <<br>
	 * @param name_len <<br>
	 * @param name <<br>
	 * <i>native declaration : xcb/xproto.h:8220</i>
	 */
	xcb.xcb_alloc_named_color_cookie_t.ByValue xcb_alloc_named_color_unchecked(PointerByReference c, int cmap, short name_len, String name);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * placed in the event queue.<br>
	 * Original signature : <code>xcb_alloc_named_color_cookie_t xcb_alloc_named_color_unchecked(xcb_connection_t*, xcb_colormap_t, uint16_t, const char*)</code><br>
	 * @param c <<br>
	 * @param cmap <<br>
	 * @param name_len <<br>
	 * @param name <<br>
	 * <i>native declaration : xcb/xproto.h:8220</i>
	 */
	xcb.xcb_alloc_named_color_cookie_t.ByValue xcb_alloc_named_color_unchecked(PointerByReference c, int cmap, short name_len, Pointer name);
	/**
	 * Return the reply<br>
	 * @param c      The connection<br>
	 * @param cookie The cookie<br>
	 * @param e      The xcb_generic_error_t supplied<br>
	 * Returns the reply of the request asked by<br>
	 * The parameter @p e supplied to this function must be NULL if<br>
	 * xcb_alloc_named_color_unchecked(). is used.<br>
	 * Otherwise, it stores the error if any.<br>
	 * The returned value must be freed by the caller using free().<br>
	 * Original signature : <code>xcb_alloc_named_color_reply_t* xcb_alloc_named_color_reply(xcb_connection_t*, xcb_alloc_named_color_cookie_t, xcb_generic_error_t**)</code><br>
	 * @param c <<br>
	 * @param cookie <<br>
	 * @param e <<br>
	 * <i>native declaration : xcb/xproto.h:8236</i><br>
	 * @deprecated use the safer method {@link #xcb_alloc_named_color_reply(com.sun.jna.ptr.PointerByReference, xcb.xcb_alloc_named_color_cookie_t.ByValue, xcb.xcb_generic_error_t.ByReference[])} instead
	 */
	@Deprecated 
	xcb_alloc_named_color_reply_t xcb_alloc_named_color_reply(Pointer c, xcb.xcb_alloc_named_color_cookie_t.ByValue cookie, PointerByReference e);
	/**
	 * Return the reply<br>
	 * @param c      The connection<br>
	 * @param cookie The cookie<br>
	 * @param e      The xcb_generic_error_t supplied<br>
	 * Returns the reply of the request asked by<br>
	 * The parameter @p e supplied to this function must be NULL if<br>
	 * xcb_alloc_named_color_unchecked(). is used.<br>
	 * Otherwise, it stores the error if any.<br>
	 * The returned value must be freed by the caller using free().<br>
	 * Original signature : <code>xcb_alloc_named_color_reply_t* xcb_alloc_named_color_reply(xcb_connection_t*, xcb_alloc_named_color_cookie_t, xcb_generic_error_t**)</code><br>
	 * @param c <<br>
	 * @param cookie <<br>
	 * @param e <<br>
	 * <i>native declaration : xcb/xproto.h:8236</i>
	 */
	xcb_alloc_named_color_reply_t xcb_alloc_named_color_reply(PointerByReference c, xcb.xcb_alloc_named_color_cookie_t.ByValue cookie, xcb_generic_error_t.ByReference e[]);
	/**
	 * Original signature : <code>int xcb_alloc_color_cells_sizeof(const void*)</code><br>
	 * @param _buffer <<br>
	 * <i>native declaration : xcb/xproto.h:8241</i>
	 */
	int xcb_alloc_color_cells_sizeof(Pointer _buffer);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_alloc_color_cells_cookie_t xcb_alloc_color_cells(xcb_connection_t*, uint8_t, xcb_colormap_t, uint16_t, uint16_t)</code><br>
	 * @param c <<br>
	 * @param contiguous <<br>
	 * @param cmap <<br>
	 * @param colors <<br>
	 * @param planes <<br>
	 * <i>native declaration : xcb/xproto.h:8253</i><br>
	 * @deprecated use the safer method {@link #xcb_alloc_color_cells(com.sun.jna.ptr.PointerByReference, byte, int, short, short)} instead
	 */
	@Deprecated 
	xcb.xcb_alloc_color_cells_cookie_t.ByValue xcb_alloc_color_cells(Pointer c, byte contiguous, int cmap, short colors, short planes);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_alloc_color_cells_cookie_t xcb_alloc_color_cells(xcb_connection_t*, uint8_t, xcb_colormap_t, uint16_t, uint16_t)</code><br>
	 * @param c <<br>
	 * @param contiguous <<br>
	 * @param cmap <<br>
	 * @param colors <<br>
	 * @param planes <<br>
	 * <i>native declaration : xcb/xproto.h:8253</i>
	 */
	xcb.xcb_alloc_color_cells_cookie_t.ByValue xcb_alloc_color_cells(PointerByReference c, byte contiguous, int cmap, short colors, short planes);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * placed in the event queue.<br>
	 * Original signature : <code>xcb_alloc_color_cells_cookie_t xcb_alloc_color_cells_unchecked(xcb_connection_t*, uint8_t, xcb_colormap_t, uint16_t, uint16_t)</code><br>
	 * @param c <<br>
	 * @param contiguous <<br>
	 * @param cmap <<br>
	 * @param colors <<br>
	 * @param planes <<br>
	 * <i>native declaration : xcb/xproto.h:8268</i><br>
	 * @deprecated use the safer method {@link #xcb_alloc_color_cells_unchecked(com.sun.jna.ptr.PointerByReference, byte, int, short, short)} instead
	 */
	@Deprecated 
	xcb.xcb_alloc_color_cells_cookie_t.ByValue xcb_alloc_color_cells_unchecked(Pointer c, byte contiguous, int cmap, short colors, short planes);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * placed in the event queue.<br>
	 * Original signature : <code>xcb_alloc_color_cells_cookie_t xcb_alloc_color_cells_unchecked(xcb_connection_t*, uint8_t, xcb_colormap_t, uint16_t, uint16_t)</code><br>
	 * @param c <<br>
	 * @param contiguous <<br>
	 * @param cmap <<br>
	 * @param colors <<br>
	 * @param planes <<br>
	 * <i>native declaration : xcb/xproto.h:8268</i>
	 */
	xcb.xcb_alloc_color_cells_cookie_t.ByValue xcb_alloc_color_cells_unchecked(PointerByReference c, byte contiguous, int cmap, short colors, short planes);
	/**
	 * Original signature : <code>uint32_t* xcb_alloc_color_cells_pixels(const xcb_alloc_color_cells_reply_t*)</code><br>
	 * @param R <<br>
	 * <i>native declaration : xcb/xproto.h:8273</i>
	 */
	IntByReference xcb_alloc_color_cells_pixels(xcb_alloc_color_cells_reply_t R);
	/**
	 * Original signature : <code>int xcb_alloc_color_cells_pixels_length(const xcb_alloc_color_cells_reply_t*)</code><br>
	 * @param R <<br>
	 * <i>native declaration : xcb/xproto.h:8278</i>
	 */
	int xcb_alloc_color_cells_pixels_length(xcb_alloc_color_cells_reply_t R);
	/**
	 * Original signature : <code>xcb_generic_iterator_t xcb_alloc_color_cells_pixels_end(const xcb_alloc_color_cells_reply_t*)</code><br>
	 * @param R <<br>
	 * <i>native declaration : xcb/xproto.h:8283</i>
	 */
	xcb.xcb_generic_iterator_t.ByValue xcb_alloc_color_cells_pixels_end(xcb_alloc_color_cells_reply_t R);
	/**
	 * Original signature : <code>uint32_t* xcb_alloc_color_cells_masks(const xcb_alloc_color_cells_reply_t*)</code><br>
	 * @param R <<br>
	 * <i>native declaration : xcb/xproto.h:8288</i>
	 */
	IntByReference xcb_alloc_color_cells_masks(xcb_alloc_color_cells_reply_t R);
	/**
	 * Original signature : <code>int xcb_alloc_color_cells_masks_length(const xcb_alloc_color_cells_reply_t*)</code><br>
	 * @param R <<br>
	 * <i>native declaration : xcb/xproto.h:8293</i>
	 */
	int xcb_alloc_color_cells_masks_length(xcb_alloc_color_cells_reply_t R);
	/**
	 * Original signature : <code>xcb_generic_iterator_t xcb_alloc_color_cells_masks_end(const xcb_alloc_color_cells_reply_t*)</code><br>
	 * @param R <<br>
	 * <i>native declaration : xcb/xproto.h:8298</i>
	 */
	xcb.xcb_generic_iterator_t.ByValue xcb_alloc_color_cells_masks_end(xcb_alloc_color_cells_reply_t R);
	/**
	 * Return the reply<br>
	 * @param c      The connection<br>
	 * @param cookie The cookie<br>
	 * @param e      The xcb_generic_error_t supplied<br>
	 * Returns the reply of the request asked by<br>
	 * The parameter @p e supplied to this function must be NULL if<br>
	 * xcb_alloc_color_cells_unchecked(). is used.<br>
	 * Otherwise, it stores the error if any.<br>
	 * The returned value must be freed by the caller using free().<br>
	 * Original signature : <code>xcb_alloc_color_cells_reply_t* xcb_alloc_color_cells_reply(xcb_connection_t*, xcb_alloc_color_cells_cookie_t, xcb_generic_error_t**)</code><br>
	 * @param c <<br>
	 * @param cookie <<br>
	 * @param e <<br>
	 * <i>native declaration : xcb/xproto.h:8314</i><br>
	 * @deprecated use the safer method {@link #xcb_alloc_color_cells_reply(com.sun.jna.ptr.PointerByReference, xcb.xcb_alloc_color_cells_cookie_t.ByValue, xcb.xcb_generic_error_t.ByReference[])} instead
	 */
	@Deprecated 
	xcb_alloc_color_cells_reply_t xcb_alloc_color_cells_reply(Pointer c, xcb.xcb_alloc_color_cells_cookie_t.ByValue cookie, PointerByReference e);
	/**
	 * Return the reply<br>
	 * @param c      The connection<br>
	 * @param cookie The cookie<br>
	 * @param e      The xcb_generic_error_t supplied<br>
	 * Returns the reply of the request asked by<br>
	 * The parameter @p e supplied to this function must be NULL if<br>
	 * xcb_alloc_color_cells_unchecked(). is used.<br>
	 * Otherwise, it stores the error if any.<br>
	 * The returned value must be freed by the caller using free().<br>
	 * Original signature : <code>xcb_alloc_color_cells_reply_t* xcb_alloc_color_cells_reply(xcb_connection_t*, xcb_alloc_color_cells_cookie_t, xcb_generic_error_t**)</code><br>
	 * @param c <<br>
	 * @param cookie <<br>
	 * @param e <<br>
	 * <i>native declaration : xcb/xproto.h:8314</i>
	 */
	xcb_alloc_color_cells_reply_t xcb_alloc_color_cells_reply(PointerByReference c, xcb.xcb_alloc_color_cells_cookie_t.ByValue cookie, xcb_generic_error_t.ByReference e[]);
	/**
	 * Original signature : <code>int xcb_alloc_color_planes_sizeof(const void*)</code><br>
	 * @param _buffer <<br>
	 * <i>native declaration : xcb/xproto.h:8319</i>
	 */
	int xcb_alloc_color_planes_sizeof(Pointer _buffer);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_alloc_color_planes_cookie_t xcb_alloc_color_planes(xcb_connection_t*, uint8_t, xcb_colormap_t, uint16_t, uint16_t, uint16_t, uint16_t)</code><br>
	 * @param c <<br>
	 * @param contiguous <<br>
	 * @param cmap <<br>
	 * @param colors <<br>
	 * @param reds <<br>
	 * @param greens <<br>
	 * @param blues <<br>
	 * <i>native declaration : xcb/xproto.h:8333</i><br>
	 * @deprecated use the safer method {@link #xcb_alloc_color_planes(com.sun.jna.ptr.PointerByReference, byte, int, short, short, short, short)} instead
	 */
	@Deprecated 
	xcb.xcb_alloc_color_planes_cookie_t.ByValue xcb_alloc_color_planes(Pointer c, byte contiguous, int cmap, short colors, short reds, short greens, short blues);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_alloc_color_planes_cookie_t xcb_alloc_color_planes(xcb_connection_t*, uint8_t, xcb_colormap_t, uint16_t, uint16_t, uint16_t, uint16_t)</code><br>
	 * @param c <<br>
	 * @param contiguous <<br>
	 * @param cmap <<br>
	 * @param colors <<br>
	 * @param reds <<br>
	 * @param greens <<br>
	 * @param blues <<br>
	 * <i>native declaration : xcb/xproto.h:8333</i>
	 */
	xcb.xcb_alloc_color_planes_cookie_t.ByValue xcb_alloc_color_planes(PointerByReference c, byte contiguous, int cmap, short colors, short reds, short greens, short blues);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * placed in the event queue.<br>
	 * Original signature : <code>xcb_alloc_color_planes_cookie_t xcb_alloc_color_planes_unchecked(xcb_connection_t*, uint8_t, xcb_colormap_t, uint16_t, uint16_t, uint16_t, uint16_t)</code><br>
	 * @param c <<br>
	 * @param contiguous <<br>
	 * @param cmap <<br>
	 * @param colors <<br>
	 * @param reds <<br>
	 * @param greens <<br>
	 * @param blues <<br>
	 * <i>native declaration : xcb/xproto.h:8350</i><br>
	 * @deprecated use the safer method {@link #xcb_alloc_color_planes_unchecked(com.sun.jna.ptr.PointerByReference, byte, int, short, short, short, short)} instead
	 */
	@Deprecated 
	xcb.xcb_alloc_color_planes_cookie_t.ByValue xcb_alloc_color_planes_unchecked(Pointer c, byte contiguous, int cmap, short colors, short reds, short greens, short blues);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * placed in the event queue.<br>
	 * Original signature : <code>xcb_alloc_color_planes_cookie_t xcb_alloc_color_planes_unchecked(xcb_connection_t*, uint8_t, xcb_colormap_t, uint16_t, uint16_t, uint16_t, uint16_t)</code><br>
	 * @param c <<br>
	 * @param contiguous <<br>
	 * @param cmap <<br>
	 * @param colors <<br>
	 * @param reds <<br>
	 * @param greens <<br>
	 * @param blues <<br>
	 * <i>native declaration : xcb/xproto.h:8350</i>
	 */
	xcb.xcb_alloc_color_planes_cookie_t.ByValue xcb_alloc_color_planes_unchecked(PointerByReference c, byte contiguous, int cmap, short colors, short reds, short greens, short blues);
	/**
	 * Original signature : <code>uint32_t* xcb_alloc_color_planes_pixels(const xcb_alloc_color_planes_reply_t*)</code><br>
	 * @param R <<br>
	 * <i>native declaration : xcb/xproto.h:8355</i>
	 */
	IntByReference xcb_alloc_color_planes_pixels(xcb_alloc_color_planes_reply_t R);
	/**
	 * Original signature : <code>int xcb_alloc_color_planes_pixels_length(const xcb_alloc_color_planes_reply_t*)</code><br>
	 * @param R <<br>
	 * <i>native declaration : xcb/xproto.h:8360</i>
	 */
	int xcb_alloc_color_planes_pixels_length(xcb_alloc_color_planes_reply_t R);
	/**
	 * Original signature : <code>xcb_generic_iterator_t xcb_alloc_color_planes_pixels_end(const xcb_alloc_color_planes_reply_t*)</code><br>
	 * @param R <<br>
	 * <i>native declaration : xcb/xproto.h:8365</i>
	 */
	xcb.xcb_generic_iterator_t.ByValue xcb_alloc_color_planes_pixels_end(xcb_alloc_color_planes_reply_t R);
	/**
	 * Return the reply<br>
	 * @param c      The connection<br>
	 * @param cookie The cookie<br>
	 * @param e      The xcb_generic_error_t supplied<br>
	 * Returns the reply of the request asked by<br>
	 * The parameter @p e supplied to this function must be NULL if<br>
	 * xcb_alloc_color_planes_unchecked(). is used.<br>
	 * Otherwise, it stores the error if any.<br>
	 * The returned value must be freed by the caller using free().<br>
	 * Original signature : <code>xcb_alloc_color_planes_reply_t* xcb_alloc_color_planes_reply(xcb_connection_t*, xcb_alloc_color_planes_cookie_t, xcb_generic_error_t**)</code><br>
	 * @param c <<br>
	 * @param cookie <<br>
	 * @param e <<br>
	 * <i>native declaration : xcb/xproto.h:8381</i><br>
	 * @deprecated use the safer method {@link #xcb_alloc_color_planes_reply(com.sun.jna.ptr.PointerByReference, xcb.xcb_alloc_color_planes_cookie_t.ByValue, xcb.xcb_generic_error_t.ByReference[])} instead
	 */
	@Deprecated 
	xcb_alloc_color_planes_reply_t xcb_alloc_color_planes_reply(Pointer c, xcb.xcb_alloc_color_planes_cookie_t.ByValue cookie, PointerByReference e);
	/**
	 * Return the reply<br>
	 * @param c      The connection<br>
	 * @param cookie The cookie<br>
	 * @param e      The xcb_generic_error_t supplied<br>
	 * Returns the reply of the request asked by<br>
	 * The parameter @p e supplied to this function must be NULL if<br>
	 * xcb_alloc_color_planes_unchecked(). is used.<br>
	 * Otherwise, it stores the error if any.<br>
	 * The returned value must be freed by the caller using free().<br>
	 * Original signature : <code>xcb_alloc_color_planes_reply_t* xcb_alloc_color_planes_reply(xcb_connection_t*, xcb_alloc_color_planes_cookie_t, xcb_generic_error_t**)</code><br>
	 * @param c <<br>
	 * @param cookie <<br>
	 * @param e <<br>
	 * <i>native declaration : xcb/xproto.h:8381</i>
	 */
	xcb_alloc_color_planes_reply_t xcb_alloc_color_planes_reply(PointerByReference c, xcb.xcb_alloc_color_planes_cookie_t.ByValue cookie, xcb_generic_error_t.ByReference e[]);
	/**
	 * Original signature : <code>int xcb_free_colors_sizeof(const void*, uint32_t)</code><br>
	 * @param _buffer <<br>
	 * @param pixels_len <<br>
	 * <i>native declaration : xcb/xproto.h:8387</i>
	 */
	int xcb_free_colors_sizeof(Pointer _buffer, int pixels_len);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_free_colors_checked(xcb_connection_t*, xcb_colormap_t, uint32_t, uint32_t, const uint32_t*)</code><br>
	 * @param c <<br>
	 * @param cmap <<br>
	 * @param plane_mask <<br>
	 * @param pixels_len <<br>
	 * @param pixels <<br>
	 * <i>native declaration : xcb/xproto.h:8402</i><br>
	 * @deprecated use the safer methods {@link #xcb_free_colors_checked(com.sun.jna.ptr.PointerByReference, int, int, int, int[])} and {@link #xcb_free_colors_checked(com.sun.jna.ptr.PointerByReference, int, int, int, com.sun.jna.ptr.IntByReference)} instead
	 */
	@Deprecated 
	xcb.xcb_void_cookie_t.ByValue xcb_free_colors_checked(Pointer c, int cmap, int plane_mask, int pixels_len, IntByReference pixels);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_free_colors_checked(xcb_connection_t*, xcb_colormap_t, uint32_t, uint32_t, const uint32_t*)</code><br>
	 * @param c <<br>
	 * @param cmap <<br>
	 * @param plane_mask <<br>
	 * @param pixels_len <<br>
	 * @param pixels <<br>
	 * <i>native declaration : xcb/xproto.h:8402</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_free_colors_checked(PointerByReference c, int cmap, int plane_mask, int pixels_len, int pixels[]);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_free_colors_checked(xcb_connection_t*, xcb_colormap_t, uint32_t, uint32_t, const uint32_t*)</code><br>
	 * @param c <<br>
	 * @param cmap <<br>
	 * @param plane_mask <<br>
	 * @param pixels_len <<br>
	 * @param pixels <<br>
	 * <i>native declaration : xcb/xproto.h:8402</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_free_colors_checked(PointerByReference c, int cmap, int plane_mask, int pixels_len, IntByReference pixels);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_free_colors(xcb_connection_t*, xcb_colormap_t, uint32_t, uint32_t, const uint32_t*)</code><br>
	 * @param c <<br>
	 * @param cmap <<br>
	 * @param plane_mask <<br>
	 * @param pixels_len <<br>
	 * @param pixels <<br>
	 * <i>native declaration : xcb/xproto.h:8414</i><br>
	 * @deprecated use the safer methods {@link #xcb_free_colors(com.sun.jna.ptr.PointerByReference, int, int, int, int[])} and {@link #xcb_free_colors(com.sun.jna.ptr.PointerByReference, int, int, int, com.sun.jna.ptr.IntByReference)} instead
	 */
	@Deprecated 
	xcb.xcb_void_cookie_t.ByValue xcb_free_colors(Pointer c, int cmap, int plane_mask, int pixels_len, IntByReference pixels);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_free_colors(xcb_connection_t*, xcb_colormap_t, uint32_t, uint32_t, const uint32_t*)</code><br>
	 * @param c <<br>
	 * @param cmap <<br>
	 * @param plane_mask <<br>
	 * @param pixels_len <<br>
	 * @param pixels <<br>
	 * <i>native declaration : xcb/xproto.h:8414</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_free_colors(PointerByReference c, int cmap, int plane_mask, int pixels_len, int pixels[]);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_free_colors(xcb_connection_t*, xcb_colormap_t, uint32_t, uint32_t, const uint32_t*)</code><br>
	 * @param c <<br>
	 * @param cmap <<br>
	 * @param plane_mask <<br>
	 * @param pixels_len <<br>
	 * @param pixels <<br>
	 * <i>native declaration : xcb/xproto.h:8414</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_free_colors(PointerByReference c, int cmap, int plane_mask, int pixels_len, IntByReference pixels);
	/**
	 * Get the next element of the iterator<br>
	 * @param i Pointer to a xcb_coloritem_iterator_t<br>
	 * Get the next element in the iterator. The member rem is<br>
	 * decreased by one. The member data points to the next<br>
	 * element. The member index is increased by sizeof(xcb_coloritem_t)<br>
	 * Original signature : <code>void xcb_coloritem_next(xcb_coloritem_iterator_t*)</code><br>
	 * @param i <<br>
	 * <i>native declaration : xcb/xproto.h:8424</i>
	 */
	void xcb_coloritem_next(xcb_coloritem_iterator_t i);
	/**
	 * Return the iterator pointing to the last element<br>
	 * @param i An xcb_coloritem_iterator_t<br>
	 * @return  The iterator pointing to the last element<br>
	 * Set the current element in the iterator to the last element.<br>
	 * The member rem is set to 0. The member data points to the<br>
	 * last element.<br>
	 * Original signature : <code>xcb_generic_iterator_t xcb_coloritem_end(xcb_coloritem_iterator_t)</code><br>
	 * @param i <<br>
	 * <i>native declaration : xcb/xproto.h:8435</i>
	 */
	xcb.xcb_generic_iterator_t.ByValue xcb_coloritem_end(xcb_coloritem_iterator_t.ByValue i);
	/**
	 * Original signature : <code>int xcb_store_colors_sizeof(const void*, uint32_t)</code><br>
	 * @param _buffer <<br>
	 * @param items_len <<br>
	 * <i>native declaration : xcb/xproto.h:8441</i>
	 */
	int xcb_store_colors_sizeof(Pointer _buffer, int items_len);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_store_colors_checked(xcb_connection_t*, xcb_colormap_t, uint32_t, const xcb_coloritem_t*)</code><br>
	 * @param c <<br>
	 * @param cmap <<br>
	 * @param items_len <<br>
	 * @param items <<br>
	 * <i>native declaration : xcb/xproto.h:8455</i><br>
	 * @deprecated use the safer method {@link #xcb_store_colors_checked(com.sun.jna.ptr.PointerByReference, int, int, xcb.xcb_coloritem_t)} instead
	 */
	@Deprecated 
	xcb.xcb_void_cookie_t.ByValue xcb_store_colors_checked(Pointer c, int cmap, int items_len, xcb_coloritem_t items);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_store_colors_checked(xcb_connection_t*, xcb_colormap_t, uint32_t, const xcb_coloritem_t*)</code><br>
	 * @param c <<br>
	 * @param cmap <<br>
	 * @param items_len <<br>
	 * @param items <<br>
	 * <i>native declaration : xcb/xproto.h:8455</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_store_colors_checked(PointerByReference c, int cmap, int items_len, xcb_coloritem_t items);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_store_colors(xcb_connection_t*, xcb_colormap_t, uint32_t, const xcb_coloritem_t*)</code><br>
	 * @param c <<br>
	 * @param cmap <<br>
	 * @param items_len <<br>
	 * @param items <<br>
	 * <i>native declaration : xcb/xproto.h:8466</i><br>
	 * @deprecated use the safer method {@link #xcb_store_colors(com.sun.jna.ptr.PointerByReference, int, int, xcb.xcb_coloritem_t)} instead
	 */
	@Deprecated 
	xcb.xcb_void_cookie_t.ByValue xcb_store_colors(Pointer c, int cmap, int items_len, xcb_coloritem_t items);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_store_colors(xcb_connection_t*, xcb_colormap_t, uint32_t, const xcb_coloritem_t*)</code><br>
	 * @param c <<br>
	 * @param cmap <<br>
	 * @param items_len <<br>
	 * @param items <<br>
	 * <i>native declaration : xcb/xproto.h:8466</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_store_colors(PointerByReference c, int cmap, int items_len, xcb_coloritem_t items);
	/**
	 * Original signature : <code>int xcb_store_named_color_sizeof(const void*)</code><br>
	 * @param _buffer <<br>
	 * <i>native declaration : xcb/xproto.h:8471</i>
	 */
	int xcb_store_named_color_sizeof(Pointer _buffer);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_store_named_color_checked(xcb_connection_t*, uint8_t, xcb_colormap_t, uint32_t, uint16_t, const char*)</code><br>
	 * @param c <<br>
	 * @param flags <<br>
	 * @param cmap <<br>
	 * @param pixel <<br>
	 * @param name_len <<br>
	 * @param name <<br>
	 * <i>native declaration : xcb/xproto.h:8487</i><br>
	 * @deprecated use the safer methods {@link #xcb_store_named_color_checked(com.sun.jna.ptr.PointerByReference, byte, int, int, short, java.lang.String)} and {@link #xcb_store_named_color_checked(com.sun.jna.ptr.PointerByReference, byte, int, int, short, com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	xcb.xcb_void_cookie_t.ByValue xcb_store_named_color_checked(Pointer c, byte flags, int cmap, int pixel, short name_len, Pointer name);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_store_named_color_checked(xcb_connection_t*, uint8_t, xcb_colormap_t, uint32_t, uint16_t, const char*)</code><br>
	 * @param c <<br>
	 * @param flags <<br>
	 * @param cmap <<br>
	 * @param pixel <<br>
	 * @param name_len <<br>
	 * @param name <<br>
	 * <i>native declaration : xcb/xproto.h:8487</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_store_named_color_checked(PointerByReference c, byte flags, int cmap, int pixel, short name_len, String name);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_store_named_color_checked(xcb_connection_t*, uint8_t, xcb_colormap_t, uint32_t, uint16_t, const char*)</code><br>
	 * @param c <<br>
	 * @param flags <<br>
	 * @param cmap <<br>
	 * @param pixel <<br>
	 * @param name_len <<br>
	 * @param name <<br>
	 * <i>native declaration : xcb/xproto.h:8487</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_store_named_color_checked(PointerByReference c, byte flags, int cmap, int pixel, short name_len, Pointer name);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_store_named_color(xcb_connection_t*, uint8_t, xcb_colormap_t, uint32_t, uint16_t, const char*)</code><br>
	 * @param c <<br>
	 * @param flags <<br>
	 * @param cmap <<br>
	 * @param pixel <<br>
	 * @param name_len <<br>
	 * @param name <<br>
	 * <i>native declaration : xcb/xproto.h:8500</i><br>
	 * @deprecated use the safer methods {@link #xcb_store_named_color(com.sun.jna.ptr.PointerByReference, byte, int, int, short, java.lang.String)} and {@link #xcb_store_named_color(com.sun.jna.ptr.PointerByReference, byte, int, int, short, com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	xcb.xcb_void_cookie_t.ByValue xcb_store_named_color(Pointer c, byte flags, int cmap, int pixel, short name_len, Pointer name);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_store_named_color(xcb_connection_t*, uint8_t, xcb_colormap_t, uint32_t, uint16_t, const char*)</code><br>
	 * @param c <<br>
	 * @param flags <<br>
	 * @param cmap <<br>
	 * @param pixel <<br>
	 * @param name_len <<br>
	 * @param name <<br>
	 * <i>native declaration : xcb/xproto.h:8500</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_store_named_color(PointerByReference c, byte flags, int cmap, int pixel, short name_len, String name);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_store_named_color(xcb_connection_t*, uint8_t, xcb_colormap_t, uint32_t, uint16_t, const char*)</code><br>
	 * @param c <<br>
	 * @param flags <<br>
	 * @param cmap <<br>
	 * @param pixel <<br>
	 * @param name_len <<br>
	 * @param name <<br>
	 * <i>native declaration : xcb/xproto.h:8500</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_store_named_color(PointerByReference c, byte flags, int cmap, int pixel, short name_len, Pointer name);
	/**
	 * Get the next element of the iterator<br>
	 * @param i Pointer to a xcb_rgb_iterator_t<br>
	 * Get the next element in the iterator. The member rem is<br>
	 * decreased by one. The member data points to the next<br>
	 * element. The member index is increased by sizeof(xcb_rgb_t)<br>
	 * Original signature : <code>void xcb_rgb_next(xcb_rgb_iterator_t*)</code><br>
	 * @param i <<br>
	 * <i>native declaration : xcb/xproto.h:8510</i>
	 */
	void xcb_rgb_next(xcb_rgb_iterator_t i);
	/**
	 * Return the iterator pointing to the last element<br>
	 * @param i An xcb_rgb_iterator_t<br>
	 * @return  The iterator pointing to the last element<br>
	 * Set the current element in the iterator to the last element.<br>
	 * The member rem is set to 0. The member data points to the<br>
	 * last element.<br>
	 * Original signature : <code>xcb_generic_iterator_t xcb_rgb_end(xcb_rgb_iterator_t)</code><br>
	 * @param i <<br>
	 * <i>native declaration : xcb/xproto.h:8521</i>
	 */
	xcb.xcb_generic_iterator_t.ByValue xcb_rgb_end(xcb_rgb_iterator_t.ByValue i);
	/**
	 * Original signature : <code>int xcb_query_colors_sizeof(const void*, uint32_t)</code><br>
	 * @param _buffer <<br>
	 * @param pixels_len <<br>
	 * <i>native declaration : xcb/xproto.h:8527</i>
	 */
	int xcb_query_colors_sizeof(Pointer _buffer, int pixels_len);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_query_colors_cookie_t xcb_query_colors(xcb_connection_t*, xcb_colormap_t, uint32_t, const uint32_t*)</code><br>
	 * @param c <<br>
	 * @param cmap <<br>
	 * @param pixels_len <<br>
	 * @param pixels <<br>
	 * <i>native declaration : xcb/xproto.h:8538</i><br>
	 * @deprecated use the safer methods {@link #xcb_query_colors(com.sun.jna.ptr.PointerByReference, int, int, int[])} and {@link #xcb_query_colors(com.sun.jna.ptr.PointerByReference, int, int, com.sun.jna.ptr.IntByReference)} instead
	 */
	@Deprecated 
	xcb.xcb_query_colors_cookie_t.ByValue xcb_query_colors(Pointer c, int cmap, int pixels_len, IntByReference pixels);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_query_colors_cookie_t xcb_query_colors(xcb_connection_t*, xcb_colormap_t, uint32_t, const uint32_t*)</code><br>
	 * @param c <<br>
	 * @param cmap <<br>
	 * @param pixels_len <<br>
	 * @param pixels <<br>
	 * <i>native declaration : xcb/xproto.h:8538</i>
	 */
	xcb.xcb_query_colors_cookie_t.ByValue xcb_query_colors(PointerByReference c, int cmap, int pixels_len, int pixels[]);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_query_colors_cookie_t xcb_query_colors(xcb_connection_t*, xcb_colormap_t, uint32_t, const uint32_t*)</code><br>
	 * @param c <<br>
	 * @param cmap <<br>
	 * @param pixels_len <<br>
	 * @param pixels <<br>
	 * <i>native declaration : xcb/xproto.h:8538</i>
	 */
	xcb.xcb_query_colors_cookie_t.ByValue xcb_query_colors(PointerByReference c, int cmap, int pixels_len, IntByReference pixels);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * placed in the event queue.<br>
	 * Original signature : <code>xcb_query_colors_cookie_t xcb_query_colors_unchecked(xcb_connection_t*, xcb_colormap_t, uint32_t, const uint32_t*)</code><br>
	 * @param c <<br>
	 * @param cmap <<br>
	 * @param pixels_len <<br>
	 * @param pixels <<br>
	 * <i>native declaration : xcb/xproto.h:8552</i><br>
	 * @deprecated use the safer methods {@link #xcb_query_colors_unchecked(com.sun.jna.ptr.PointerByReference, int, int, int[])} and {@link #xcb_query_colors_unchecked(com.sun.jna.ptr.PointerByReference, int, int, com.sun.jna.ptr.IntByReference)} instead
	 */
	@Deprecated 
	xcb.xcb_query_colors_cookie_t.ByValue xcb_query_colors_unchecked(Pointer c, int cmap, int pixels_len, IntByReference pixels);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * placed in the event queue.<br>
	 * Original signature : <code>xcb_query_colors_cookie_t xcb_query_colors_unchecked(xcb_connection_t*, xcb_colormap_t, uint32_t, const uint32_t*)</code><br>
	 * @param c <<br>
	 * @param cmap <<br>
	 * @param pixels_len <<br>
	 * @param pixels <<br>
	 * <i>native declaration : xcb/xproto.h:8552</i>
	 */
	xcb.xcb_query_colors_cookie_t.ByValue xcb_query_colors_unchecked(PointerByReference c, int cmap, int pixels_len, int pixels[]);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * placed in the event queue.<br>
	 * Original signature : <code>xcb_query_colors_cookie_t xcb_query_colors_unchecked(xcb_connection_t*, xcb_colormap_t, uint32_t, const uint32_t*)</code><br>
	 * @param c <<br>
	 * @param cmap <<br>
	 * @param pixels_len <<br>
	 * @param pixels <<br>
	 * <i>native declaration : xcb/xproto.h:8552</i>
	 */
	xcb.xcb_query_colors_cookie_t.ByValue xcb_query_colors_unchecked(PointerByReference c, int cmap, int pixels_len, IntByReference pixels);
	/**
	 * Original signature : <code>xcb_rgb_t* xcb_query_colors_colors(const xcb_query_colors_reply_t*)</code><br>
	 * @param R <<br>
	 * <i>native declaration : xcb/xproto.h:8557</i>
	 */
	xcb_rgb_t xcb_query_colors_colors(xcb_query_colors_reply_t R);
	/**
	 * Original signature : <code>int xcb_query_colors_colors_length(const xcb_query_colors_reply_t*)</code><br>
	 * @param R <<br>
	 * <i>native declaration : xcb/xproto.h:8562</i>
	 */
	int xcb_query_colors_colors_length(xcb_query_colors_reply_t R);
	/**
	 * Original signature : <code>xcb_rgb_iterator_t xcb_query_colors_colors_iterator(const xcb_query_colors_reply_t*)</code><br>
	 * @param R <<br>
	 * <i>native declaration : xcb/xproto.h:8567</i>
	 */
	xcb_rgb_iterator_t.ByValue xcb_query_colors_colors_iterator(xcb_query_colors_reply_t R);
	/**
	 * Return the reply<br>
	 * @param c      The connection<br>
	 * @param cookie The cookie<br>
	 * @param e      The xcb_generic_error_t supplied<br>
	 * Returns the reply of the request asked by<br>
	 * The parameter @p e supplied to this function must be NULL if<br>
	 * xcb_query_colors_unchecked(). is used.<br>
	 * Otherwise, it stores the error if any.<br>
	 * The returned value must be freed by the caller using free().<br>
	 * Original signature : <code>xcb_query_colors_reply_t* xcb_query_colors_reply(xcb_connection_t*, xcb_query_colors_cookie_t, xcb_generic_error_t**)</code><br>
	 * @param c <<br>
	 * @param cookie <<br>
	 * @param e <<br>
	 * <i>native declaration : xcb/xproto.h:8583</i><br>
	 * @deprecated use the safer method {@link #xcb_query_colors_reply(com.sun.jna.ptr.PointerByReference, xcb.xcb_query_colors_cookie_t.ByValue, xcb.xcb_generic_error_t.ByReference[])} instead
	 */
	@Deprecated 
	xcb_query_colors_reply_t xcb_query_colors_reply(Pointer c, xcb.xcb_query_colors_cookie_t.ByValue cookie, PointerByReference e);
	/**
	 * Return the reply<br>
	 * @param c      The connection<br>
	 * @param cookie The cookie<br>
	 * @param e      The xcb_generic_error_t supplied<br>
	 * Returns the reply of the request asked by<br>
	 * The parameter @p e supplied to this function must be NULL if<br>
	 * xcb_query_colors_unchecked(). is used.<br>
	 * Otherwise, it stores the error if any.<br>
	 * The returned value must be freed by the caller using free().<br>
	 * Original signature : <code>xcb_query_colors_reply_t* xcb_query_colors_reply(xcb_connection_t*, xcb_query_colors_cookie_t, xcb_generic_error_t**)</code><br>
	 * @param c <<br>
	 * @param cookie <<br>
	 * @param e <<br>
	 * <i>native declaration : xcb/xproto.h:8583</i>
	 */
	xcb_query_colors_reply_t xcb_query_colors_reply(PointerByReference c, xcb.xcb_query_colors_cookie_t.ByValue cookie, xcb_generic_error_t.ByReference e[]);
	/**
	 * Original signature : <code>int xcb_lookup_color_sizeof(const void*)</code><br>
	 * @param _buffer <<br>
	 * <i>native declaration : xcb/xproto.h:8588</i>
	 */
	int xcb_lookup_color_sizeof(Pointer _buffer);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_lookup_color_cookie_t xcb_lookup_color(xcb_connection_t*, xcb_colormap_t, uint16_t, const char*)</code><br>
	 * @param c <<br>
	 * @param cmap <<br>
	 * @param name_len <<br>
	 * @param name <<br>
	 * <i>native declaration : xcb/xproto.h:8599</i><br>
	 * @deprecated use the safer methods {@link #xcb_lookup_color(com.sun.jna.ptr.PointerByReference, int, short, java.lang.String)} and {@link #xcb_lookup_color(com.sun.jna.ptr.PointerByReference, int, short, com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	xcb.xcb_lookup_color_cookie_t.ByValue xcb_lookup_color(Pointer c, int cmap, short name_len, Pointer name);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_lookup_color_cookie_t xcb_lookup_color(xcb_connection_t*, xcb_colormap_t, uint16_t, const char*)</code><br>
	 * @param c <<br>
	 * @param cmap <<br>
	 * @param name_len <<br>
	 * @param name <<br>
	 * <i>native declaration : xcb/xproto.h:8599</i>
	 */
	xcb.xcb_lookup_color_cookie_t.ByValue xcb_lookup_color(PointerByReference c, int cmap, short name_len, String name);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_lookup_color_cookie_t xcb_lookup_color(xcb_connection_t*, xcb_colormap_t, uint16_t, const char*)</code><br>
	 * @param c <<br>
	 * @param cmap <<br>
	 * @param name_len <<br>
	 * @param name <<br>
	 * <i>native declaration : xcb/xproto.h:8599</i>
	 */
	xcb.xcb_lookup_color_cookie_t.ByValue xcb_lookup_color(PointerByReference c, int cmap, short name_len, Pointer name);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * placed in the event queue.<br>
	 * Original signature : <code>xcb_lookup_color_cookie_t xcb_lookup_color_unchecked(xcb_connection_t*, xcb_colormap_t, uint16_t, const char*)</code><br>
	 * @param c <<br>
	 * @param cmap <<br>
	 * @param name_len <<br>
	 * @param name <<br>
	 * <i>native declaration : xcb/xproto.h:8613</i><br>
	 * @deprecated use the safer methods {@link #xcb_lookup_color_unchecked(com.sun.jna.ptr.PointerByReference, int, short, java.lang.String)} and {@link #xcb_lookup_color_unchecked(com.sun.jna.ptr.PointerByReference, int, short, com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	xcb.xcb_lookup_color_cookie_t.ByValue xcb_lookup_color_unchecked(Pointer c, int cmap, short name_len, Pointer name);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * placed in the event queue.<br>
	 * Original signature : <code>xcb_lookup_color_cookie_t xcb_lookup_color_unchecked(xcb_connection_t*, xcb_colormap_t, uint16_t, const char*)</code><br>
	 * @param c <<br>
	 * @param cmap <<br>
	 * @param name_len <<br>
	 * @param name <<br>
	 * <i>native declaration : xcb/xproto.h:8613</i>
	 */
	xcb.xcb_lookup_color_cookie_t.ByValue xcb_lookup_color_unchecked(PointerByReference c, int cmap, short name_len, String name);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * placed in the event queue.<br>
	 * Original signature : <code>xcb_lookup_color_cookie_t xcb_lookup_color_unchecked(xcb_connection_t*, xcb_colormap_t, uint16_t, const char*)</code><br>
	 * @param c <<br>
	 * @param cmap <<br>
	 * @param name_len <<br>
	 * @param name <<br>
	 * <i>native declaration : xcb/xproto.h:8613</i>
	 */
	xcb.xcb_lookup_color_cookie_t.ByValue xcb_lookup_color_unchecked(PointerByReference c, int cmap, short name_len, Pointer name);
	/**
	 * Return the reply<br>
	 * @param c      The connection<br>
	 * @param cookie The cookie<br>
	 * @param e      The xcb_generic_error_t supplied<br>
	 * Returns the reply of the request asked by<br>
	 * The parameter @p e supplied to this function must be NULL if<br>
	 * xcb_lookup_color_unchecked(). is used.<br>
	 * Otherwise, it stores the error if any.<br>
	 * The returned value must be freed by the caller using free().<br>
	 * Original signature : <code>xcb_lookup_color_reply_t* xcb_lookup_color_reply(xcb_connection_t*, xcb_lookup_color_cookie_t, xcb_generic_error_t**)</code><br>
	 * @param c <<br>
	 * @param cookie <<br>
	 * @param e <<br>
	 * <i>native declaration : xcb/xproto.h:8629</i><br>
	 * @deprecated use the safer method {@link #xcb_lookup_color_reply(com.sun.jna.ptr.PointerByReference, xcb.xcb_lookup_color_cookie_t.ByValue, xcb.xcb_generic_error_t.ByReference[])} instead
	 */
	@Deprecated 
	xcb_lookup_color_reply_t xcb_lookup_color_reply(Pointer c, xcb.xcb_lookup_color_cookie_t.ByValue cookie, PointerByReference e);
	/**
	 * Return the reply<br>
	 * @param c      The connection<br>
	 * @param cookie The cookie<br>
	 * @param e      The xcb_generic_error_t supplied<br>
	 * Returns the reply of the request asked by<br>
	 * The parameter @p e supplied to this function must be NULL if<br>
	 * xcb_lookup_color_unchecked(). is used.<br>
	 * Otherwise, it stores the error if any.<br>
	 * The returned value must be freed by the caller using free().<br>
	 * Original signature : <code>xcb_lookup_color_reply_t* xcb_lookup_color_reply(xcb_connection_t*, xcb_lookup_color_cookie_t, xcb_generic_error_t**)</code><br>
	 * @param c <<br>
	 * @param cookie <<br>
	 * @param e <<br>
	 * <i>native declaration : xcb/xproto.h:8629</i>
	 */
	xcb_lookup_color_reply_t xcb_lookup_color_reply(PointerByReference c, xcb.xcb_lookup_color_cookie_t.ByValue cookie, xcb_generic_error_t.ByReference e[]);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_create_cursor_checked(xcb_connection_t*, xcb_cursor_t, xcb_pixmap_t, xcb_pixmap_t, uint16_t, uint16_t, uint16_t, uint16_t, uint16_t, uint16_t, uint16_t, uint16_t)</code><br>
	 * @param c <<br>
	 * @param cid <<br>
	 * @param source <<br>
	 * @param mask <<br>
	 * @param fore_red <<br>
	 * @param fore_green <<br>
	 * @param fore_blue <<br>
	 * @param back_red <<br>
	 * @param back_green <<br>
	 * @param back_blue <<br>
	 * @param x <<br>
	 * @param y <<br>
	 * <i>native declaration : xcb/xproto.h:8651</i><br>
	 * @deprecated use the safer method {@link #xcb_create_cursor_checked(com.sun.jna.ptr.PointerByReference, int, int, int, short, short, short, short, short, short, short, short)} instead
	 */
	@Deprecated 
	xcb.xcb_void_cookie_t.ByValue xcb_create_cursor_checked(Pointer c, int cid, int source, int mask, short fore_red, short fore_green, short fore_blue, short back_red, short back_green, short back_blue, short x, short y);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_create_cursor_checked(xcb_connection_t*, xcb_cursor_t, xcb_pixmap_t, xcb_pixmap_t, uint16_t, uint16_t, uint16_t, uint16_t, uint16_t, uint16_t, uint16_t, uint16_t)</code><br>
	 * @param c <<br>
	 * @param cid <<br>
	 * @param source <<br>
	 * @param mask <<br>
	 * @param fore_red <<br>
	 * @param fore_green <<br>
	 * @param fore_blue <<br>
	 * @param back_red <<br>
	 * @param back_green <<br>
	 * @param back_blue <<br>
	 * @param x <<br>
	 * @param y <<br>
	 * <i>native declaration : xcb/xproto.h:8651</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_create_cursor_checked(PointerByReference c, int cid, int source, int mask, short fore_red, short fore_green, short fore_blue, short back_red, short back_green, short back_blue, short x, short y);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_create_cursor(xcb_connection_t*, xcb_cursor_t, xcb_pixmap_t, xcb_pixmap_t, uint16_t, uint16_t, uint16_t, uint16_t, uint16_t, uint16_t, uint16_t, uint16_t)</code><br>
	 * @param c <<br>
	 * @param cid <<br>
	 * @param source <<br>
	 * @param mask <<br>
	 * @param fore_red <<br>
	 * @param fore_green <<br>
	 * @param fore_blue <<br>
	 * @param back_red <<br>
	 * @param back_green <<br>
	 * @param back_blue <<br>
	 * @param x <<br>
	 * @param y <<br>
	 * <i>native declaration : xcb/xproto.h:8670</i><br>
	 * @deprecated use the safer method {@link #xcb_create_cursor(com.sun.jna.ptr.PointerByReference, int, int, int, short, short, short, short, short, short, short, short)} instead
	 */
	@Deprecated 
	xcb.xcb_void_cookie_t.ByValue xcb_create_cursor(Pointer c, int cid, int source, int mask, short fore_red, short fore_green, short fore_blue, short back_red, short back_green, short back_blue, short x, short y);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_create_cursor(xcb_connection_t*, xcb_cursor_t, xcb_pixmap_t, xcb_pixmap_t, uint16_t, uint16_t, uint16_t, uint16_t, uint16_t, uint16_t, uint16_t, uint16_t)</code><br>
	 * @param c <<br>
	 * @param cid <<br>
	 * @param source <<br>
	 * @param mask <<br>
	 * @param fore_red <<br>
	 * @param fore_green <<br>
	 * @param fore_blue <<br>
	 * @param back_red <<br>
	 * @param back_green <<br>
	 * @param back_blue <<br>
	 * @param x <<br>
	 * @param y <<br>
	 * <i>native declaration : xcb/xproto.h:8670</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_create_cursor(PointerByReference c, int cid, int source, int mask, short fore_red, short fore_green, short fore_blue, short back_red, short back_green, short back_blue, short x, short y);
	/**
	 * @brief create cursor<br>
	 * @param c The connection<br>
	 * @param cid The ID with which you will refer to the cursor, created by `xcb_generate_id`.<br>
	 * @param source_font In which font to look for the cursor glyph.<br>
	 * @param mask_font In which font to look for the mask glyph.<br>
	 * @param source_char The glyph of \a source_font to use.<br>
	 * @param mask_char The glyph of \a mask_font to use as a mask: Pixels which are set to 1 define<br>
	 * which source pixels are displayed. All pixels which are set to 0 are not<br>
	 * displayed.<br>
	 * @param fore_red The red value of the foreground color.<br>
	 * @param fore_green The green value of the foreground color.<br>
	 * @param fore_blue The blue value of the foreground color.<br>
	 * @param back_red The red value of the background color.<br>
	 * @param back_green The green value of the background color.<br>
	 * @param back_blue The blue value of the background color.<br>
	 * @return A cookie<br>
	 * Creates a cursor from a font glyph. X provides a set of standard cursor shapes<br>
	 * in a special font named cursor. Applications are encouraged to use this<br>
	 * interface for their cursors because the font can be customized for the<br>
	 * individual display type.<br>
	 * <br>
	 * All pixels which are set to 1 in the source will use the foreground color (as<br>
	 * specified by \a fore_red, \a fore_green and \a fore_blue). All pixels set to 0<br>
	 * will use the background color (as specified by \a back_red, \a back_green and<br>
	 * \a back_blue).<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_create_glyph_cursor_checked(xcb_connection_t*, xcb_cursor_t, xcb_font_t, xcb_font_t, uint16_t, uint16_t, uint16_t, uint16_t, uint16_t, uint16_t, uint16_t, uint16_t)</code><br>
	 * @param c <<br>
	 * @param cid <<br>
	 * @param source_font <<br>
	 * @param mask_font <<br>
	 * @param source_char <<br>
	 * @param mask_char <<br>
	 * @param fore_red <<br>
	 * @param fore_green <<br>
	 * @param fore_blue <<br>
	 * @param back_red <<br>
	 * @param back_green <<br>
	 * @param back_blue <<br>
	 * <i>native declaration : xcb/xproto.h:8714</i><br>
	 * @deprecated use the safer method {@link #xcb_create_glyph_cursor_checked(com.sun.jna.ptr.PointerByReference, int, int, int, short, short, short, short, short, short, short, short)} instead
	 */
	@Deprecated 
	xcb.xcb_void_cookie_t.ByValue xcb_create_glyph_cursor_checked(Pointer c, int cid, int source_font, int mask_font, short source_char, short mask_char, short fore_red, short fore_green, short fore_blue, short back_red, short back_green, short back_blue);
	/**
	 * @brief create cursor<br>
	 * @param c The connection<br>
	 * @param cid The ID with which you will refer to the cursor, created by `xcb_generate_id`.<br>
	 * @param source_font In which font to look for the cursor glyph.<br>
	 * @param mask_font In which font to look for the mask glyph.<br>
	 * @param source_char The glyph of \a source_font to use.<br>
	 * @param mask_char The glyph of \a mask_font to use as a mask: Pixels which are set to 1 define<br>
	 * which source pixels are displayed. All pixels which are set to 0 are not<br>
	 * displayed.<br>
	 * @param fore_red The red value of the foreground color.<br>
	 * @param fore_green The green value of the foreground color.<br>
	 * @param fore_blue The blue value of the foreground color.<br>
	 * @param back_red The red value of the background color.<br>
	 * @param back_green The green value of the background color.<br>
	 * @param back_blue The blue value of the background color.<br>
	 * @return A cookie<br>
	 * Creates a cursor from a font glyph. X provides a set of standard cursor shapes<br>
	 * in a special font named cursor. Applications are encouraged to use this<br>
	 * interface for their cursors because the font can be customized for the<br>
	 * individual display type.<br>
	 * <br>
	 * All pixels which are set to 1 in the source will use the foreground color (as<br>
	 * specified by \a fore_red, \a fore_green and \a fore_blue). All pixels set to 0<br>
	 * will use the background color (as specified by \a back_red, \a back_green and<br>
	 * \a back_blue).<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_create_glyph_cursor_checked(xcb_connection_t*, xcb_cursor_t, xcb_font_t, xcb_font_t, uint16_t, uint16_t, uint16_t, uint16_t, uint16_t, uint16_t, uint16_t, uint16_t)</code><br>
	 * @param c <<br>
	 * @param cid <<br>
	 * @param source_font <<br>
	 * @param mask_font <<br>
	 * @param source_char <<br>
	 * @param mask_char <<br>
	 * @param fore_red <<br>
	 * @param fore_green <<br>
	 * @param fore_blue <<br>
	 * @param back_red <<br>
	 * @param back_green <<br>
	 * @param back_blue <<br>
	 * <i>native declaration : xcb/xproto.h:8714</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_create_glyph_cursor_checked(PointerByReference c, int cid, int source_font, int mask_font, short source_char, short mask_char, short fore_red, short fore_green, short fore_blue, short back_red, short back_green, short back_blue);
	/**
	 * @brief create cursor<br>
	 * @param c The connection<br>
	 * @param cid The ID with which you will refer to the cursor, created by `xcb_generate_id`.<br>
	 * @param source_font In which font to look for the cursor glyph.<br>
	 * @param mask_font In which font to look for the mask glyph.<br>
	 * @param source_char The glyph of \a source_font to use.<br>
	 * @param mask_char The glyph of \a mask_font to use as a mask: Pixels which are set to 1 define<br>
	 * which source pixels are displayed. All pixels which are set to 0 are not<br>
	 * displayed.<br>
	 * @param fore_red The red value of the foreground color.<br>
	 * @param fore_green The green value of the foreground color.<br>
	 * @param fore_blue The blue value of the foreground color.<br>
	 * @param back_red The red value of the background color.<br>
	 * @param back_green The green value of the background color.<br>
	 * @param back_blue The blue value of the background color.<br>
	 * @return A cookie<br>
	 * Creates a cursor from a font glyph. X provides a set of standard cursor shapes<br>
	 * in a special font named cursor. Applications are encouraged to use this<br>
	 * interface for their cursors because the font can be customized for the<br>
	 * individual display type.<br>
	 * <br>
	 * All pixels which are set to 1 in the source will use the foreground color (as<br>
	 * specified by \a fore_red, \a fore_green and \a fore_blue). All pixels set to 0<br>
	 * will use the background color (as specified by \a back_red, \a back_green and<br>
	 * \a back_blue).<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_create_glyph_cursor(xcb_connection_t*, xcb_cursor_t, xcb_font_t, xcb_font_t, uint16_t, uint16_t, uint16_t, uint16_t, uint16_t, uint16_t, uint16_t, uint16_t)</code><br>
	 * @param c <<br>
	 * @param cid <<br>
	 * @param source_font <<br>
	 * @param mask_font <<br>
	 * @param source_char <<br>
	 * @param mask_char <<br>
	 * @param fore_red <<br>
	 * @param fore_green <<br>
	 * @param fore_blue <<br>
	 * @param back_red <<br>
	 * @param back_green <<br>
	 * @param back_blue <<br>
	 * <i>native declaration : xcb/xproto.h:8755</i><br>
	 * @deprecated use the safer method {@link #xcb_create_glyph_cursor(com.sun.jna.ptr.PointerByReference, int, int, int, short, short, short, short, short, short, short, short)} instead
	 */
	@Deprecated 
	xcb.xcb_void_cookie_t.ByValue xcb_create_glyph_cursor(Pointer c, int cid, int source_font, int mask_font, short source_char, short mask_char, short fore_red, short fore_green, short fore_blue, short back_red, short back_green, short back_blue);
	/**
	 * @brief create cursor<br>
	 * @param c The connection<br>
	 * @param cid The ID with which you will refer to the cursor, created by `xcb_generate_id`.<br>
	 * @param source_font In which font to look for the cursor glyph.<br>
	 * @param mask_font In which font to look for the mask glyph.<br>
	 * @param source_char The glyph of \a source_font to use.<br>
	 * @param mask_char The glyph of \a mask_font to use as a mask: Pixels which are set to 1 define<br>
	 * which source pixels are displayed. All pixels which are set to 0 are not<br>
	 * displayed.<br>
	 * @param fore_red The red value of the foreground color.<br>
	 * @param fore_green The green value of the foreground color.<br>
	 * @param fore_blue The blue value of the foreground color.<br>
	 * @param back_red The red value of the background color.<br>
	 * @param back_green The green value of the background color.<br>
	 * @param back_blue The blue value of the background color.<br>
	 * @return A cookie<br>
	 * Creates a cursor from a font glyph. X provides a set of standard cursor shapes<br>
	 * in a special font named cursor. Applications are encouraged to use this<br>
	 * interface for their cursors because the font can be customized for the<br>
	 * individual display type.<br>
	 * <br>
	 * All pixels which are set to 1 in the source will use the foreground color (as<br>
	 * specified by \a fore_red, \a fore_green and \a fore_blue). All pixels set to 0<br>
	 * will use the background color (as specified by \a back_red, \a back_green and<br>
	 * \a back_blue).<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_create_glyph_cursor(xcb_connection_t*, xcb_cursor_t, xcb_font_t, xcb_font_t, uint16_t, uint16_t, uint16_t, uint16_t, uint16_t, uint16_t, uint16_t, uint16_t)</code><br>
	 * @param c <<br>
	 * @param cid <<br>
	 * @param source_font <<br>
	 * @param mask_font <<br>
	 * @param source_char <<br>
	 * @param mask_char <<br>
	 * @param fore_red <<br>
	 * @param fore_green <<br>
	 * @param fore_blue <<br>
	 * @param back_red <<br>
	 * @param back_green <<br>
	 * @param back_blue <<br>
	 * <i>native declaration : xcb/xproto.h:8755</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_create_glyph_cursor(PointerByReference c, int cid, int source_font, int mask_font, short source_char, short mask_char, short fore_red, short fore_green, short fore_blue, short back_red, short back_green, short back_blue);
	/**
	 * @brief Deletes a cursor<br>
	 * @param c The connection<br>
	 * @param cursor The cursor to destroy.<br>
	 * @return A cookie<br>
	 * Deletes the association between the cursor resource ID and the specified<br>
	 * cursor. The cursor is freed when no other resource references it.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_free_cursor_checked(xcb_connection_t*, xcb_cursor_t)</code><br>
	 * @param c <<br>
	 * @param cursor <<br>
	 * <i>native declaration : xcb/xproto.h:8770</i><br>
	 * @deprecated use the safer method {@link #xcb_free_cursor_checked(com.sun.jna.ptr.PointerByReference, int)} instead
	 */
	@Deprecated 
	xcb.xcb_void_cookie_t.ByValue xcb_free_cursor_checked(Pointer c, int cursor);
	/**
	 * @brief Deletes a cursor<br>
	 * @param c The connection<br>
	 * @param cursor The cursor to destroy.<br>
	 * @return A cookie<br>
	 * Deletes the association between the cursor resource ID and the specified<br>
	 * cursor. The cursor is freed when no other resource references it.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_free_cursor_checked(xcb_connection_t*, xcb_cursor_t)</code><br>
	 * @param c <<br>
	 * @param cursor <<br>
	 * <i>native declaration : xcb/xproto.h:8770</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_free_cursor_checked(PointerByReference c, int cursor);
	/**
	 * @brief Deletes a cursor<br>
	 * @param c The connection<br>
	 * @param cursor The cursor to destroy.<br>
	 * @return A cookie<br>
	 * Deletes the association between the cursor resource ID and the specified<br>
	 * cursor. The cursor is freed when no other resource references it.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_free_cursor(xcb_connection_t*, xcb_cursor_t)</code><br>
	 * @param c <<br>
	 * @param cursor <<br>
	 * <i>native declaration : xcb/xproto.h:8782</i><br>
	 * @deprecated use the safer method {@link #xcb_free_cursor(com.sun.jna.ptr.PointerByReference, int)} instead
	 */
	@Deprecated 
	xcb.xcb_void_cookie_t.ByValue xcb_free_cursor(Pointer c, int cursor);
	/**
	 * @brief Deletes a cursor<br>
	 * @param c The connection<br>
	 * @param cursor The cursor to destroy.<br>
	 * @return A cookie<br>
	 * Deletes the association between the cursor resource ID and the specified<br>
	 * cursor. The cursor is freed when no other resource references it.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_free_cursor(xcb_connection_t*, xcb_cursor_t)</code><br>
	 * @param c <<br>
	 * @param cursor <<br>
	 * <i>native declaration : xcb/xproto.h:8782</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_free_cursor(PointerByReference c, int cursor);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_recolor_cursor_checked(xcb_connection_t*, xcb_cursor_t, uint16_t, uint16_t, uint16_t, uint16_t, uint16_t, uint16_t)</code><br>
	 * @param c <<br>
	 * @param cursor <<br>
	 * @param fore_red <<br>
	 * @param fore_green <<br>
	 * @param fore_blue <<br>
	 * @param back_red <<br>
	 * @param back_green <<br>
	 * @param back_blue <<br>
	 * <i>native declaration : xcb/xproto.h:8800</i><br>
	 * @deprecated use the safer method {@link #xcb_recolor_cursor_checked(com.sun.jna.ptr.PointerByReference, int, short, short, short, short, short, short)} instead
	 */
	@Deprecated 
	xcb.xcb_void_cookie_t.ByValue xcb_recolor_cursor_checked(Pointer c, int cursor, short fore_red, short fore_green, short fore_blue, short back_red, short back_green, short back_blue);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_recolor_cursor_checked(xcb_connection_t*, xcb_cursor_t, uint16_t, uint16_t, uint16_t, uint16_t, uint16_t, uint16_t)</code><br>
	 * @param c <<br>
	 * @param cursor <<br>
	 * @param fore_red <<br>
	 * @param fore_green <<br>
	 * @param fore_blue <<br>
	 * @param back_red <<br>
	 * @param back_green <<br>
	 * @param back_blue <<br>
	 * <i>native declaration : xcb/xproto.h:8800</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_recolor_cursor_checked(PointerByReference c, int cursor, short fore_red, short fore_green, short fore_blue, short back_red, short back_green, short back_blue);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_recolor_cursor(xcb_connection_t*, xcb_cursor_t, uint16_t, uint16_t, uint16_t, uint16_t, uint16_t, uint16_t)</code><br>
	 * @param c <<br>
	 * @param cursor <<br>
	 * @param fore_red <<br>
	 * @param fore_green <<br>
	 * @param fore_blue <<br>
	 * @param back_red <<br>
	 * @param back_green <<br>
	 * @param back_blue <<br>
	 * <i>native declaration : xcb/xproto.h:8815</i><br>
	 * @deprecated use the safer method {@link #xcb_recolor_cursor(com.sun.jna.ptr.PointerByReference, int, short, short, short, short, short, short)} instead
	 */
	@Deprecated 
	xcb.xcb_void_cookie_t.ByValue xcb_recolor_cursor(Pointer c, int cursor, short fore_red, short fore_green, short fore_blue, short back_red, short back_green, short back_blue);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_recolor_cursor(xcb_connection_t*, xcb_cursor_t, uint16_t, uint16_t, uint16_t, uint16_t, uint16_t, uint16_t)</code><br>
	 * @param c <<br>
	 * @param cursor <<br>
	 * @param fore_red <<br>
	 * @param fore_green <<br>
	 * @param fore_blue <<br>
	 * @param back_red <<br>
	 * @param back_green <<br>
	 * @param back_blue <<br>
	 * <i>native declaration : xcb/xproto.h:8815</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_recolor_cursor(PointerByReference c, int cursor, short fore_red, short fore_green, short fore_blue, short back_red, short back_green, short back_blue);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_query_best_size_cookie_t xcb_query_best_size(xcb_connection_t*, uint8_t, xcb_drawable_t, uint16_t, uint16_t)</code><br>
	 * @param c <<br>
	 * @param _class <<br>
	 * @param drawable <<br>
	 * @param width <<br>
	 * @param height <<br>
	 * <i>native declaration : xcb/xproto.h:8827</i><br>
	 * @deprecated use the safer method {@link #xcb_query_best_size(com.sun.jna.ptr.PointerByReference, byte, int, short, short)} instead
	 */
	@Deprecated 
	xcb.xcb_query_best_size_cookie_t.ByValue xcb_query_best_size(Pointer c, byte _class, int drawable, short width, short height);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_query_best_size_cookie_t xcb_query_best_size(xcb_connection_t*, uint8_t, xcb_drawable_t, uint16_t, uint16_t)</code><br>
	 * @param c <<br>
	 * @param _class <<br>
	 * @param drawable <<br>
	 * @param width <<br>
	 * @param height <<br>
	 * <i>native declaration : xcb/xproto.h:8827</i>
	 */
	xcb.xcb_query_best_size_cookie_t.ByValue xcb_query_best_size(PointerByReference c, byte _class, int drawable, short width, short height);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * placed in the event queue.<br>
	 * Original signature : <code>xcb_query_best_size_cookie_t xcb_query_best_size_unchecked(xcb_connection_t*, uint8_t, xcb_drawable_t, uint16_t, uint16_t)</code><br>
	 * @param c <<br>
	 * @param _class <<br>
	 * @param drawable <<br>
	 * @param width <<br>
	 * @param height <<br>
	 * <i>native declaration : xcb/xproto.h:8842</i><br>
	 * @deprecated use the safer method {@link #xcb_query_best_size_unchecked(com.sun.jna.ptr.PointerByReference, byte, int, short, short)} instead
	 */
	@Deprecated 
	xcb.xcb_query_best_size_cookie_t.ByValue xcb_query_best_size_unchecked(Pointer c, byte _class, int drawable, short width, short height);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * placed in the event queue.<br>
	 * Original signature : <code>xcb_query_best_size_cookie_t xcb_query_best_size_unchecked(xcb_connection_t*, uint8_t, xcb_drawable_t, uint16_t, uint16_t)</code><br>
	 * @param c <<br>
	 * @param _class <<br>
	 * @param drawable <<br>
	 * @param width <<br>
	 * @param height <<br>
	 * <i>native declaration : xcb/xproto.h:8842</i>
	 */
	xcb.xcb_query_best_size_cookie_t.ByValue xcb_query_best_size_unchecked(PointerByReference c, byte _class, int drawable, short width, short height);
	/**
	 * Return the reply<br>
	 * @param c      The connection<br>
	 * @param cookie The cookie<br>
	 * @param e      The xcb_generic_error_t supplied<br>
	 * Returns the reply of the request asked by<br>
	 * The parameter @p e supplied to this function must be NULL if<br>
	 * xcb_query_best_size_unchecked(). is used.<br>
	 * Otherwise, it stores the error if any.<br>
	 * The returned value must be freed by the caller using free().<br>
	 * Original signature : <code>xcb_query_best_size_reply_t* xcb_query_best_size_reply(xcb_connection_t*, xcb_query_best_size_cookie_t, xcb_generic_error_t**)</code><br>
	 * @param c <<br>
	 * @param cookie <<br>
	 * @param e <<br>
	 * <i>native declaration : xcb/xproto.h:8858</i><br>
	 * @deprecated use the safer method {@link #xcb_query_best_size_reply(com.sun.jna.ptr.PointerByReference, xcb.xcb_query_best_size_cookie_t.ByValue, xcb.xcb_generic_error_t.ByReference[])} instead
	 */
	@Deprecated 
	xcb_query_best_size_reply_t xcb_query_best_size_reply(Pointer c, xcb.xcb_query_best_size_cookie_t.ByValue cookie, PointerByReference e);
	/**
	 * Return the reply<br>
	 * @param c      The connection<br>
	 * @param cookie The cookie<br>
	 * @param e      The xcb_generic_error_t supplied<br>
	 * Returns the reply of the request asked by<br>
	 * The parameter @p e supplied to this function must be NULL if<br>
	 * xcb_query_best_size_unchecked(). is used.<br>
	 * Otherwise, it stores the error if any.<br>
	 * The returned value must be freed by the caller using free().<br>
	 * Original signature : <code>xcb_query_best_size_reply_t* xcb_query_best_size_reply(xcb_connection_t*, xcb_query_best_size_cookie_t, xcb_generic_error_t**)</code><br>
	 * @param c <<br>
	 * @param cookie <<br>
	 * @param e <<br>
	 * <i>native declaration : xcb/xproto.h:8858</i>
	 */
	xcb_query_best_size_reply_t xcb_query_best_size_reply(PointerByReference c, xcb.xcb_query_best_size_cookie_t.ByValue cookie, xcb_generic_error_t.ByReference e[]);
	/**
	 * Original signature : <code>int xcb_query_extension_sizeof(const void*)</code><br>
	 * @param _buffer <<br>
	 * <i>native declaration : xcb/xproto.h:8863</i>
	 */
	int xcb_query_extension_sizeof(Pointer _buffer);
	/**
	 * @brief check if extension is present<br>
	 * @param c The connection<br>
	 * @param name_len The length of \a name in bytes.<br>
	 * @param name The name of the extension to query, for example "RANDR". This is case<br>
	 * sensitive!<br>
	 * @return A cookie<br>
	 * Determines if the specified extension is present on this X11 server.<br>
	 * <br>
	 * Every extension has a unique `major_opcode` to identify requests, the minor<br>
	 * opcodes and request formats are extension-specific. If the extension provides<br>
	 * events and errors, the `first_event` and `first_error` fields in the reply are<br>
	 * set accordingly.<br>
	 * <br>
	 * There should rarely be a need to use this request directly, XCB provides the<br>
	 * `xcb_get_extension_data` function instead.<br>
	 * Original signature : <code>xcb_query_extension_cookie_t xcb_query_extension(xcb_connection_t*, uint16_t, const char*)</code><br>
	 * @param c <<br>
	 * @param name_len <<br>
	 * @param name <<br>
	 * <i>native declaration : xcb/xproto.h:8885</i><br>
	 * @deprecated use the safer methods {@link #xcb_query_extension(com.sun.jna.ptr.PointerByReference, short, java.lang.String)} and {@link #xcb_query_extension(com.sun.jna.ptr.PointerByReference, short, com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	xcb.xcb_query_extension_cookie_t.ByValue xcb_query_extension(Pointer c, short name_len, Pointer name);
	/**
	 * @brief check if extension is present<br>
	 * @param c The connection<br>
	 * @param name_len The length of \a name in bytes.<br>
	 * @param name The name of the extension to query, for example "RANDR". This is case<br>
	 * sensitive!<br>
	 * @return A cookie<br>
	 * Determines if the specified extension is present on this X11 server.<br>
	 * <br>
	 * Every extension has a unique `major_opcode` to identify requests, the minor<br>
	 * opcodes and request formats are extension-specific. If the extension provides<br>
	 * events and errors, the `first_event` and `first_error` fields in the reply are<br>
	 * set accordingly.<br>
	 * <br>
	 * There should rarely be a need to use this request directly, XCB provides the<br>
	 * `xcb_get_extension_data` function instead.<br>
	 * Original signature : <code>xcb_query_extension_cookie_t xcb_query_extension(xcb_connection_t*, uint16_t, const char*)</code><br>
	 * @param c <<br>
	 * @param name_len <<br>
	 * @param name <<br>
	 * <i>native declaration : xcb/xproto.h:8885</i>
	 */
	xcb.xcb_query_extension_cookie_t.ByValue xcb_query_extension(PointerByReference c, short name_len, String name);
	/**
	 * @brief check if extension is present<br>
	 * @param c The connection<br>
	 * @param name_len The length of \a name in bytes.<br>
	 * @param name The name of the extension to query, for example "RANDR". This is case<br>
	 * sensitive!<br>
	 * @return A cookie<br>
	 * Determines if the specified extension is present on this X11 server.<br>
	 * <br>
	 * Every extension has a unique `major_opcode` to identify requests, the minor<br>
	 * opcodes and request formats are extension-specific. If the extension provides<br>
	 * events and errors, the `first_event` and `first_error` fields in the reply are<br>
	 * set accordingly.<br>
	 * <br>
	 * There should rarely be a need to use this request directly, XCB provides the<br>
	 * `xcb_get_extension_data` function instead.<br>
	 * Original signature : <code>xcb_query_extension_cookie_t xcb_query_extension(xcb_connection_t*, uint16_t, const char*)</code><br>
	 * @param c <<br>
	 * @param name_len <<br>
	 * @param name <<br>
	 * <i>native declaration : xcb/xproto.h:8885</i>
	 */
	xcb.xcb_query_extension_cookie_t.ByValue xcb_query_extension(PointerByReference c, short name_len, Pointer name);
	/**
	 * @brief check if extension is present<br>
	 * @param c The connection<br>
	 * @param name_len The length of \a name in bytes.<br>
	 * @param name The name of the extension to query, for example "RANDR". This is case<br>
	 * sensitive!<br>
	 * @return A cookie<br>
	 * Determines if the specified extension is present on this X11 server.<br>
	 * <br>
	 * Every extension has a unique `major_opcode` to identify requests, the minor<br>
	 * opcodes and request formats are extension-specific. If the extension provides<br>
	 * events and errors, the `first_event` and `first_error` fields in the reply are<br>
	 * set accordingly.<br>
	 * <br>
	 * There should rarely be a need to use this request directly, XCB provides the<br>
	 * `xcb_get_extension_data` function instead.<br>
	 * This form can be used only if the request will cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * placed in the event queue.<br>
	 * Original signature : <code>xcb_query_extension_cookie_t xcb_query_extension_unchecked(xcb_connection_t*, uint16_t, const char*)</code><br>
	 * @param c <<br>
	 * @param name_len <<br>
	 * @param name <<br>
	 * <i>native declaration : xcb/xproto.h:8910</i><br>
	 * @deprecated use the safer methods {@link #xcb_query_extension_unchecked(com.sun.jna.ptr.PointerByReference, short, java.lang.String)} and {@link #xcb_query_extension_unchecked(com.sun.jna.ptr.PointerByReference, short, com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	xcb.xcb_query_extension_cookie_t.ByValue xcb_query_extension_unchecked(Pointer c, short name_len, Pointer name);
	/**
	 * @brief check if extension is present<br>
	 * @param c The connection<br>
	 * @param name_len The length of \a name in bytes.<br>
	 * @param name The name of the extension to query, for example "RANDR". This is case<br>
	 * sensitive!<br>
	 * @return A cookie<br>
	 * Determines if the specified extension is present on this X11 server.<br>
	 * <br>
	 * Every extension has a unique `major_opcode` to identify requests, the minor<br>
	 * opcodes and request formats are extension-specific. If the extension provides<br>
	 * events and errors, the `first_event` and `first_error` fields in the reply are<br>
	 * set accordingly.<br>
	 * <br>
	 * There should rarely be a need to use this request directly, XCB provides the<br>
	 * `xcb_get_extension_data` function instead.<br>
	 * This form can be used only if the request will cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * placed in the event queue.<br>
	 * Original signature : <code>xcb_query_extension_cookie_t xcb_query_extension_unchecked(xcb_connection_t*, uint16_t, const char*)</code><br>
	 * @param c <<br>
	 * @param name_len <<br>
	 * @param name <<br>
	 * <i>native declaration : xcb/xproto.h:8910</i>
	 */
	xcb.xcb_query_extension_cookie_t.ByValue xcb_query_extension_unchecked(PointerByReference c, short name_len, String name);
	/**
	 * @brief check if extension is present<br>
	 * @param c The connection<br>
	 * @param name_len The length of \a name in bytes.<br>
	 * @param name The name of the extension to query, for example "RANDR". This is case<br>
	 * sensitive!<br>
	 * @return A cookie<br>
	 * Determines if the specified extension is present on this X11 server.<br>
	 * <br>
	 * Every extension has a unique `major_opcode` to identify requests, the minor<br>
	 * opcodes and request formats are extension-specific. If the extension provides<br>
	 * events and errors, the `first_event` and `first_error` fields in the reply are<br>
	 * set accordingly.<br>
	 * <br>
	 * There should rarely be a need to use this request directly, XCB provides the<br>
	 * `xcb_get_extension_data` function instead.<br>
	 * This form can be used only if the request will cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * placed in the event queue.<br>
	 * Original signature : <code>xcb_query_extension_cookie_t xcb_query_extension_unchecked(xcb_connection_t*, uint16_t, const char*)</code><br>
	 * @param c <<br>
	 * @param name_len <<br>
	 * @param name <<br>
	 * <i>native declaration : xcb/xproto.h:8910</i>
	 */
	xcb.xcb_query_extension_cookie_t.ByValue xcb_query_extension_unchecked(PointerByReference c, short name_len, Pointer name);
	/**
	 * Return the reply<br>
	 * @param c      The connection<br>
	 * @param cookie The cookie<br>
	 * @param e      The xcb_generic_error_t supplied<br>
	 * Returns the reply of the request asked by<br>
	 * The parameter @p e supplied to this function must be NULL if<br>
	 * xcb_query_extension_unchecked(). is used.<br>
	 * Otherwise, it stores the error if any.<br>
	 * The returned value must be freed by the caller using free().<br>
	 * Original signature : <code>xcb_query_extension_reply_t* xcb_query_extension_reply(xcb_connection_t*, xcb_query_extension_cookie_t, xcb_generic_error_t**)</code><br>
	 * @param c <<br>
	 * @param cookie <<br>
	 * @param e <<br>
	 * <i>native declaration : xcb/xproto.h:8926</i><br>
	 * @deprecated use the safer method {@link #xcb_query_extension_reply(com.sun.jna.ptr.PointerByReference, xcb.xcb_query_extension_cookie_t.ByValue, xcb.xcb_generic_error_t.ByReference[])} instead
	 */
	@Deprecated 
	xcb_query_extension_reply_t xcb_query_extension_reply(Pointer c, xcb.xcb_query_extension_cookie_t.ByValue cookie, PointerByReference e);
	/**
	 * Return the reply<br>
	 * @param c      The connection<br>
	 * @param cookie The cookie<br>
	 * @param e      The xcb_generic_error_t supplied<br>
	 * Returns the reply of the request asked by<br>
	 * The parameter @p e supplied to this function must be NULL if<br>
	 * xcb_query_extension_unchecked(). is used.<br>
	 * Otherwise, it stores the error if any.<br>
	 * The returned value must be freed by the caller using free().<br>
	 * Original signature : <code>xcb_query_extension_reply_t* xcb_query_extension_reply(xcb_connection_t*, xcb_query_extension_cookie_t, xcb_generic_error_t**)</code><br>
	 * @param c <<br>
	 * @param cookie <<br>
	 * @param e <<br>
	 * <i>native declaration : xcb/xproto.h:8926</i>
	 */
	xcb_query_extension_reply_t xcb_query_extension_reply(PointerByReference c, xcb.xcb_query_extension_cookie_t.ByValue cookie, xcb_generic_error_t.ByReference e[]);
	/**
	 * Original signature : <code>int xcb_list_extensions_sizeof(const void*)</code><br>
	 * @param _buffer <<br>
	 * <i>native declaration : xcb/xproto.h:8931</i>
	 */
	int xcb_list_extensions_sizeof(Pointer _buffer);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_list_extensions_cookie_t xcb_list_extensions(xcb_connection_t*)</code><br>
	 * @param c <<br>
	 * <i>native declaration : xcb/xproto.h:8939</i><br>
	 * @deprecated use the safer method {@link #xcb_list_extensions(com.sun.jna.ptr.PointerByReference)} instead
	 */
	@Deprecated 
	xcb.xcb_list_extensions_cookie_t.ByValue xcb_list_extensions(Pointer c);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_list_extensions_cookie_t xcb_list_extensions(xcb_connection_t*)</code><br>
	 * @param c <<br>
	 * <i>native declaration : xcb/xproto.h:8939</i>
	 */
	xcb.xcb_list_extensions_cookie_t.ByValue xcb_list_extensions(PointerByReference c);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * placed in the event queue.<br>
	 * Original signature : <code>xcb_list_extensions_cookie_t xcb_list_extensions_unchecked(xcb_connection_t*)</code><br>
	 * @param c <<br>
	 * <i>native declaration : xcb/xproto.h:8950</i><br>
	 * @deprecated use the safer method {@link #xcb_list_extensions_unchecked(com.sun.jna.ptr.PointerByReference)} instead
	 */
	@Deprecated 
	xcb.xcb_list_extensions_cookie_t.ByValue xcb_list_extensions_unchecked(Pointer c);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * placed in the event queue.<br>
	 * Original signature : <code>xcb_list_extensions_cookie_t xcb_list_extensions_unchecked(xcb_connection_t*)</code><br>
	 * @param c <<br>
	 * <i>native declaration : xcb/xproto.h:8950</i>
	 */
	xcb.xcb_list_extensions_cookie_t.ByValue xcb_list_extensions_unchecked(PointerByReference c);
	/**
	 * Original signature : <code>int xcb_list_extensions_names_length(const xcb_list_extensions_reply_t*)</code><br>
	 * @param R <<br>
	 * <i>native declaration : xcb/xproto.h:8955</i>
	 */
	int xcb_list_extensions_names_length(xcb_list_extensions_reply_t R);
	/**
	 * Original signature : <code>xcb_str_iterator_t xcb_list_extensions_names_iterator(const xcb_list_extensions_reply_t*)</code><br>
	 * @param R <<br>
	 * <i>native declaration : xcb/xproto.h:8960</i>
	 */
	xcb_str_iterator_t.ByValue xcb_list_extensions_names_iterator(xcb_list_extensions_reply_t R);
	/**
	 * Return the reply<br>
	 * @param c      The connection<br>
	 * @param cookie The cookie<br>
	 * @param e      The xcb_generic_error_t supplied<br>
	 * Returns the reply of the request asked by<br>
	 * The parameter @p e supplied to this function must be NULL if<br>
	 * xcb_list_extensions_unchecked(). is used.<br>
	 * Otherwise, it stores the error if any.<br>
	 * The returned value must be freed by the caller using free().<br>
	 * Original signature : <code>xcb_list_extensions_reply_t* xcb_list_extensions_reply(xcb_connection_t*, xcb_list_extensions_cookie_t, xcb_generic_error_t**)</code><br>
	 * @param c <<br>
	 * @param cookie <<br>
	 * @param e <<br>
	 * <i>native declaration : xcb/xproto.h:8976</i><br>
	 * @deprecated use the safer method {@link #xcb_list_extensions_reply(com.sun.jna.ptr.PointerByReference, xcb.xcb_list_extensions_cookie_t.ByValue, xcb.xcb_generic_error_t.ByReference[])} instead
	 */
	@Deprecated 
	xcb_list_extensions_reply_t xcb_list_extensions_reply(Pointer c, xcb.xcb_list_extensions_cookie_t.ByValue cookie, PointerByReference e);
	/**
	 * Return the reply<br>
	 * @param c      The connection<br>
	 * @param cookie The cookie<br>
	 * @param e      The xcb_generic_error_t supplied<br>
	 * Returns the reply of the request asked by<br>
	 * The parameter @p e supplied to this function must be NULL if<br>
	 * xcb_list_extensions_unchecked(). is used.<br>
	 * Otherwise, it stores the error if any.<br>
	 * The returned value must be freed by the caller using free().<br>
	 * Original signature : <code>xcb_list_extensions_reply_t* xcb_list_extensions_reply(xcb_connection_t*, xcb_list_extensions_cookie_t, xcb_generic_error_t**)</code><br>
	 * @param c <<br>
	 * @param cookie <<br>
	 * @param e <<br>
	 * <i>native declaration : xcb/xproto.h:8976</i>
	 */
	xcb_list_extensions_reply_t xcb_list_extensions_reply(PointerByReference c, xcb.xcb_list_extensions_cookie_t.ByValue cookie, xcb_generic_error_t.ByReference e[]);
	/**
	 * Original signature : <code>int xcb_change_keyboard_mapping_sizeof(const void*)</code><br>
	 * @param _buffer <<br>
	 * <i>native declaration : xcb/xproto.h:8981</i>
	 */
	int xcb_change_keyboard_mapping_sizeof(Pointer _buffer);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_change_keyboard_mapping_checked(xcb_connection_t*, uint8_t, xcb_keycode_t, uint8_t, const xcb_keysym_t*)</code><br>
	 * @param c <<br>
	 * @param keycode_count <<br>
	 * @param first_keycode <<br>
	 * @param keysyms_per_keycode <<br>
	 * @param keysyms <<br>
	 * <i>native declaration : xcb/xproto.h:8996</i><br>
	 * @deprecated use the safer methods {@link #xcb_change_keyboard_mapping_checked(com.sun.jna.ptr.PointerByReference, byte, byte, byte, java.nio.IntBuffer)} and {@link #xcb_change_keyboard_mapping_checked(com.sun.jna.ptr.PointerByReference, byte, byte, byte, com.sun.jna.ptr.IntByReference)} instead
	 */
	@Deprecated 
	xcb.xcb_void_cookie_t.ByValue xcb_change_keyboard_mapping_checked(Pointer c, byte keycode_count, byte first_keycode, byte keysyms_per_keycode, IntByReference keysyms);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_change_keyboard_mapping_checked(xcb_connection_t*, uint8_t, xcb_keycode_t, uint8_t, const xcb_keysym_t*)</code><br>
	 * @param c <<br>
	 * @param keycode_count <<br>
	 * @param first_keycode <<br>
	 * @param keysyms_per_keycode <<br>
	 * @param keysyms <<br>
	 * <i>native declaration : xcb/xproto.h:8996</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_change_keyboard_mapping_checked(PointerByReference c, byte keycode_count, byte first_keycode, byte keysyms_per_keycode, IntBuffer keysyms);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_change_keyboard_mapping_checked(xcb_connection_t*, uint8_t, xcb_keycode_t, uint8_t, const xcb_keysym_t*)</code><br>
	 * @param c <<br>
	 * @param keycode_count <<br>
	 * @param first_keycode <<br>
	 * @param keysyms_per_keycode <<br>
	 * @param keysyms <<br>
	 * <i>native declaration : xcb/xproto.h:8996</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_change_keyboard_mapping_checked(PointerByReference c, byte keycode_count, byte first_keycode, byte keysyms_per_keycode, IntByReference keysyms);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_change_keyboard_mapping(xcb_connection_t*, uint8_t, xcb_keycode_t, uint8_t, const xcb_keysym_t*)</code><br>
	 * @param c <<br>
	 * @param keycode_count <<br>
	 * @param first_keycode <<br>
	 * @param keysyms_per_keycode <<br>
	 * @param keysyms <<br>
	 * <i>native declaration : xcb/xproto.h:9008</i><br>
	 * @deprecated use the safer methods {@link #xcb_change_keyboard_mapping(com.sun.jna.ptr.PointerByReference, byte, byte, byte, java.nio.IntBuffer)} and {@link #xcb_change_keyboard_mapping(com.sun.jna.ptr.PointerByReference, byte, byte, byte, com.sun.jna.ptr.IntByReference)} instead
	 */
	@Deprecated 
	xcb.xcb_void_cookie_t.ByValue xcb_change_keyboard_mapping(Pointer c, byte keycode_count, byte first_keycode, byte keysyms_per_keycode, IntByReference keysyms);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_change_keyboard_mapping(xcb_connection_t*, uint8_t, xcb_keycode_t, uint8_t, const xcb_keysym_t*)</code><br>
	 * @param c <<br>
	 * @param keycode_count <<br>
	 * @param first_keycode <<br>
	 * @param keysyms_per_keycode <<br>
	 * @param keysyms <<br>
	 * <i>native declaration : xcb/xproto.h:9008</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_change_keyboard_mapping(PointerByReference c, byte keycode_count, byte first_keycode, byte keysyms_per_keycode, IntBuffer keysyms);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_change_keyboard_mapping(xcb_connection_t*, uint8_t, xcb_keycode_t, uint8_t, const xcb_keysym_t*)</code><br>
	 * @param c <<br>
	 * @param keycode_count <<br>
	 * @param first_keycode <<br>
	 * @param keysyms_per_keycode <<br>
	 * @param keysyms <<br>
	 * <i>native declaration : xcb/xproto.h:9008</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_change_keyboard_mapping(PointerByReference c, byte keycode_count, byte first_keycode, byte keysyms_per_keycode, IntByReference keysyms);
	/**
	 * Original signature : <code>int xcb_get_keyboard_mapping_sizeof(const void*)</code><br>
	 * @param _buffer <<br>
	 * <i>native declaration : xcb/xproto.h:9013</i>
	 */
	int xcb_get_keyboard_mapping_sizeof(Pointer _buffer);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_get_keyboard_mapping_cookie_t xcb_get_keyboard_mapping(xcb_connection_t*, xcb_keycode_t, uint8_t)</code><br>
	 * @param c <<br>
	 * @param first_keycode <<br>
	 * @param count <<br>
	 * <i>native declaration : xcb/xproto.h:9023</i><br>
	 * @deprecated use the safer method {@link #xcb_get_keyboard_mapping(com.sun.jna.ptr.PointerByReference, byte, byte)} instead
	 */
	@Deprecated 
	xcb.xcb_get_keyboard_mapping_cookie_t.ByValue xcb_get_keyboard_mapping(Pointer c, byte first_keycode, byte count);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_get_keyboard_mapping_cookie_t xcb_get_keyboard_mapping(xcb_connection_t*, xcb_keycode_t, uint8_t)</code><br>
	 * @param c <<br>
	 * @param first_keycode <<br>
	 * @param count <<br>
	 * <i>native declaration : xcb/xproto.h:9023</i>
	 */
	xcb.xcb_get_keyboard_mapping_cookie_t.ByValue xcb_get_keyboard_mapping(PointerByReference c, byte first_keycode, byte count);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * placed in the event queue.<br>
	 * Original signature : <code>xcb_get_keyboard_mapping_cookie_t xcb_get_keyboard_mapping_unchecked(xcb_connection_t*, xcb_keycode_t, uint8_t)</code><br>
	 * @param c <<br>
	 * @param first_keycode <<br>
	 * @param count <<br>
	 * <i>native declaration : xcb/xproto.h:9036</i><br>
	 * @deprecated use the safer method {@link #xcb_get_keyboard_mapping_unchecked(com.sun.jna.ptr.PointerByReference, byte, byte)} instead
	 */
	@Deprecated 
	xcb.xcb_get_keyboard_mapping_cookie_t.ByValue xcb_get_keyboard_mapping_unchecked(Pointer c, byte first_keycode, byte count);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * placed in the event queue.<br>
	 * Original signature : <code>xcb_get_keyboard_mapping_cookie_t xcb_get_keyboard_mapping_unchecked(xcb_connection_t*, xcb_keycode_t, uint8_t)</code><br>
	 * @param c <<br>
	 * @param first_keycode <<br>
	 * @param count <<br>
	 * <i>native declaration : xcb/xproto.h:9036</i>
	 */
	xcb.xcb_get_keyboard_mapping_cookie_t.ByValue xcb_get_keyboard_mapping_unchecked(PointerByReference c, byte first_keycode, byte count);
	/**
	 * Original signature : <code>xcb_keysym_t* xcb_get_keyboard_mapping_keysyms(const xcb_get_keyboard_mapping_reply_t*)</code><br>
	 * @param R <<br>
	 * <i>native declaration : xcb/xproto.h:9041</i>
	 */
	IntByReference xcb_get_keyboard_mapping_keysyms(xcb_get_keyboard_mapping_reply_t R);
	/**
	 * Original signature : <code>int xcb_get_keyboard_mapping_keysyms_length(const xcb_get_keyboard_mapping_reply_t*)</code><br>
	 * @param R <<br>
	 * <i>native declaration : xcb/xproto.h:9046</i>
	 */
	int xcb_get_keyboard_mapping_keysyms_length(xcb_get_keyboard_mapping_reply_t R);
	/**
	 * Original signature : <code>xcb_generic_iterator_t xcb_get_keyboard_mapping_keysyms_end(const xcb_get_keyboard_mapping_reply_t*)</code><br>
	 * @param R <<br>
	 * <i>native declaration : xcb/xproto.h:9051</i>
	 */
	xcb.xcb_generic_iterator_t.ByValue xcb_get_keyboard_mapping_keysyms_end(xcb_get_keyboard_mapping_reply_t R);
	/**
	 * Return the reply<br>
	 * @param c      The connection<br>
	 * @param cookie The cookie<br>
	 * @param e      The xcb_generic_error_t supplied<br>
	 * Returns the reply of the request asked by<br>
	 * The parameter @p e supplied to this function must be NULL if<br>
	 * xcb_get_keyboard_mapping_unchecked(). is used.<br>
	 * Otherwise, it stores the error if any.<br>
	 * The returned value must be freed by the caller using free().<br>
	 * Original signature : <code>xcb_get_keyboard_mapping_reply_t* xcb_get_keyboard_mapping_reply(xcb_connection_t*, xcb_get_keyboard_mapping_cookie_t, xcb_generic_error_t**)</code><br>
	 * @param c <<br>
	 * @param cookie <<br>
	 * @param e <<br>
	 * <i>native declaration : xcb/xproto.h:9067</i><br>
	 * @deprecated use the safer method {@link #xcb_get_keyboard_mapping_reply(com.sun.jna.ptr.PointerByReference, xcb.xcb_get_keyboard_mapping_cookie_t.ByValue, xcb.xcb_generic_error_t.ByReference[])} instead
	 */
	@Deprecated 
	xcb_get_keyboard_mapping_reply_t xcb_get_keyboard_mapping_reply(Pointer c, xcb.xcb_get_keyboard_mapping_cookie_t.ByValue cookie, PointerByReference e);
	/**
	 * Return the reply<br>
	 * @param c      The connection<br>
	 * @param cookie The cookie<br>
	 * @param e      The xcb_generic_error_t supplied<br>
	 * Returns the reply of the request asked by<br>
	 * The parameter @p e supplied to this function must be NULL if<br>
	 * xcb_get_keyboard_mapping_unchecked(). is used.<br>
	 * Otherwise, it stores the error if any.<br>
	 * The returned value must be freed by the caller using free().<br>
	 * Original signature : <code>xcb_get_keyboard_mapping_reply_t* xcb_get_keyboard_mapping_reply(xcb_connection_t*, xcb_get_keyboard_mapping_cookie_t, xcb_generic_error_t**)</code><br>
	 * @param c <<br>
	 * @param cookie <<br>
	 * @param e <<br>
	 * <i>native declaration : xcb/xproto.h:9067</i>
	 */
	xcb_get_keyboard_mapping_reply_t xcb_get_keyboard_mapping_reply(PointerByReference c, xcb.xcb_get_keyboard_mapping_cookie_t.ByValue cookie, xcb_generic_error_t.ByReference e[]);
	/**
	 * Original signature : <code>int xcb_change_keyboard_control_sizeof(const void*)</code><br>
	 * @param _buffer <<br>
	 * <i>native declaration : xcb/xproto.h:9072</i>
	 */
	int xcb_change_keyboard_control_sizeof(Pointer _buffer);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_change_keyboard_control_checked(xcb_connection_t*, uint32_t, const uint32_t*)</code><br>
	 * @param c <<br>
	 * @param value_mask <<br>
	 * @param value_list <<br>
	 * <i>native declaration : xcb/xproto.h:9085</i><br>
	 * @deprecated use the safer methods {@link #xcb_change_keyboard_control_checked(com.sun.jna.ptr.PointerByReference, int, int[])} and {@link #xcb_change_keyboard_control_checked(com.sun.jna.ptr.PointerByReference, int, com.sun.jna.ptr.IntByReference)} instead
	 */
	@Deprecated 
	xcb.xcb_void_cookie_t.ByValue xcb_change_keyboard_control_checked(Pointer c, int value_mask, IntByReference value_list);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_change_keyboard_control_checked(xcb_connection_t*, uint32_t, const uint32_t*)</code><br>
	 * @param c <<br>
	 * @param value_mask <<br>
	 * @param value_list <<br>
	 * <i>native declaration : xcb/xproto.h:9085</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_change_keyboard_control_checked(PointerByReference c, int value_mask, int value_list[]);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_change_keyboard_control_checked(xcb_connection_t*, uint32_t, const uint32_t*)</code><br>
	 * @param c <<br>
	 * @param value_mask <<br>
	 * @param value_list <<br>
	 * <i>native declaration : xcb/xproto.h:9085</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_change_keyboard_control_checked(PointerByReference c, int value_mask, IntByReference value_list);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_change_keyboard_control(xcb_connection_t*, uint32_t, const uint32_t*)</code><br>
	 * @param c <<br>
	 * @param value_mask <<br>
	 * @param value_list <<br>
	 * <i>native declaration : xcb/xproto.h:9095</i><br>
	 * @deprecated use the safer methods {@link #xcb_change_keyboard_control(com.sun.jna.ptr.PointerByReference, int, int[])} and {@link #xcb_change_keyboard_control(com.sun.jna.ptr.PointerByReference, int, com.sun.jna.ptr.IntByReference)} instead
	 */
	@Deprecated 
	xcb.xcb_void_cookie_t.ByValue xcb_change_keyboard_control(Pointer c, int value_mask, IntByReference value_list);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_change_keyboard_control(xcb_connection_t*, uint32_t, const uint32_t*)</code><br>
	 * @param c <<br>
	 * @param value_mask <<br>
	 * @param value_list <<br>
	 * <i>native declaration : xcb/xproto.h:9095</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_change_keyboard_control(PointerByReference c, int value_mask, int value_list[]);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_change_keyboard_control(xcb_connection_t*, uint32_t, const uint32_t*)</code><br>
	 * @param c <<br>
	 * @param value_mask <<br>
	 * @param value_list <<br>
	 * <i>native declaration : xcb/xproto.h:9095</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_change_keyboard_control(PointerByReference c, int value_mask, IntByReference value_list);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_get_keyboard_control_cookie_t xcb_get_keyboard_control(xcb_connection_t*)</code><br>
	 * @param c <<br>
	 * <i>native declaration : xcb/xproto.h:9103</i><br>
	 * @deprecated use the safer method {@link #xcb_get_keyboard_control(com.sun.jna.ptr.PointerByReference)} instead
	 */
	@Deprecated 
	xcb.xcb_get_keyboard_control_cookie_t.ByValue xcb_get_keyboard_control(Pointer c);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_get_keyboard_control_cookie_t xcb_get_keyboard_control(xcb_connection_t*)</code><br>
	 * @param c <<br>
	 * <i>native declaration : xcb/xproto.h:9103</i>
	 */
	xcb.xcb_get_keyboard_control_cookie_t.ByValue xcb_get_keyboard_control(PointerByReference c);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * placed in the event queue.<br>
	 * Original signature : <code>xcb_get_keyboard_control_cookie_t xcb_get_keyboard_control_unchecked(xcb_connection_t*)</code><br>
	 * @param c <<br>
	 * <i>native declaration : xcb/xproto.h:9114</i><br>
	 * @deprecated use the safer method {@link #xcb_get_keyboard_control_unchecked(com.sun.jna.ptr.PointerByReference)} instead
	 */
	@Deprecated 
	xcb.xcb_get_keyboard_control_cookie_t.ByValue xcb_get_keyboard_control_unchecked(Pointer c);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * placed in the event queue.<br>
	 * Original signature : <code>xcb_get_keyboard_control_cookie_t xcb_get_keyboard_control_unchecked(xcb_connection_t*)</code><br>
	 * @param c <<br>
	 * <i>native declaration : xcb/xproto.h:9114</i>
	 */
	xcb.xcb_get_keyboard_control_cookie_t.ByValue xcb_get_keyboard_control_unchecked(PointerByReference c);
	/**
	 * Return the reply<br>
	 * @param c      The connection<br>
	 * @param cookie The cookie<br>
	 * @param e      The xcb_generic_error_t supplied<br>
	 * Returns the reply of the request asked by<br>
	 * The parameter @p e supplied to this function must be NULL if<br>
	 * xcb_get_keyboard_control_unchecked(). is used.<br>
	 * Otherwise, it stores the error if any.<br>
	 * The returned value must be freed by the caller using free().<br>
	 * Original signature : <code>xcb_get_keyboard_control_reply_t* xcb_get_keyboard_control_reply(xcb_connection_t*, xcb_get_keyboard_control_cookie_t, xcb_generic_error_t**)</code><br>
	 * @param c <<br>
	 * @param cookie <<br>
	 * @param e <<br>
	 * <i>native declaration : xcb/xproto.h:9130</i><br>
	 * @deprecated use the safer method {@link #xcb_get_keyboard_control_reply(com.sun.jna.ptr.PointerByReference, xcb.xcb_get_keyboard_control_cookie_t.ByValue, xcb.xcb_generic_error_t.ByReference[])} instead
	 */
	@Deprecated 
	xcb_get_keyboard_control_reply_t xcb_get_keyboard_control_reply(Pointer c, xcb.xcb_get_keyboard_control_cookie_t.ByValue cookie, PointerByReference e);
	/**
	 * Return the reply<br>
	 * @param c      The connection<br>
	 * @param cookie The cookie<br>
	 * @param e      The xcb_generic_error_t supplied<br>
	 * Returns the reply of the request asked by<br>
	 * The parameter @p e supplied to this function must be NULL if<br>
	 * xcb_get_keyboard_control_unchecked(). is used.<br>
	 * Otherwise, it stores the error if any.<br>
	 * The returned value must be freed by the caller using free().<br>
	 * Original signature : <code>xcb_get_keyboard_control_reply_t* xcb_get_keyboard_control_reply(xcb_connection_t*, xcb_get_keyboard_control_cookie_t, xcb_generic_error_t**)</code><br>
	 * @param c <<br>
	 * @param cookie <<br>
	 * @param e <<br>
	 * <i>native declaration : xcb/xproto.h:9130</i>
	 */
	xcb_get_keyboard_control_reply_t xcb_get_keyboard_control_reply(PointerByReference c, xcb.xcb_get_keyboard_control_cookie_t.ByValue cookie, xcb_generic_error_t.ByReference e[]);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_bell_checked(xcb_connection_t*, int8_t)</code><br>
	 * @param c <<br>
	 * @param percent <<br>
	 * <i>native declaration : xcb/xproto.h:9142</i><br>
	 * @deprecated use the safer method {@link #xcb_bell_checked(com.sun.jna.ptr.PointerByReference, byte)} instead
	 */
	@Deprecated 
	xcb.xcb_void_cookie_t.ByValue xcb_bell_checked(Pointer c, byte percent);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_bell_checked(xcb_connection_t*, int8_t)</code><br>
	 * @param c <<br>
	 * @param percent <<br>
	 * <i>native declaration : xcb/xproto.h:9142</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_bell_checked(PointerByReference c, byte percent);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_bell(xcb_connection_t*, int8_t)</code><br>
	 * @param c <<br>
	 * @param percent <<br>
	 * <i>native declaration : xcb/xproto.h:9151</i><br>
	 * @deprecated use the safer method {@link #xcb_bell(com.sun.jna.ptr.PointerByReference, byte)} instead
	 */
	@Deprecated 
	xcb.xcb_void_cookie_t.ByValue xcb_bell(Pointer c, byte percent);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_bell(xcb_connection_t*, int8_t)</code><br>
	 * @param c <<br>
	 * @param percent <<br>
	 * <i>native declaration : xcb/xproto.h:9151</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_bell(PointerByReference c, byte percent);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_change_pointer_control_checked(xcb_connection_t*, int16_t, int16_t, int16_t, uint8_t, uint8_t)</code><br>
	 * @param c <<br>
	 * @param acceleration_numerator <<br>
	 * @param acceleration_denominator <<br>
	 * @param threshold <<br>
	 * @param do_acceleration <<br>
	 * @param do_threshold <<br>
	 * <i>native declaration : xcb/xproto.h:9167</i><br>
	 * @deprecated use the safer method {@link #xcb_change_pointer_control_checked(com.sun.jna.ptr.PointerByReference, short, short, short, byte, byte)} instead
	 */
	@Deprecated 
	xcb.xcb_void_cookie_t.ByValue xcb_change_pointer_control_checked(Pointer c, short acceleration_numerator, short acceleration_denominator, short threshold, byte do_acceleration, byte do_threshold);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_change_pointer_control_checked(xcb_connection_t*, int16_t, int16_t, int16_t, uint8_t, uint8_t)</code><br>
	 * @param c <<br>
	 * @param acceleration_numerator <<br>
	 * @param acceleration_denominator <<br>
	 * @param threshold <<br>
	 * @param do_acceleration <<br>
	 * @param do_threshold <<br>
	 * <i>native declaration : xcb/xproto.h:9167</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_change_pointer_control_checked(PointerByReference c, short acceleration_numerator, short acceleration_denominator, short threshold, byte do_acceleration, byte do_threshold);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_change_pointer_control(xcb_connection_t*, int16_t, int16_t, int16_t, uint8_t, uint8_t)</code><br>
	 * @param c <<br>
	 * @param acceleration_numerator <<br>
	 * @param acceleration_denominator <<br>
	 * @param threshold <<br>
	 * @param do_acceleration <<br>
	 * @param do_threshold <<br>
	 * <i>native declaration : xcb/xproto.h:9180</i><br>
	 * @deprecated use the safer method {@link #xcb_change_pointer_control(com.sun.jna.ptr.PointerByReference, short, short, short, byte, byte)} instead
	 */
	@Deprecated 
	xcb.xcb_void_cookie_t.ByValue xcb_change_pointer_control(Pointer c, short acceleration_numerator, short acceleration_denominator, short threshold, byte do_acceleration, byte do_threshold);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_change_pointer_control(xcb_connection_t*, int16_t, int16_t, int16_t, uint8_t, uint8_t)</code><br>
	 * @param c <<br>
	 * @param acceleration_numerator <<br>
	 * @param acceleration_denominator <<br>
	 * @param threshold <<br>
	 * @param do_acceleration <<br>
	 * @param do_threshold <<br>
	 * <i>native declaration : xcb/xproto.h:9180</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_change_pointer_control(PointerByReference c, short acceleration_numerator, short acceleration_denominator, short threshold, byte do_acceleration, byte do_threshold);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_get_pointer_control_cookie_t xcb_get_pointer_control(xcb_connection_t*)</code><br>
	 * @param c <<br>
	 * <i>native declaration : xcb/xproto.h:9188</i><br>
	 * @deprecated use the safer method {@link #xcb_get_pointer_control(com.sun.jna.ptr.PointerByReference)} instead
	 */
	@Deprecated 
	xcb.xcb_get_pointer_control_cookie_t.ByValue xcb_get_pointer_control(Pointer c);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_get_pointer_control_cookie_t xcb_get_pointer_control(xcb_connection_t*)</code><br>
	 * @param c <<br>
	 * <i>native declaration : xcb/xproto.h:9188</i>
	 */
	xcb.xcb_get_pointer_control_cookie_t.ByValue xcb_get_pointer_control(PointerByReference c);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * placed in the event queue.<br>
	 * Original signature : <code>xcb_get_pointer_control_cookie_t xcb_get_pointer_control_unchecked(xcb_connection_t*)</code><br>
	 * @param c <<br>
	 * <i>native declaration : xcb/xproto.h:9199</i><br>
	 * @deprecated use the safer method {@link #xcb_get_pointer_control_unchecked(com.sun.jna.ptr.PointerByReference)} instead
	 */
	@Deprecated 
	xcb.xcb_get_pointer_control_cookie_t.ByValue xcb_get_pointer_control_unchecked(Pointer c);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * placed in the event queue.<br>
	 * Original signature : <code>xcb_get_pointer_control_cookie_t xcb_get_pointer_control_unchecked(xcb_connection_t*)</code><br>
	 * @param c <<br>
	 * <i>native declaration : xcb/xproto.h:9199</i>
	 */
	xcb.xcb_get_pointer_control_cookie_t.ByValue xcb_get_pointer_control_unchecked(PointerByReference c);
	/**
	 * Return the reply<br>
	 * @param c      The connection<br>
	 * @param cookie The cookie<br>
	 * @param e      The xcb_generic_error_t supplied<br>
	 * Returns the reply of the request asked by<br>
	 * The parameter @p e supplied to this function must be NULL if<br>
	 * xcb_get_pointer_control_unchecked(). is used.<br>
	 * Otherwise, it stores the error if any.<br>
	 * The returned value must be freed by the caller using free().<br>
	 * Original signature : <code>xcb_get_pointer_control_reply_t* xcb_get_pointer_control_reply(xcb_connection_t*, xcb_get_pointer_control_cookie_t, xcb_generic_error_t**)</code><br>
	 * @param c <<br>
	 * @param cookie <<br>
	 * @param e <<br>
	 * <i>native declaration : xcb/xproto.h:9215</i><br>
	 * @deprecated use the safer method {@link #xcb_get_pointer_control_reply(com.sun.jna.ptr.PointerByReference, xcb.xcb_get_pointer_control_cookie_t.ByValue, xcb.xcb_generic_error_t.ByReference[])} instead
	 */
	@Deprecated 
	xcb_get_pointer_control_reply_t xcb_get_pointer_control_reply(Pointer c, xcb.xcb_get_pointer_control_cookie_t.ByValue cookie, PointerByReference e);
	/**
	 * Return the reply<br>
	 * @param c      The connection<br>
	 * @param cookie The cookie<br>
	 * @param e      The xcb_generic_error_t supplied<br>
	 * Returns the reply of the request asked by<br>
	 * The parameter @p e supplied to this function must be NULL if<br>
	 * xcb_get_pointer_control_unchecked(). is used.<br>
	 * Otherwise, it stores the error if any.<br>
	 * The returned value must be freed by the caller using free().<br>
	 * Original signature : <code>xcb_get_pointer_control_reply_t* xcb_get_pointer_control_reply(xcb_connection_t*, xcb_get_pointer_control_cookie_t, xcb_generic_error_t**)</code><br>
	 * @param c <<br>
	 * @param cookie <<br>
	 * @param e <<br>
	 * <i>native declaration : xcb/xproto.h:9215</i>
	 */
	xcb_get_pointer_control_reply_t xcb_get_pointer_control_reply(PointerByReference c, xcb.xcb_get_pointer_control_cookie_t.ByValue cookie, xcb_generic_error_t.ByReference e[]);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_set_screen_saver_checked(xcb_connection_t*, int16_t, int16_t, uint8_t, uint8_t)</code><br>
	 * @param c <<br>
	 * @param timeout <<br>
	 * @param interval <<br>
	 * @param prefer_blanking <<br>
	 * @param allow_exposures <<br>
	 * <i>native declaration : xcb/xproto.h:9230</i><br>
	 * @deprecated use the safer method {@link #xcb_set_screen_saver_checked(com.sun.jna.ptr.PointerByReference, short, short, byte, byte)} instead
	 */
	@Deprecated 
	xcb.xcb_void_cookie_t.ByValue xcb_set_screen_saver_checked(Pointer c, short timeout, short interval, byte prefer_blanking, byte allow_exposures);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_set_screen_saver_checked(xcb_connection_t*, int16_t, int16_t, uint8_t, uint8_t)</code><br>
	 * @param c <<br>
	 * @param timeout <<br>
	 * @param interval <<br>
	 * @param prefer_blanking <<br>
	 * @param allow_exposures <<br>
	 * <i>native declaration : xcb/xproto.h:9230</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_set_screen_saver_checked(PointerByReference c, short timeout, short interval, byte prefer_blanking, byte allow_exposures);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_set_screen_saver(xcb_connection_t*, int16_t, int16_t, uint8_t, uint8_t)</code><br>
	 * @param c <<br>
	 * @param timeout <<br>
	 * @param interval <<br>
	 * @param prefer_blanking <<br>
	 * @param allow_exposures <<br>
	 * <i>native declaration : xcb/xproto.h:9242</i><br>
	 * @deprecated use the safer method {@link #xcb_set_screen_saver(com.sun.jna.ptr.PointerByReference, short, short, byte, byte)} instead
	 */
	@Deprecated 
	xcb.xcb_void_cookie_t.ByValue xcb_set_screen_saver(Pointer c, short timeout, short interval, byte prefer_blanking, byte allow_exposures);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_set_screen_saver(xcb_connection_t*, int16_t, int16_t, uint8_t, uint8_t)</code><br>
	 * @param c <<br>
	 * @param timeout <<br>
	 * @param interval <<br>
	 * @param prefer_blanking <<br>
	 * @param allow_exposures <<br>
	 * <i>native declaration : xcb/xproto.h:9242</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_set_screen_saver(PointerByReference c, short timeout, short interval, byte prefer_blanking, byte allow_exposures);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_get_screen_saver_cookie_t xcb_get_screen_saver(xcb_connection_t*)</code><br>
	 * @param c <<br>
	 * <i>native declaration : xcb/xproto.h:9250</i><br>
	 * @deprecated use the safer method {@link #xcb_get_screen_saver(com.sun.jna.ptr.PointerByReference)} instead
	 */
	@Deprecated 
	xcb.xcb_get_screen_saver_cookie_t.ByValue xcb_get_screen_saver(Pointer c);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_get_screen_saver_cookie_t xcb_get_screen_saver(xcb_connection_t*)</code><br>
	 * @param c <<br>
	 * <i>native declaration : xcb/xproto.h:9250</i>
	 */
	xcb.xcb_get_screen_saver_cookie_t.ByValue xcb_get_screen_saver(PointerByReference c);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * placed in the event queue.<br>
	 * Original signature : <code>xcb_get_screen_saver_cookie_t xcb_get_screen_saver_unchecked(xcb_connection_t*)</code><br>
	 * @param c <<br>
	 * <i>native declaration : xcb/xproto.h:9261</i><br>
	 * @deprecated use the safer method {@link #xcb_get_screen_saver_unchecked(com.sun.jna.ptr.PointerByReference)} instead
	 */
	@Deprecated 
	xcb.xcb_get_screen_saver_cookie_t.ByValue xcb_get_screen_saver_unchecked(Pointer c);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * placed in the event queue.<br>
	 * Original signature : <code>xcb_get_screen_saver_cookie_t xcb_get_screen_saver_unchecked(xcb_connection_t*)</code><br>
	 * @param c <<br>
	 * <i>native declaration : xcb/xproto.h:9261</i>
	 */
	xcb.xcb_get_screen_saver_cookie_t.ByValue xcb_get_screen_saver_unchecked(PointerByReference c);
	/**
	 * Return the reply<br>
	 * @param c      The connection<br>
	 * @param cookie The cookie<br>
	 * @param e      The xcb_generic_error_t supplied<br>
	 * Returns the reply of the request asked by<br>
	 * The parameter @p e supplied to this function must be NULL if<br>
	 * xcb_get_screen_saver_unchecked(). is used.<br>
	 * Otherwise, it stores the error if any.<br>
	 * The returned value must be freed by the caller using free().<br>
	 * Original signature : <code>xcb_get_screen_saver_reply_t* xcb_get_screen_saver_reply(xcb_connection_t*, xcb_get_screen_saver_cookie_t, xcb_generic_error_t**)</code><br>
	 * @param c <<br>
	 * @param cookie <<br>
	 * @param e <<br>
	 * <i>native declaration : xcb/xproto.h:9277</i><br>
	 * @deprecated use the safer method {@link #xcb_get_screen_saver_reply(com.sun.jna.ptr.PointerByReference, xcb.xcb_get_screen_saver_cookie_t.ByValue, xcb.xcb_generic_error_t.ByReference[])} instead
	 */
	@Deprecated 
	xcb_get_screen_saver_reply_t xcb_get_screen_saver_reply(Pointer c, xcb.xcb_get_screen_saver_cookie_t.ByValue cookie, PointerByReference e);
	/**
	 * Return the reply<br>
	 * @param c      The connection<br>
	 * @param cookie The cookie<br>
	 * @param e      The xcb_generic_error_t supplied<br>
	 * Returns the reply of the request asked by<br>
	 * The parameter @p e supplied to this function must be NULL if<br>
	 * xcb_get_screen_saver_unchecked(). is used.<br>
	 * Otherwise, it stores the error if any.<br>
	 * The returned value must be freed by the caller using free().<br>
	 * Original signature : <code>xcb_get_screen_saver_reply_t* xcb_get_screen_saver_reply(xcb_connection_t*, xcb_get_screen_saver_cookie_t, xcb_generic_error_t**)</code><br>
	 * @param c <<br>
	 * @param cookie <<br>
	 * @param e <<br>
	 * <i>native declaration : xcb/xproto.h:9277</i>
	 */
	xcb_get_screen_saver_reply_t xcb_get_screen_saver_reply(PointerByReference c, xcb.xcb_get_screen_saver_cookie_t.ByValue cookie, xcb_generic_error_t.ByReference e[]);
	/**
	 * Original signature : <code>int xcb_change_hosts_sizeof(const void*)</code><br>
	 * @param _buffer <<br>
	 * <i>native declaration : xcb/xproto.h:9282</i>
	 */
	int xcb_change_hosts_sizeof(Pointer _buffer);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_change_hosts_checked(xcb_connection_t*, uint8_t, uint8_t, uint16_t, const uint8_t*)</code><br>
	 * @param c <<br>
	 * @param mode <<br>
	 * @param family <<br>
	 * @param address_len <<br>
	 * @param address <<br>
	 * <i>native declaration : xcb/xproto.h:9297</i><br>
	 * @deprecated use the safer methods {@link #xcb_change_hosts_checked(com.sun.jna.ptr.PointerByReference, byte, byte, short, byte[])} and {@link #xcb_change_hosts_checked(com.sun.jna.ptr.PointerByReference, byte, byte, short, com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	xcb.xcb_void_cookie_t.ByValue xcb_change_hosts_checked(Pointer c, byte mode, byte family, short address_len, Pointer address);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_change_hosts_checked(xcb_connection_t*, uint8_t, uint8_t, uint16_t, const uint8_t*)</code><br>
	 * @param c <<br>
	 * @param mode <<br>
	 * @param family <<br>
	 * @param address_len <<br>
	 * @param address <<br>
	 * <i>native declaration : xcb/xproto.h:9297</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_change_hosts_checked(PointerByReference c, byte mode, byte family, short address_len, byte address[]);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_change_hosts_checked(xcb_connection_t*, uint8_t, uint8_t, uint16_t, const uint8_t*)</code><br>
	 * @param c <<br>
	 * @param mode <<br>
	 * @param family <<br>
	 * @param address_len <<br>
	 * @param address <<br>
	 * <i>native declaration : xcb/xproto.h:9297</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_change_hosts_checked(PointerByReference c, byte mode, byte family, short address_len, Pointer address);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_change_hosts(xcb_connection_t*, uint8_t, uint8_t, uint16_t, const uint8_t*)</code><br>
	 * @param c <<br>
	 * @param mode <<br>
	 * @param family <<br>
	 * @param address_len <<br>
	 * @param address <<br>
	 * <i>native declaration : xcb/xproto.h:9309</i><br>
	 * @deprecated use the safer methods {@link #xcb_change_hosts(com.sun.jna.ptr.PointerByReference, byte, byte, short, byte[])} and {@link #xcb_change_hosts(com.sun.jna.ptr.PointerByReference, byte, byte, short, com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	xcb.xcb_void_cookie_t.ByValue xcb_change_hosts(Pointer c, byte mode, byte family, short address_len, Pointer address);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_change_hosts(xcb_connection_t*, uint8_t, uint8_t, uint16_t, const uint8_t*)</code><br>
	 * @param c <<br>
	 * @param mode <<br>
	 * @param family <<br>
	 * @param address_len <<br>
	 * @param address <<br>
	 * <i>native declaration : xcb/xproto.h:9309</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_change_hosts(PointerByReference c, byte mode, byte family, short address_len, byte address[]);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_change_hosts(xcb_connection_t*, uint8_t, uint8_t, uint16_t, const uint8_t*)</code><br>
	 * @param c <<br>
	 * @param mode <<br>
	 * @param family <<br>
	 * @param address_len <<br>
	 * @param address <<br>
	 * <i>native declaration : xcb/xproto.h:9309</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_change_hosts(PointerByReference c, byte mode, byte family, short address_len, Pointer address);
	/**
	 * Original signature : <code>int xcb_host_sizeof(const void*)</code><br>
	 * @param _buffer <<br>
	 * <i>native declaration : xcb/xproto.h:9314</i>
	 */
	int xcb_host_sizeof(Pointer _buffer);
	/**
	 * Original signature : <code>uint8_t* xcb_host_address(const xcb_host_t*)</code><br>
	 * @param R <<br>
	 * <i>native declaration : xcb/xproto.h:9319</i>
	 */
	Pointer xcb_host_address(xcb_host_t R);
	/**
	 * Original signature : <code>int xcb_host_address_length(const xcb_host_t*)</code><br>
	 * @param R <<br>
	 * <i>native declaration : xcb/xproto.h:9324</i>
	 */
	int xcb_host_address_length(xcb_host_t R);
	/**
	 * Original signature : <code>xcb_generic_iterator_t xcb_host_address_end(const xcb_host_t*)</code><br>
	 * @param R <<br>
	 * <i>native declaration : xcb/xproto.h:9329</i>
	 */
	xcb.xcb_generic_iterator_t.ByValue xcb_host_address_end(xcb_host_t R);
	/**
	 * Get the next element of the iterator<br>
	 * @param i Pointer to a xcb_host_iterator_t<br>
	 * Get the next element in the iterator. The member rem is<br>
	 * decreased by one. The member data points to the next<br>
	 * element. The member index is increased by sizeof(xcb_host_t)<br>
	 * Original signature : <code>void xcb_host_next(xcb_host_iterator_t*)</code><br>
	 * @param i <<br>
	 * <i>native declaration : xcb/xproto.h:9339</i>
	 */
	void xcb_host_next(xcb_host_iterator_t i);
	/**
	 * Return the iterator pointing to the last element<br>
	 * @param i An xcb_host_iterator_t<br>
	 * @return  The iterator pointing to the last element<br>
	 * Set the current element in the iterator to the last element.<br>
	 * The member rem is set to 0. The member data points to the<br>
	 * last element.<br>
	 * Original signature : <code>xcb_generic_iterator_t xcb_host_end(xcb_host_iterator_t)</code><br>
	 * @param i <<br>
	 * <i>native declaration : xcb/xproto.h:9350</i>
	 */
	xcb.xcb_generic_iterator_t.ByValue xcb_host_end(xcb_host_iterator_t.ByValue i);
	/**
	 * Original signature : <code>int xcb_list_hosts_sizeof(const void*)</code><br>
	 * @param _buffer <<br>
	 * <i>native declaration : xcb/xproto.h:9355</i>
	 */
	int xcb_list_hosts_sizeof(Pointer _buffer);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_list_hosts_cookie_t xcb_list_hosts(xcb_connection_t*)</code><br>
	 * @param c <<br>
	 * <i>native declaration : xcb/xproto.h:9363</i><br>
	 * @deprecated use the safer method {@link #xcb_list_hosts(com.sun.jna.ptr.PointerByReference)} instead
	 */
	@Deprecated 
	xcb.xcb_list_hosts_cookie_t.ByValue xcb_list_hosts(Pointer c);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_list_hosts_cookie_t xcb_list_hosts(xcb_connection_t*)</code><br>
	 * @param c <<br>
	 * <i>native declaration : xcb/xproto.h:9363</i>
	 */
	xcb.xcb_list_hosts_cookie_t.ByValue xcb_list_hosts(PointerByReference c);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * placed in the event queue.<br>
	 * Original signature : <code>xcb_list_hosts_cookie_t xcb_list_hosts_unchecked(xcb_connection_t*)</code><br>
	 * @param c <<br>
	 * <i>native declaration : xcb/xproto.h:9374</i><br>
	 * @deprecated use the safer method {@link #xcb_list_hosts_unchecked(com.sun.jna.ptr.PointerByReference)} instead
	 */
	@Deprecated 
	xcb.xcb_list_hosts_cookie_t.ByValue xcb_list_hosts_unchecked(Pointer c);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * placed in the event queue.<br>
	 * Original signature : <code>xcb_list_hosts_cookie_t xcb_list_hosts_unchecked(xcb_connection_t*)</code><br>
	 * @param c <<br>
	 * <i>native declaration : xcb/xproto.h:9374</i>
	 */
	xcb.xcb_list_hosts_cookie_t.ByValue xcb_list_hosts_unchecked(PointerByReference c);
	/**
	 * Original signature : <code>int xcb_list_hosts_hosts_length(const xcb_list_hosts_reply_t*)</code><br>
	 * @param R <<br>
	 * <i>native declaration : xcb/xproto.h:9379</i>
	 */
	int xcb_list_hosts_hosts_length(xcb_list_hosts_reply_t R);
	/**
	 * Original signature : <code>xcb_host_iterator_t xcb_list_hosts_hosts_iterator(const xcb_list_hosts_reply_t*)</code><br>
	 * @param R <<br>
	 * <i>native declaration : xcb/xproto.h:9384</i>
	 */
	xcb_host_iterator_t.ByValue xcb_list_hosts_hosts_iterator(xcb_list_hosts_reply_t R);
	/**
	 * Return the reply<br>
	 * @param c      The connection<br>
	 * @param cookie The cookie<br>
	 * @param e      The xcb_generic_error_t supplied<br>
	 * Returns the reply of the request asked by<br>
	 * The parameter @p e supplied to this function must be NULL if<br>
	 * xcb_list_hosts_unchecked(). is used.<br>
	 * Otherwise, it stores the error if any.<br>
	 * The returned value must be freed by the caller using free().<br>
	 * Original signature : <code>xcb_list_hosts_reply_t* xcb_list_hosts_reply(xcb_connection_t*, xcb_list_hosts_cookie_t, xcb_generic_error_t**)</code><br>
	 * @param c <<br>
	 * @param cookie <<br>
	 * @param e <<br>
	 * <i>native declaration : xcb/xproto.h:9400</i><br>
	 * @deprecated use the safer method {@link #xcb_list_hosts_reply(com.sun.jna.ptr.PointerByReference, xcb.xcb_list_hosts_cookie_t.ByValue, xcb.xcb_generic_error_t.ByReference[])} instead
	 */
	@Deprecated 
	xcb_list_hosts_reply_t xcb_list_hosts_reply(Pointer c, xcb.xcb_list_hosts_cookie_t.ByValue cookie, PointerByReference e);
	/**
	 * Return the reply<br>
	 * @param c      The connection<br>
	 * @param cookie The cookie<br>
	 * @param e      The xcb_generic_error_t supplied<br>
	 * Returns the reply of the request asked by<br>
	 * The parameter @p e supplied to this function must be NULL if<br>
	 * xcb_list_hosts_unchecked(). is used.<br>
	 * Otherwise, it stores the error if any.<br>
	 * The returned value must be freed by the caller using free().<br>
	 * Original signature : <code>xcb_list_hosts_reply_t* xcb_list_hosts_reply(xcb_connection_t*, xcb_list_hosts_cookie_t, xcb_generic_error_t**)</code><br>
	 * @param c <<br>
	 * @param cookie <<br>
	 * @param e <<br>
	 * <i>native declaration : xcb/xproto.h:9400</i>
	 */
	xcb_list_hosts_reply_t xcb_list_hosts_reply(PointerByReference c, xcb.xcb_list_hosts_cookie_t.ByValue cookie, xcb_generic_error_t.ByReference e[]);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_set_access_control_checked(xcb_connection_t*, uint8_t)</code><br>
	 * @param c <<br>
	 * @param mode <<br>
	 * <i>native declaration : xcb/xproto.h:9412</i><br>
	 * @deprecated use the safer method {@link #xcb_set_access_control_checked(com.sun.jna.ptr.PointerByReference, byte)} instead
	 */
	@Deprecated 
	xcb.xcb_void_cookie_t.ByValue xcb_set_access_control_checked(Pointer c, byte mode);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_set_access_control_checked(xcb_connection_t*, uint8_t)</code><br>
	 * @param c <<br>
	 * @param mode <<br>
	 * <i>native declaration : xcb/xproto.h:9412</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_set_access_control_checked(PointerByReference c, byte mode);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_set_access_control(xcb_connection_t*, uint8_t)</code><br>
	 * @param c <<br>
	 * @param mode <<br>
	 * <i>native declaration : xcb/xproto.h:9421</i><br>
	 * @deprecated use the safer method {@link #xcb_set_access_control(com.sun.jna.ptr.PointerByReference, byte)} instead
	 */
	@Deprecated 
	xcb.xcb_void_cookie_t.ByValue xcb_set_access_control(Pointer c, byte mode);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_set_access_control(xcb_connection_t*, uint8_t)</code><br>
	 * @param c <<br>
	 * @param mode <<br>
	 * <i>native declaration : xcb/xproto.h:9421</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_set_access_control(PointerByReference c, byte mode);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_set_close_down_mode_checked(xcb_connection_t*, uint8_t)</code><br>
	 * @param c <<br>
	 * @param mode <<br>
	 * <i>native declaration : xcb/xproto.h:9433</i><br>
	 * @deprecated use the safer method {@link #xcb_set_close_down_mode_checked(com.sun.jna.ptr.PointerByReference, byte)} instead
	 */
	@Deprecated 
	xcb.xcb_void_cookie_t.ByValue xcb_set_close_down_mode_checked(Pointer c, byte mode);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_set_close_down_mode_checked(xcb_connection_t*, uint8_t)</code><br>
	 * @param c <<br>
	 * @param mode <<br>
	 * <i>native declaration : xcb/xproto.h:9433</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_set_close_down_mode_checked(PointerByReference c, byte mode);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_set_close_down_mode(xcb_connection_t*, uint8_t)</code><br>
	 * @param c <<br>
	 * @param mode <<br>
	 * <i>native declaration : xcb/xproto.h:9442</i><br>
	 * @deprecated use the safer method {@link #xcb_set_close_down_mode(com.sun.jna.ptr.PointerByReference, byte)} instead
	 */
	@Deprecated 
	xcb.xcb_void_cookie_t.ByValue xcb_set_close_down_mode(Pointer c, byte mode);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_set_close_down_mode(xcb_connection_t*, uint8_t)</code><br>
	 * @param c <<br>
	 * @param mode <<br>
	 * <i>native declaration : xcb/xproto.h:9442</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_set_close_down_mode(PointerByReference c, byte mode);
	/**
	 * @brief kills a client<br>
	 * @param c The connection<br>
	 * @param resource Any resource belonging to the client (for example a Window), used to identify<br>
	 * the client connection.<br>
	 * \n<br>
	 * The special value of `XCB_KILL_ALL_TEMPORARY`, the resources of all clients<br>
	 * that have terminated in `RetainTemporary` (TODO) are destroyed.<br>
	 * @return A cookie<br>
	 * Forces a close down of the client that created the specified \a resource.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_kill_client_checked(xcb_connection_t*, uint32_t)</code><br>
	 * @param c <<br>
	 * @param resource <<br>
	 * <i>native declaration : xcb/xproto.h:9460</i><br>
	 * @deprecated use the safer method {@link #xcb_kill_client_checked(com.sun.jna.ptr.PointerByReference, int)} instead
	 */
	@Deprecated 
	xcb.xcb_void_cookie_t.ByValue xcb_kill_client_checked(Pointer c, int resource);
	/**
	 * @brief kills a client<br>
	 * @param c The connection<br>
	 * @param resource Any resource belonging to the client (for example a Window), used to identify<br>
	 * the client connection.<br>
	 * \n<br>
	 * The special value of `XCB_KILL_ALL_TEMPORARY`, the resources of all clients<br>
	 * that have terminated in `RetainTemporary` (TODO) are destroyed.<br>
	 * @return A cookie<br>
	 * Forces a close down of the client that created the specified \a resource.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_kill_client_checked(xcb_connection_t*, uint32_t)</code><br>
	 * @param c <<br>
	 * @param resource <<br>
	 * <i>native declaration : xcb/xproto.h:9460</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_kill_client_checked(PointerByReference c, int resource);
	/**
	 * @brief kills a client<br>
	 * @param c The connection<br>
	 * @param resource Any resource belonging to the client (for example a Window), used to identify<br>
	 * the client connection.<br>
	 * \n<br>
	 * The special value of `XCB_KILL_ALL_TEMPORARY`, the resources of all clients<br>
	 * that have terminated in `RetainTemporary` (TODO) are destroyed.<br>
	 * @return A cookie<br>
	 * Forces a close down of the client that created the specified \a resource.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_kill_client(xcb_connection_t*, uint32_t)</code><br>
	 * @param c <<br>
	 * @param resource <<br>
	 * <i>native declaration : xcb/xproto.h:9475</i><br>
	 * @deprecated use the safer method {@link #xcb_kill_client(com.sun.jna.ptr.PointerByReference, int)} instead
	 */
	@Deprecated 
	xcb.xcb_void_cookie_t.ByValue xcb_kill_client(Pointer c, int resource);
	/**
	 * @brief kills a client<br>
	 * @param c The connection<br>
	 * @param resource Any resource belonging to the client (for example a Window), used to identify<br>
	 * the client connection.<br>
	 * \n<br>
	 * The special value of `XCB_KILL_ALL_TEMPORARY`, the resources of all clients<br>
	 * that have terminated in `RetainTemporary` (TODO) are destroyed.<br>
	 * @return A cookie<br>
	 * Forces a close down of the client that created the specified \a resource.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_kill_client(xcb_connection_t*, uint32_t)</code><br>
	 * @param c <<br>
	 * @param resource <<br>
	 * <i>native declaration : xcb/xproto.h:9475</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_kill_client(PointerByReference c, int resource);
	/**
	 * Original signature : <code>int xcb_rotate_properties_sizeof(const void*)</code><br>
	 * @param _buffer <<br>
	 * <i>native declaration : xcb/xproto.h:9480</i>
	 */
	int xcb_rotate_properties_sizeof(Pointer _buffer);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_rotate_properties_checked(xcb_connection_t*, xcb_window_t, uint16_t, int16_t, const xcb_atom_t*)</code><br>
	 * @param c <<br>
	 * @param window <<br>
	 * @param atoms_len <<br>
	 * @param delta <<br>
	 * @param atoms <<br>
	 * <i>native declaration : xcb/xproto.h:9495</i><br>
	 * @deprecated use the safer methods {@link #xcb_rotate_properties_checked(com.sun.jna.ptr.PointerByReference, int, short, short, java.nio.IntBuffer)} and {@link #xcb_rotate_properties_checked(com.sun.jna.ptr.PointerByReference, int, short, short, com.sun.jna.ptr.IntByReference)} instead
	 */
	@Deprecated 
	xcb.xcb_void_cookie_t.ByValue xcb_rotate_properties_checked(Pointer c, int window, short atoms_len, short delta, IntByReference atoms);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_rotate_properties_checked(xcb_connection_t*, xcb_window_t, uint16_t, int16_t, const xcb_atom_t*)</code><br>
	 * @param c <<br>
	 * @param window <<br>
	 * @param atoms_len <<br>
	 * @param delta <<br>
	 * @param atoms <<br>
	 * <i>native declaration : xcb/xproto.h:9495</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_rotate_properties_checked(PointerByReference c, int window, short atoms_len, short delta, IntBuffer atoms);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_rotate_properties_checked(xcb_connection_t*, xcb_window_t, uint16_t, int16_t, const xcb_atom_t*)</code><br>
	 * @param c <<br>
	 * @param window <<br>
	 * @param atoms_len <<br>
	 * @param delta <<br>
	 * @param atoms <<br>
	 * <i>native declaration : xcb/xproto.h:9495</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_rotate_properties_checked(PointerByReference c, int window, short atoms_len, short delta, IntByReference atoms);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_rotate_properties(xcb_connection_t*, xcb_window_t, uint16_t, int16_t, const xcb_atom_t*)</code><br>
	 * @param c <<br>
	 * @param window <<br>
	 * @param atoms_len <<br>
	 * @param delta <<br>
	 * @param atoms <<br>
	 * <i>native declaration : xcb/xproto.h:9507</i><br>
	 * @deprecated use the safer methods {@link #xcb_rotate_properties(com.sun.jna.ptr.PointerByReference, int, short, short, java.nio.IntBuffer)} and {@link #xcb_rotate_properties(com.sun.jna.ptr.PointerByReference, int, short, short, com.sun.jna.ptr.IntByReference)} instead
	 */
	@Deprecated 
	xcb.xcb_void_cookie_t.ByValue xcb_rotate_properties(Pointer c, int window, short atoms_len, short delta, IntByReference atoms);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_rotate_properties(xcb_connection_t*, xcb_window_t, uint16_t, int16_t, const xcb_atom_t*)</code><br>
	 * @param c <<br>
	 * @param window <<br>
	 * @param atoms_len <<br>
	 * @param delta <<br>
	 * @param atoms <<br>
	 * <i>native declaration : xcb/xproto.h:9507</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_rotate_properties(PointerByReference c, int window, short atoms_len, short delta, IntBuffer atoms);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_rotate_properties(xcb_connection_t*, xcb_window_t, uint16_t, int16_t, const xcb_atom_t*)</code><br>
	 * @param c <<br>
	 * @param window <<br>
	 * @param atoms_len <<br>
	 * @param delta <<br>
	 * @param atoms <<br>
	 * <i>native declaration : xcb/xproto.h:9507</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_rotate_properties(PointerByReference c, int window, short atoms_len, short delta, IntByReference atoms);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_force_screen_saver_checked(xcb_connection_t*, uint8_t)</code><br>
	 * @param c <<br>
	 * @param mode <<br>
	 * <i>native declaration : xcb/xproto.h:9519</i><br>
	 * @deprecated use the safer method {@link #xcb_force_screen_saver_checked(com.sun.jna.ptr.PointerByReference, byte)} instead
	 */
	@Deprecated 
	xcb.xcb_void_cookie_t.ByValue xcb_force_screen_saver_checked(Pointer c, byte mode);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_force_screen_saver_checked(xcb_connection_t*, uint8_t)</code><br>
	 * @param c <<br>
	 * @param mode <<br>
	 * <i>native declaration : xcb/xproto.h:9519</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_force_screen_saver_checked(PointerByReference c, byte mode);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_force_screen_saver(xcb_connection_t*, uint8_t)</code><br>
	 * @param c <<br>
	 * @param mode <<br>
	 * <i>native declaration : xcb/xproto.h:9528</i><br>
	 * @deprecated use the safer method {@link #xcb_force_screen_saver(com.sun.jna.ptr.PointerByReference, byte)} instead
	 */
	@Deprecated 
	xcb.xcb_void_cookie_t.ByValue xcb_force_screen_saver(Pointer c, byte mode);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_force_screen_saver(xcb_connection_t*, uint8_t)</code><br>
	 * @param c <<br>
	 * @param mode <<br>
	 * <i>native declaration : xcb/xproto.h:9528</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_force_screen_saver(PointerByReference c, byte mode);
	/**
	 * Original signature : <code>int xcb_set_pointer_mapping_sizeof(const void*)</code><br>
	 * @param _buffer <<br>
	 * <i>native declaration : xcb/xproto.h:9533</i>
	 */
	int xcb_set_pointer_mapping_sizeof(Pointer _buffer);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_set_pointer_mapping_cookie_t xcb_set_pointer_mapping(xcb_connection_t*, uint8_t, const uint8_t*)</code><br>
	 * @param c <<br>
	 * @param map_len <<br>
	 * @param map <<br>
	 * <i>native declaration : xcb/xproto.h:9543</i><br>
	 * @deprecated use the safer methods {@link #xcb_set_pointer_mapping(com.sun.jna.ptr.PointerByReference, byte, byte[])} and {@link #xcb_set_pointer_mapping(com.sun.jna.ptr.PointerByReference, byte, com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	xcb.xcb_set_pointer_mapping_cookie_t.ByValue xcb_set_pointer_mapping(Pointer c, byte map_len, Pointer map);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_set_pointer_mapping_cookie_t xcb_set_pointer_mapping(xcb_connection_t*, uint8_t, const uint8_t*)</code><br>
	 * @param c <<br>
	 * @param map_len <<br>
	 * @param map <<br>
	 * <i>native declaration : xcb/xproto.h:9543</i>
	 */
	xcb.xcb_set_pointer_mapping_cookie_t.ByValue xcb_set_pointer_mapping(PointerByReference c, byte map_len, byte map[]);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_set_pointer_mapping_cookie_t xcb_set_pointer_mapping(xcb_connection_t*, uint8_t, const uint8_t*)</code><br>
	 * @param c <<br>
	 * @param map_len <<br>
	 * @param map <<br>
	 * <i>native declaration : xcb/xproto.h:9543</i>
	 */
	xcb.xcb_set_pointer_mapping_cookie_t.ByValue xcb_set_pointer_mapping(PointerByReference c, byte map_len, Pointer map);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * placed in the event queue.<br>
	 * Original signature : <code>xcb_set_pointer_mapping_cookie_t xcb_set_pointer_mapping_unchecked(xcb_connection_t*, uint8_t, const uint8_t*)</code><br>
	 * @param c <<br>
	 * @param map_len <<br>
	 * @param map <<br>
	 * <i>native declaration : xcb/xproto.h:9556</i><br>
	 * @deprecated use the safer methods {@link #xcb_set_pointer_mapping_unchecked(com.sun.jna.ptr.PointerByReference, byte, byte[])} and {@link #xcb_set_pointer_mapping_unchecked(com.sun.jna.ptr.PointerByReference, byte, com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	xcb.xcb_set_pointer_mapping_cookie_t.ByValue xcb_set_pointer_mapping_unchecked(Pointer c, byte map_len, Pointer map);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * placed in the event queue.<br>
	 * Original signature : <code>xcb_set_pointer_mapping_cookie_t xcb_set_pointer_mapping_unchecked(xcb_connection_t*, uint8_t, const uint8_t*)</code><br>
	 * @param c <<br>
	 * @param map_len <<br>
	 * @param map <<br>
	 * <i>native declaration : xcb/xproto.h:9556</i>
	 */
	xcb.xcb_set_pointer_mapping_cookie_t.ByValue xcb_set_pointer_mapping_unchecked(PointerByReference c, byte map_len, byte map[]);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * placed in the event queue.<br>
	 * Original signature : <code>xcb_set_pointer_mapping_cookie_t xcb_set_pointer_mapping_unchecked(xcb_connection_t*, uint8_t, const uint8_t*)</code><br>
	 * @param c <<br>
	 * @param map_len <<br>
	 * @param map <<br>
	 * <i>native declaration : xcb/xproto.h:9556</i>
	 */
	xcb.xcb_set_pointer_mapping_cookie_t.ByValue xcb_set_pointer_mapping_unchecked(PointerByReference c, byte map_len, Pointer map);
	/**
	 * Return the reply<br>
	 * @param c      The connection<br>
	 * @param cookie The cookie<br>
	 * @param e      The xcb_generic_error_t supplied<br>
	 * Returns the reply of the request asked by<br>
	 * The parameter @p e supplied to this function must be NULL if<br>
	 * xcb_set_pointer_mapping_unchecked(). is used.<br>
	 * Otherwise, it stores the error if any.<br>
	 * The returned value must be freed by the caller using free().<br>
	 * Original signature : <code>xcb_set_pointer_mapping_reply_t* xcb_set_pointer_mapping_reply(xcb_connection_t*, xcb_set_pointer_mapping_cookie_t, xcb_generic_error_t**)</code><br>
	 * @param c <<br>
	 * @param cookie <<br>
	 * @param e <<br>
	 * <i>native declaration : xcb/xproto.h:9572</i><br>
	 * @deprecated use the safer method {@link #xcb_set_pointer_mapping_reply(com.sun.jna.ptr.PointerByReference, xcb.xcb_set_pointer_mapping_cookie_t.ByValue, xcb.xcb_generic_error_t.ByReference[])} instead
	 */
	@Deprecated 
	xcb_set_pointer_mapping_reply_t xcb_set_pointer_mapping_reply(Pointer c, xcb.xcb_set_pointer_mapping_cookie_t.ByValue cookie, PointerByReference e);
	/**
	 * Return the reply<br>
	 * @param c      The connection<br>
	 * @param cookie The cookie<br>
	 * @param e      The xcb_generic_error_t supplied<br>
	 * Returns the reply of the request asked by<br>
	 * The parameter @p e supplied to this function must be NULL if<br>
	 * xcb_set_pointer_mapping_unchecked(). is used.<br>
	 * Otherwise, it stores the error if any.<br>
	 * The returned value must be freed by the caller using free().<br>
	 * Original signature : <code>xcb_set_pointer_mapping_reply_t* xcb_set_pointer_mapping_reply(xcb_connection_t*, xcb_set_pointer_mapping_cookie_t, xcb_generic_error_t**)</code><br>
	 * @param c <<br>
	 * @param cookie <<br>
	 * @param e <<br>
	 * <i>native declaration : xcb/xproto.h:9572</i>
	 */
	xcb_set_pointer_mapping_reply_t xcb_set_pointer_mapping_reply(PointerByReference c, xcb.xcb_set_pointer_mapping_cookie_t.ByValue cookie, xcb_generic_error_t.ByReference e[]);
	/**
	 * Original signature : <code>int xcb_get_pointer_mapping_sizeof(const void*)</code><br>
	 * @param _buffer <<br>
	 * <i>native declaration : xcb/xproto.h:9577</i>
	 */
	int xcb_get_pointer_mapping_sizeof(Pointer _buffer);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_get_pointer_mapping_cookie_t xcb_get_pointer_mapping(xcb_connection_t*)</code><br>
	 * @param c <<br>
	 * <i>native declaration : xcb/xproto.h:9585</i><br>
	 * @deprecated use the safer method {@link #xcb_get_pointer_mapping(com.sun.jna.ptr.PointerByReference)} instead
	 */
	@Deprecated 
	xcb.xcb_get_pointer_mapping_cookie_t.ByValue xcb_get_pointer_mapping(Pointer c);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_get_pointer_mapping_cookie_t xcb_get_pointer_mapping(xcb_connection_t*)</code><br>
	 * @param c <<br>
	 * <i>native declaration : xcb/xproto.h:9585</i>
	 */
	xcb.xcb_get_pointer_mapping_cookie_t.ByValue xcb_get_pointer_mapping(PointerByReference c);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * placed in the event queue.<br>
	 * Original signature : <code>xcb_get_pointer_mapping_cookie_t xcb_get_pointer_mapping_unchecked(xcb_connection_t*)</code><br>
	 * @param c <<br>
	 * <i>native declaration : xcb/xproto.h:9596</i><br>
	 * @deprecated use the safer method {@link #xcb_get_pointer_mapping_unchecked(com.sun.jna.ptr.PointerByReference)} instead
	 */
	@Deprecated 
	xcb.xcb_get_pointer_mapping_cookie_t.ByValue xcb_get_pointer_mapping_unchecked(Pointer c);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * placed in the event queue.<br>
	 * Original signature : <code>xcb_get_pointer_mapping_cookie_t xcb_get_pointer_mapping_unchecked(xcb_connection_t*)</code><br>
	 * @param c <<br>
	 * <i>native declaration : xcb/xproto.h:9596</i>
	 */
	xcb.xcb_get_pointer_mapping_cookie_t.ByValue xcb_get_pointer_mapping_unchecked(PointerByReference c);
	/**
	 * Original signature : <code>uint8_t* xcb_get_pointer_mapping_map(const xcb_get_pointer_mapping_reply_t*)</code><br>
	 * @param R <<br>
	 * <i>native declaration : xcb/xproto.h:9601</i>
	 */
	Pointer xcb_get_pointer_mapping_map(xcb_get_pointer_mapping_reply_t R);
	/**
	 * Original signature : <code>int xcb_get_pointer_mapping_map_length(const xcb_get_pointer_mapping_reply_t*)</code><br>
	 * @param R <<br>
	 * <i>native declaration : xcb/xproto.h:9606</i>
	 */
	int xcb_get_pointer_mapping_map_length(xcb_get_pointer_mapping_reply_t R);
	/**
	 * Original signature : <code>xcb_generic_iterator_t xcb_get_pointer_mapping_map_end(const xcb_get_pointer_mapping_reply_t*)</code><br>
	 * @param R <<br>
	 * <i>native declaration : xcb/xproto.h:9611</i>
	 */
	xcb.xcb_generic_iterator_t.ByValue xcb_get_pointer_mapping_map_end(xcb_get_pointer_mapping_reply_t R);
	/**
	 * Return the reply<br>
	 * @param c      The connection<br>
	 * @param cookie The cookie<br>
	 * @param e      The xcb_generic_error_t supplied<br>
	 * Returns the reply of the request asked by<br>
	 * The parameter @p e supplied to this function must be NULL if<br>
	 * xcb_get_pointer_mapping_unchecked(). is used.<br>
	 * Otherwise, it stores the error if any.<br>
	 * The returned value must be freed by the caller using free().<br>
	 * Original signature : <code>xcb_get_pointer_mapping_reply_t* xcb_get_pointer_mapping_reply(xcb_connection_t*, xcb_get_pointer_mapping_cookie_t, xcb_generic_error_t**)</code><br>
	 * @param c <<br>
	 * @param cookie <<br>
	 * @param e <<br>
	 * <i>native declaration : xcb/xproto.h:9627</i><br>
	 * @deprecated use the safer method {@link #xcb_get_pointer_mapping_reply(com.sun.jna.ptr.PointerByReference, xcb.xcb_get_pointer_mapping_cookie_t.ByValue, xcb.xcb_generic_error_t.ByReference[])} instead
	 */
	@Deprecated 
	xcb_get_pointer_mapping_reply_t xcb_get_pointer_mapping_reply(Pointer c, xcb.xcb_get_pointer_mapping_cookie_t.ByValue cookie, PointerByReference e);
	/**
	 * Return the reply<br>
	 * @param c      The connection<br>
	 * @param cookie The cookie<br>
	 * @param e      The xcb_generic_error_t supplied<br>
	 * Returns the reply of the request asked by<br>
	 * The parameter @p e supplied to this function must be NULL if<br>
	 * xcb_get_pointer_mapping_unchecked(). is used.<br>
	 * Otherwise, it stores the error if any.<br>
	 * The returned value must be freed by the caller using free().<br>
	 * Original signature : <code>xcb_get_pointer_mapping_reply_t* xcb_get_pointer_mapping_reply(xcb_connection_t*, xcb_get_pointer_mapping_cookie_t, xcb_generic_error_t**)</code><br>
	 * @param c <<br>
	 * @param cookie <<br>
	 * @param e <<br>
	 * <i>native declaration : xcb/xproto.h:9627</i>
	 */
	xcb_get_pointer_mapping_reply_t xcb_get_pointer_mapping_reply(PointerByReference c, xcb.xcb_get_pointer_mapping_cookie_t.ByValue cookie, xcb_generic_error_t.ByReference e[]);
	/**
	 * Original signature : <code>int xcb_set_modifier_mapping_sizeof(const void*)</code><br>
	 * @param _buffer <<br>
	 * <i>native declaration : xcb/xproto.h:9632</i>
	 */
	int xcb_set_modifier_mapping_sizeof(Pointer _buffer);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_set_modifier_mapping_cookie_t xcb_set_modifier_mapping(xcb_connection_t*, uint8_t, const xcb_keycode_t*)</code><br>
	 * @param c <<br>
	 * @param keycodes_per_modifier <<br>
	 * @param keycodes <<br>
	 * <i>native declaration : xcb/xproto.h:9642</i><br>
	 * @deprecated use the safer methods {@link #xcb_set_modifier_mapping(com.sun.jna.ptr.PointerByReference, byte, java.nio.ByteBuffer)} and {@link #xcb_set_modifier_mapping(com.sun.jna.ptr.PointerByReference, byte, com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	xcb.xcb_set_modifier_mapping_cookie_t.ByValue xcb_set_modifier_mapping(Pointer c, byte keycodes_per_modifier, Pointer keycodes);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_set_modifier_mapping_cookie_t xcb_set_modifier_mapping(xcb_connection_t*, uint8_t, const xcb_keycode_t*)</code><br>
	 * @param c <<br>
	 * @param keycodes_per_modifier <<br>
	 * @param keycodes <<br>
	 * <i>native declaration : xcb/xproto.h:9642</i>
	 */
	xcb.xcb_set_modifier_mapping_cookie_t.ByValue xcb_set_modifier_mapping(PointerByReference c, byte keycodes_per_modifier, ByteBuffer keycodes);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_set_modifier_mapping_cookie_t xcb_set_modifier_mapping(xcb_connection_t*, uint8_t, const xcb_keycode_t*)</code><br>
	 * @param c <<br>
	 * @param keycodes_per_modifier <<br>
	 * @param keycodes <<br>
	 * <i>native declaration : xcb/xproto.h:9642</i>
	 */
	xcb.xcb_set_modifier_mapping_cookie_t.ByValue xcb_set_modifier_mapping(PointerByReference c, byte keycodes_per_modifier, Pointer keycodes);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * placed in the event queue.<br>
	 * Original signature : <code>xcb_set_modifier_mapping_cookie_t xcb_set_modifier_mapping_unchecked(xcb_connection_t*, uint8_t, const xcb_keycode_t*)</code><br>
	 * @param c <<br>
	 * @param keycodes_per_modifier <<br>
	 * @param keycodes <<br>
	 * <i>native declaration : xcb/xproto.h:9655</i><br>
	 * @deprecated use the safer methods {@link #xcb_set_modifier_mapping_unchecked(com.sun.jna.ptr.PointerByReference, byte, java.nio.ByteBuffer)} and {@link #xcb_set_modifier_mapping_unchecked(com.sun.jna.ptr.PointerByReference, byte, com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	xcb.xcb_set_modifier_mapping_cookie_t.ByValue xcb_set_modifier_mapping_unchecked(Pointer c, byte keycodes_per_modifier, Pointer keycodes);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * placed in the event queue.<br>
	 * Original signature : <code>xcb_set_modifier_mapping_cookie_t xcb_set_modifier_mapping_unchecked(xcb_connection_t*, uint8_t, const xcb_keycode_t*)</code><br>
	 * @param c <<br>
	 * @param keycodes_per_modifier <<br>
	 * @param keycodes <<br>
	 * <i>native declaration : xcb/xproto.h:9655</i>
	 */
	xcb.xcb_set_modifier_mapping_cookie_t.ByValue xcb_set_modifier_mapping_unchecked(PointerByReference c, byte keycodes_per_modifier, ByteBuffer keycodes);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * placed in the event queue.<br>
	 * Original signature : <code>xcb_set_modifier_mapping_cookie_t xcb_set_modifier_mapping_unchecked(xcb_connection_t*, uint8_t, const xcb_keycode_t*)</code><br>
	 * @param c <<br>
	 * @param keycodes_per_modifier <<br>
	 * @param keycodes <<br>
	 * <i>native declaration : xcb/xproto.h:9655</i>
	 */
	xcb.xcb_set_modifier_mapping_cookie_t.ByValue xcb_set_modifier_mapping_unchecked(PointerByReference c, byte keycodes_per_modifier, Pointer keycodes);
	/**
	 * Return the reply<br>
	 * @param c      The connection<br>
	 * @param cookie The cookie<br>
	 * @param e      The xcb_generic_error_t supplied<br>
	 * Returns the reply of the request asked by<br>
	 * The parameter @p e supplied to this function must be NULL if<br>
	 * xcb_set_modifier_mapping_unchecked(). is used.<br>
	 * Otherwise, it stores the error if any.<br>
	 * The returned value must be freed by the caller using free().<br>
	 * Original signature : <code>xcb_set_modifier_mapping_reply_t* xcb_set_modifier_mapping_reply(xcb_connection_t*, xcb_set_modifier_mapping_cookie_t, xcb_generic_error_t**)</code><br>
	 * @param c <<br>
	 * @param cookie <<br>
	 * @param e <<br>
	 * <i>native declaration : xcb/xproto.h:9671</i><br>
	 * @deprecated use the safer method {@link #xcb_set_modifier_mapping_reply(com.sun.jna.ptr.PointerByReference, xcb.xcb_set_modifier_mapping_cookie_t.ByValue, xcb.xcb_generic_error_t.ByReference[])} instead
	 */
	@Deprecated 
	xcb_set_modifier_mapping_reply_t xcb_set_modifier_mapping_reply(Pointer c, xcb.xcb_set_modifier_mapping_cookie_t.ByValue cookie, PointerByReference e);
	/**
	 * Return the reply<br>
	 * @param c      The connection<br>
	 * @param cookie The cookie<br>
	 * @param e      The xcb_generic_error_t supplied<br>
	 * Returns the reply of the request asked by<br>
	 * The parameter @p e supplied to this function must be NULL if<br>
	 * xcb_set_modifier_mapping_unchecked(). is used.<br>
	 * Otherwise, it stores the error if any.<br>
	 * The returned value must be freed by the caller using free().<br>
	 * Original signature : <code>xcb_set_modifier_mapping_reply_t* xcb_set_modifier_mapping_reply(xcb_connection_t*, xcb_set_modifier_mapping_cookie_t, xcb_generic_error_t**)</code><br>
	 * @param c <<br>
	 * @param cookie <<br>
	 * @param e <<br>
	 * <i>native declaration : xcb/xproto.h:9671</i>
	 */
	xcb_set_modifier_mapping_reply_t xcb_set_modifier_mapping_reply(PointerByReference c, xcb.xcb_set_modifier_mapping_cookie_t.ByValue cookie, xcb_generic_error_t.ByReference e[]);
	/**
	 * Original signature : <code>int xcb_get_modifier_mapping_sizeof(const void*)</code><br>
	 * @param _buffer <<br>
	 * <i>native declaration : xcb/xproto.h:9676</i>
	 */
	int xcb_get_modifier_mapping_sizeof(Pointer _buffer);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_get_modifier_mapping_cookie_t xcb_get_modifier_mapping(xcb_connection_t*)</code><br>
	 * @param c <<br>
	 * <i>native declaration : xcb/xproto.h:9684</i><br>
	 * @deprecated use the safer method {@link #xcb_get_modifier_mapping(com.sun.jna.ptr.PointerByReference)} instead
	 */
	@Deprecated 
	xcb.xcb_get_modifier_mapping_cookie_t.ByValue xcb_get_modifier_mapping(Pointer c);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_get_modifier_mapping_cookie_t xcb_get_modifier_mapping(xcb_connection_t*)</code><br>
	 * @param c <<br>
	 * <i>native declaration : xcb/xproto.h:9684</i>
	 */
	xcb.xcb_get_modifier_mapping_cookie_t.ByValue xcb_get_modifier_mapping(PointerByReference c);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * placed in the event queue.<br>
	 * Original signature : <code>xcb_get_modifier_mapping_cookie_t xcb_get_modifier_mapping_unchecked(xcb_connection_t*)</code><br>
	 * @param c <<br>
	 * <i>native declaration : xcb/xproto.h:9695</i><br>
	 * @deprecated use the safer method {@link #xcb_get_modifier_mapping_unchecked(com.sun.jna.ptr.PointerByReference)} instead
	 */
	@Deprecated 
	xcb.xcb_get_modifier_mapping_cookie_t.ByValue xcb_get_modifier_mapping_unchecked(Pointer c);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * placed in the event queue.<br>
	 * Original signature : <code>xcb_get_modifier_mapping_cookie_t xcb_get_modifier_mapping_unchecked(xcb_connection_t*)</code><br>
	 * @param c <<br>
	 * <i>native declaration : xcb/xproto.h:9695</i>
	 */
	xcb.xcb_get_modifier_mapping_cookie_t.ByValue xcb_get_modifier_mapping_unchecked(PointerByReference c);
	/**
	 * Original signature : <code>xcb_keycode_t* xcb_get_modifier_mapping_keycodes(const xcb_get_modifier_mapping_reply_t*)</code><br>
	 * @param R <<br>
	 * <i>native declaration : xcb/xproto.h:9700</i>
	 */
	Pointer xcb_get_modifier_mapping_keycodes(xcb_get_modifier_mapping_reply_t R);
	/**
	 * Original signature : <code>int xcb_get_modifier_mapping_keycodes_length(const xcb_get_modifier_mapping_reply_t*)</code><br>
	 * @param R <<br>
	 * <i>native declaration : xcb/xproto.h:9705</i>
	 */
	int xcb_get_modifier_mapping_keycodes_length(xcb_get_modifier_mapping_reply_t R);
	/**
	 * Original signature : <code>xcb_generic_iterator_t xcb_get_modifier_mapping_keycodes_end(const xcb_get_modifier_mapping_reply_t*)</code><br>
	 * @param R <<br>
	 * <i>native declaration : xcb/xproto.h:9710</i>
	 */
	xcb.xcb_generic_iterator_t.ByValue xcb_get_modifier_mapping_keycodes_end(xcb_get_modifier_mapping_reply_t R);
	/**
	 * Return the reply<br>
	 * @param c      The connection<br>
	 * @param cookie The cookie<br>
	 * @param e      The xcb_generic_error_t supplied<br>
	 * Returns the reply of the request asked by<br>
	 * The parameter @p e supplied to this function must be NULL if<br>
	 * xcb_get_modifier_mapping_unchecked(). is used.<br>
	 * Otherwise, it stores the error if any.<br>
	 * The returned value must be freed by the caller using free().<br>
	 * Original signature : <code>xcb_get_modifier_mapping_reply_t* xcb_get_modifier_mapping_reply(xcb_connection_t*, xcb_get_modifier_mapping_cookie_t, xcb_generic_error_t**)</code><br>
	 * @param c <<br>
	 * @param cookie <<br>
	 * @param e <<br>
	 * <i>native declaration : xcb/xproto.h:9726</i><br>
	 * @deprecated use the safer method {@link #xcb_get_modifier_mapping_reply(com.sun.jna.ptr.PointerByReference, xcb.xcb_get_modifier_mapping_cookie_t.ByValue, xcb.xcb_generic_error_t.ByReference[])} instead
	 */
	@Deprecated 
	xcb_get_modifier_mapping_reply_t xcb_get_modifier_mapping_reply(Pointer c, xcb.xcb_get_modifier_mapping_cookie_t.ByValue cookie, PointerByReference e);
	/**
	 * Return the reply<br>
	 * @param c      The connection<br>
	 * @param cookie The cookie<br>
	 * @param e      The xcb_generic_error_t supplied<br>
	 * Returns the reply of the request asked by<br>
	 * The parameter @p e supplied to this function must be NULL if<br>
	 * xcb_get_modifier_mapping_unchecked(). is used.<br>
	 * Otherwise, it stores the error if any.<br>
	 * The returned value must be freed by the caller using free().<br>
	 * Original signature : <code>xcb_get_modifier_mapping_reply_t* xcb_get_modifier_mapping_reply(xcb_connection_t*, xcb_get_modifier_mapping_cookie_t, xcb_generic_error_t**)</code><br>
	 * @param c <<br>
	 * @param cookie <<br>
	 * @param e <<br>
	 * <i>native declaration : xcb/xproto.h:9726</i>
	 */
	xcb_get_modifier_mapping_reply_t xcb_get_modifier_mapping_reply(PointerByReference c, xcb.xcb_get_modifier_mapping_cookie_t.ByValue cookie, xcb_generic_error_t.ByReference e[]);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_no_operation_checked(xcb_connection_t*)</code><br>
	 * @param c <<br>
	 * <i>native declaration : xcb/xproto.h:9737</i><br>
	 * @deprecated use the safer method {@link #xcb_no_operation_checked(com.sun.jna.ptr.PointerByReference)} instead
	 */
	@Deprecated 
	xcb.xcb_void_cookie_t.ByValue xcb_no_operation_checked(Pointer c);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_no_operation_checked(xcb_connection_t*)</code><br>
	 * @param c <<br>
	 * <i>native declaration : xcb/xproto.h:9737</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_no_operation_checked(PointerByReference c);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_no_operation(xcb_connection_t*)</code><br>
	 * @param c <<br>
	 * <i>native declaration : xcb/xproto.h:9745</i><br>
	 * @deprecated use the safer method {@link #xcb_no_operation(com.sun.jna.ptr.PointerByReference)} instead
	 */
	@Deprecated 
	xcb.xcb_void_cookie_t.ByValue xcb_no_operation(Pointer c);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_no_operation(xcb_connection_t*)</code><br>
	 * @param c <<br>
	 * <i>native declaration : xcb/xproto.h:9745</i>
	 */
	xcb.xcb_void_cookie_t.ByValue xcb_no_operation(PointerByReference c);
	/**
	 * @brief Forces any buffered output to be written to the server.<br>
	 * @param c: The connection to the X server.<br>
	 * @return > @c 0 on success, <= @c 0 otherwise.<br>
	 * Forces any buffered output to be written to the server. Blocks<br>
	 * until the write is complete.<br>
	 * Original signature : <code>int xcb_flush(xcb_connection_t*)</code><br>
	 * <i>native declaration : xcb/xcb.h:18</i><br>
	 * @deprecated use the safer method {@link #xcb_flush(com.sun.jna.ptr.PointerByReference)} instead
	 */
	@Deprecated 
	int xcb_flush(Pointer c);
	/**
	 * @brief Forces any buffered output to be written to the server.<br>
	 * @param c: The connection to the X server.<br>
	 * @return > @c 0 on success, <= @c 0 otherwise.<br>
	 * Forces any buffered output to be written to the server. Blocks<br>
	 * until the write is complete.<br>
	 * Original signature : <code>int xcb_flush(xcb_connection_t*)</code><br>
	 * <i>native declaration : xcb/xcb.h:18</i>
	 */
	int xcb_flush(PointerByReference c);
	/**
	 * @brief Returns the maximum request length that this server accepts.<br>
	 * @param c: The connection to the X server.<br>
	 * @return The maximum request length field.<br>
	 * In the absence of the BIG-REQUESTS extension, returns the<br>
	 * maximum request length field from the connection setup data, which<br>
	 * may be as much as 65535. If the server supports BIG-REQUESTS, then<br>
	 * the maximum request length field from the reply to the<br>
	 * BigRequestsEnable request will be returned instead.<br>
	 * Note that this length is measured in four-byte units, making the<br>
	 * theoretical maximum lengths roughly 256kB without BIG-REQUESTS and<br>
	 * 16GB with.<br>
	 * Original signature : <code>uint32_t xcb_get_maximum_request_length(xcb_connection_t*)</code><br>
	 * <i>native declaration : xcb/xcb.h:33</i><br>
	 * @deprecated use the safer method {@link #xcb_get_maximum_request_length(com.sun.jna.ptr.PointerByReference)} instead
	 */
	@Deprecated 
	int xcb_get_maximum_request_length(Pointer c);
	/**
	 * @brief Returns the maximum request length that this server accepts.<br>
	 * @param c: The connection to the X server.<br>
	 * @return The maximum request length field.<br>
	 * In the absence of the BIG-REQUESTS extension, returns the<br>
	 * maximum request length field from the connection setup data, which<br>
	 * may be as much as 65535. If the server supports BIG-REQUESTS, then<br>
	 * the maximum request length field from the reply to the<br>
	 * BigRequestsEnable request will be returned instead.<br>
	 * Note that this length is measured in four-byte units, making the<br>
	 * theoretical maximum lengths roughly 256kB without BIG-REQUESTS and<br>
	 * 16GB with.<br>
	 * Original signature : <code>uint32_t xcb_get_maximum_request_length(xcb_connection_t*)</code><br>
	 * <i>native declaration : xcb/xcb.h:33</i>
	 */
	int xcb_get_maximum_request_length(PointerByReference c);
	/**
	 * @brief Prefetch the maximum request length without blocking.<br>
	 * @param c: The connection to the X server.<br>
	 * Without blocking, does as much work as possible toward computing<br>
	 * the maximum request length accepted by the X server.<br>
	 * Invoking this function may cause a call to xcb_big_requests_enable,<br>
	 * but will not block waiting for the reply.<br>
	 * xcb_get_maximum_request_length will return the prefetched data<br>
	 * after possibly blocking while the reply is retrieved.<br>
	 * Note that in order for this function to be fully non-blocking, the<br>
	 * application must previously have called<br>
	 * xcb_prefetch_extension_data(c, &xcb_big_requests_id) and the reply<br>
	 * must have already arrived.<br>
	 * Original signature : <code>void xcb_prefetch_maximum_request_length(xcb_connection_t*)</code><br>
	 * <i>native declaration : xcb/xcb.h:49</i><br>
	 * @deprecated use the safer method {@link #xcb_prefetch_maximum_request_length(com.sun.jna.ptr.PointerByReference)} instead
	 */
	@Deprecated 
	void xcb_prefetch_maximum_request_length(Pointer c);
	/**
	 * @brief Prefetch the maximum request length without blocking.<br>
	 * @param c: The connection to the X server.<br>
	 * Without blocking, does as much work as possible toward computing<br>
	 * the maximum request length accepted by the X server.<br>
	 * Invoking this function may cause a call to xcb_big_requests_enable,<br>
	 * but will not block waiting for the reply.<br>
	 * xcb_get_maximum_request_length will return the prefetched data<br>
	 * after possibly blocking while the reply is retrieved.<br>
	 * Note that in order for this function to be fully non-blocking, the<br>
	 * application must previously have called<br>
	 * xcb_prefetch_extension_data(c, &xcb_big_requests_id) and the reply<br>
	 * must have already arrived.<br>
	 * Original signature : <code>void xcb_prefetch_maximum_request_length(xcb_connection_t*)</code><br>
	 * <i>native declaration : xcb/xcb.h:49</i>
	 */
	void xcb_prefetch_maximum_request_length(PointerByReference c);
	/**
	 * @brief Returns the next event or error from the server.<br>
	 * @param c: The connection to the X server.<br>
	 * @return The next event from the server.<br>
	 * Returns the next event or error from the server, or returns null in<br>
	 * the event of an I/O error. Blocks until either an event or error<br>
	 * arrive, or an I/O error occurs.<br>
	 * Original signature : <code>xcb_generic_event_t* xcb_wait_for_event(xcb_connection_t*)</code><br>
	 * <i>native declaration : xcb/xcb.h:59</i><br>
	 * @deprecated use the safer method {@link #xcb_wait_for_event(com.sun.jna.ptr.PointerByReference)} instead
	 */
	@Deprecated 
	xcb_generic_event_t xcb_wait_for_event(Pointer c);
	/**
	 * @brief Returns the next event or error from the server.<br>
	 * @param c: The connection to the X server.<br>
	 * @return The next event from the server.<br>
	 * Returns the next event or error from the server, or returns null in<br>
	 * the event of an I/O error. Blocks until either an event or error<br>
	 * arrive, or an I/O error occurs.<br>
	 * Original signature : <code>xcb_generic_event_t* xcb_wait_for_event(xcb_connection_t*)</code><br>
	 * <i>native declaration : xcb/xcb.h:59</i>
	 */
	xcb_generic_event_t xcb_wait_for_event(PointerByReference c);
	/**
	 * @brief Returns the next event or error from the server.<br>
	 * @param c: The connection to the X server.<br>
	 * @return The next event from the server.<br>
	 * Returns the next event or error from the server, if one is<br>
	 * available, or returns @c NULL otherwise. If no event is available, that<br>
	 * might be because an I/O error like connection close occurred while<br>
	 * attempting to read the next event, in which case the connection is<br>
	 * shut down when this function returns.<br>
	 * Original signature : <code>xcb_generic_event_t* xcb_poll_for_event(xcb_connection_t*)</code><br>
	 * <i>native declaration : xcb/xcb.h:71</i><br>
	 * @deprecated use the safer method {@link #xcb_poll_for_event(com.sun.jna.ptr.PointerByReference)} instead
	 */
	@Deprecated 
	xcb_generic_event_t xcb_poll_for_event(Pointer c);
	/**
	 * @brief Returns the next event or error from the server.<br>
	 * @param c: The connection to the X server.<br>
	 * @return The next event from the server.<br>
	 * Returns the next event or error from the server, if one is<br>
	 * available, or returns @c NULL otherwise. If no event is available, that<br>
	 * might be because an I/O error like connection close occurred while<br>
	 * attempting to read the next event, in which case the connection is<br>
	 * shut down when this function returns.<br>
	 * Original signature : <code>xcb_generic_event_t* xcb_poll_for_event(xcb_connection_t*)</code><br>
	 * <i>native declaration : xcb/xcb.h:71</i>
	 */
	xcb_generic_event_t xcb_poll_for_event(PointerByReference c);
	/**
	 * @brief Returns the next event without reading from the connection.<br>
	 * @param c: The connection to the X server.<br>
	 * @return The next already queued event from the server.<br>
	 * This is a version of xcb_poll_for_event that only examines the<br>
	 * event queue for new events. The function doesn't try to read new<br>
	 * events from the connection if no queued events are found.<br>
	 * This function is useful for callers that know in advance that all<br>
	 * interesting events have already been read from the connection. For<br>
	 * example, callers might use xcb_wait_for_reply and be interested<br>
	 * only of events that preceded a specific reply.<br>
	 * Original signature : <code>xcb_generic_event_t* xcb_poll_for_queued_event(xcb_connection_t*)</code><br>
	 * <i>native declaration : xcb/xcb.h:85</i><br>
	 * @deprecated use the safer method {@link #xcb_poll_for_queued_event(com.sun.jna.ptr.PointerByReference)} instead
	 */
	@Deprecated 
	xcb_generic_event_t xcb_poll_for_queued_event(Pointer c);
	/**
	 * @brief Returns the next event without reading from the connection.<br>
	 * @param c: The connection to the X server.<br>
	 * @return The next already queued event from the server.<br>
	 * This is a version of xcb_poll_for_event that only examines the<br>
	 * event queue for new events. The function doesn't try to read new<br>
	 * events from the connection if no queued events are found.<br>
	 * This function is useful for callers that know in advance that all<br>
	 * interesting events have already been read from the connection. For<br>
	 * example, callers might use xcb_wait_for_reply and be interested<br>
	 * only of events that preceded a specific reply.<br>
	 * Original signature : <code>xcb_generic_event_t* xcb_poll_for_queued_event(xcb_connection_t*)</code><br>
	 * <i>native declaration : xcb/xcb.h:85</i>
	 */
	xcb_generic_event_t xcb_poll_for_queued_event(PointerByReference c);
	/**
	 * @brief Returns the next event from a special queue<br>
	 * Original signature : <code>xcb_generic_event_t* xcb_poll_for_special_event(xcb_connection_t*, xcb_special_event_t*)</code><br>
	 * <i>native declaration : xcb/xcb.h:91</i><br>
	 * @deprecated use the safer method {@link #xcb_poll_for_special_event(com.sun.jna.ptr.PointerByReference, com.sun.jna.ptr.PointerByReference)} instead
	 */
	@Deprecated 
	xcb_generic_event_t xcb_poll_for_special_event(Pointer c, Pointer se);
	/**
	 * @brief Returns the next event from a special queue<br>
	 * Original signature : <code>xcb_generic_event_t* xcb_poll_for_special_event(xcb_connection_t*, xcb_special_event_t*)</code><br>
	 * <i>native declaration : xcb/xcb.h:91</i>
	 */
	xcb_generic_event_t xcb_poll_for_special_event(PointerByReference c, PointerByReference se);
	/**
	 * @brief Returns the next event from a special queue, blocking until one arrives<br>
	 * Original signature : <code>xcb_generic_event_t* xcb_wait_for_special_event(xcb_connection_t*, xcb_special_event_t*)</code><br>
	 * <i>native declaration : xcb/xcb.h:96</i><br>
	 * @deprecated use the safer method {@link #xcb_wait_for_special_event(com.sun.jna.ptr.PointerByReference, com.sun.jna.ptr.PointerByReference)} instead
	 */
	@Deprecated 
	xcb_generic_event_t xcb_wait_for_special_event(Pointer c, Pointer se);
	/**
	 * @brief Returns the next event from a special queue, blocking until one arrives<br>
	 * Original signature : <code>xcb_generic_event_t* xcb_wait_for_special_event(xcb_connection_t*, xcb_special_event_t*)</code><br>
	 * <i>native declaration : xcb/xcb.h:96</i>
	 */
	xcb_generic_event_t xcb_wait_for_special_event(PointerByReference c, PointerByReference se);
	/**
	 * @brief Listen for a special event<br>
	 * Original signature : <code>xcb_special_event_t* xcb_register_for_special_xge(xcb_connection_t*, xcb_extension_t*, uint32_t, uint32_t*)</code><br>
	 * <i>native declaration : xcb/xcb.h:103</i><br>
	 * @deprecated use the safer methods {@link #xcb_register_for_special_xge(com.sun.jna.ptr.PointerByReference, com.sun.jna.ptr.PointerByReference, int, java.nio.IntBuffer)} and {@link #xcb_register_for_special_xge(com.sun.jna.ptr.PointerByReference, com.sun.jna.ptr.PointerByReference, int, com.sun.jna.ptr.IntByReference)} instead
	 */
	@Deprecated 
	PointerByReference xcb_register_for_special_xge(Pointer c, Pointer ext, int eid, IntByReference stamp);
	/**
	 * @brief Listen for a special event<br>
	 * Original signature : <code>xcb_special_event_t* xcb_register_for_special_xge(xcb_connection_t*, xcb_extension_t*, uint32_t, uint32_t*)</code><br>
	 * <i>native declaration : xcb/xcb.h:103</i>
	 */
	PointerByReference xcb_register_for_special_xge(PointerByReference c, PointerByReference ext, int eid, IntBuffer stamp);
	/**
	 * @brief Listen for a special event<br>
	 * Original signature : <code>xcb_special_event_t* xcb_register_for_special_xge(xcb_connection_t*, xcb_extension_t*, uint32_t, uint32_t*)</code><br>
	 * <i>native declaration : xcb/xcb.h:103</i>
	 */
	PointerByReference xcb_register_for_special_xge(PointerByReference c, PointerByReference ext, int eid, IntByReference stamp);
	/**
	 * @brief Stop listening for a special event<br>
	 * Original signature : <code>void xcb_unregister_for_special_event(xcb_connection_t*, xcb_special_event_t*)</code><br>
	 * <i>native declaration : xcb/xcb.h:108</i><br>
	 * @deprecated use the safer method {@link #xcb_unregister_for_special_event(com.sun.jna.ptr.PointerByReference, com.sun.jna.ptr.PointerByReference)} instead
	 */
	@Deprecated 
	void xcb_unregister_for_special_event(Pointer c, Pointer se);
	/**
	 * @brief Stop listening for a special event<br>
	 * Original signature : <code>void xcb_unregister_for_special_event(xcb_connection_t*, xcb_special_event_t*)</code><br>
	 * <i>native declaration : xcb/xcb.h:108</i>
	 */
	void xcb_unregister_for_special_event(PointerByReference c, PointerByReference se);
	/**
	 * @brief Return the error for a request, or NULL if none can ever arrive.<br>
	 * @param c: The connection to the X server.<br>
	 * @param cookie: The request cookie.<br>
	 * @return The error for the request, or NULL if none can ever arrive.<br>
	 * The xcb_void_cookie_t cookie supplied to this function must have resulted<br>
	 * from a call to xcb_[request_name]_checked().  This function will block<br>
	 * until one of two conditions happens.  If an error is received, it will be<br>
	 * returned.  If a reply to a subsequent request has already arrived, no error<br>
	 * can arrive for this request, so this function will return NULL.<br>
	 * Note that this function will perform a sync if needed to ensure that the<br>
	 * sequence number will advance beyond that provided in cookie; this is a<br>
	 * convenience to avoid races in determining whether the sync is needed.<br>
	 * Original signature : <code>xcb_generic_error_t* xcb_request_check(xcb_connection_t*, xcb_void_cookie_t)</code><br>
	 * <i>native declaration : xcb/xcb.h:124</i><br>
	 * @deprecated use the safer method {@link #xcb_request_check(com.sun.jna.ptr.PointerByReference, xcb.xcb_void_cookie_t.ByValue)} instead
	 */
	@Deprecated 
	xcb_generic_error_t xcb_request_check(Pointer c, xcb.xcb_void_cookie_t.ByValue cookie);
	/**
	 * @brief Return the error for a request, or NULL if none can ever arrive.<br>
	 * @param c: The connection to the X server.<br>
	 * @param cookie: The request cookie.<br>
	 * @return The error for the request, or NULL if none can ever arrive.<br>
	 * The xcb_void_cookie_t cookie supplied to this function must have resulted<br>
	 * from a call to xcb_[request_name]_checked().  This function will block<br>
	 * until one of two conditions happens.  If an error is received, it will be<br>
	 * returned.  If a reply to a subsequent request has already arrived, no error<br>
	 * can arrive for this request, so this function will return NULL.<br>
	 * Note that this function will perform a sync if needed to ensure that the<br>
	 * sequence number will advance beyond that provided in cookie; this is a<br>
	 * convenience to avoid races in determining whether the sync is needed.<br>
	 * Original signature : <code>xcb_generic_error_t* xcb_request_check(xcb_connection_t*, xcb_void_cookie_t)</code><br>
	 * <i>native declaration : xcb/xcb.h:124</i>
	 */
	xcb_generic_error_t xcb_request_check(PointerByReference c, xcb.xcb_void_cookie_t.ByValue cookie);
	/**
	 * @brief Discards the reply for a request.<br>
	 * @param c: The connection to the X server.<br>
	 * @param sequence: The request sequence number from a cookie.<br>
	 * Discards the reply for a request. Additionally, any error generated<br>
	 * by the request is also discarded (unless it was an _unchecked request<br>
	 * and the error has already arrived).<br>
	 * This function will not block even if the reply is not yet available.<br>
	 * Note that the sequence really does have to come from an xcb cookie;<br>
	 * this function is not designed to operate on socket-handoff replies.<br>
	 * Original signature : <code>void xcb_discard_reply(xcb_connection_t*, unsigned int)</code><br>
	 * <i>native declaration : xcb/xcb.h:137</i><br>
	 * @deprecated use the safer method {@link #xcb_discard_reply(com.sun.jna.ptr.PointerByReference, int)} instead
	 */
	@Deprecated 
	void xcb_discard_reply(Pointer c, int sequence);
	/**
	 * @brief Discards the reply for a request.<br>
	 * @param c: The connection to the X server.<br>
	 * @param sequence: The request sequence number from a cookie.<br>
	 * Discards the reply for a request. Additionally, any error generated<br>
	 * by the request is also discarded (unless it was an _unchecked request<br>
	 * and the error has already arrived).<br>
	 * This function will not block even if the reply is not yet available.<br>
	 * Note that the sequence really does have to come from an xcb cookie;<br>
	 * this function is not designed to operate on socket-handoff replies.<br>
	 * Original signature : <code>void xcb_discard_reply(xcb_connection_t*, unsigned int)</code><br>
	 * <i>native declaration : xcb/xcb.h:137</i>
	 */
	void xcb_discard_reply(PointerByReference c, int sequence);
	/**
	 * @brief Caches reply information from QueryExtension requests.<br>
	 * @param c: The connection.<br>
	 * @param ext: The extension data.<br>
	 * @return A pointer to the xcb_query_extension_reply_t for the extension.<br>
	 * This function is the primary interface to the "extension cache",<br>
	 * which caches reply information from QueryExtension<br>
	 * requests. Invoking this function may cause a call to<br>
	 * xcb_query_extension to retrieve extension information from the<br>
	 * server, and may block until extension data is received from the<br>
	 * server.<br>
	 * The result must not be freed. This storage is managed by the cache<br>
	 * itself.<br>
	 * Original signature : <code>xcb_query_extension_reply_t* xcb_get_extension_data(xcb_connection_t*, xcb_extension_t*)</code><br>
	 * <i>native declaration : xcb/xcb.h:153</i><br>
	 * @deprecated use the safer method {@link #xcb_get_extension_data(com.sun.jna.ptr.PointerByReference, com.sun.jna.ptr.PointerByReference)} instead
	 */
	@Deprecated 
	xcb_query_extension_reply_t xcb_get_extension_data(Pointer c, Pointer ext);
	/**
	 * @brief Caches reply information from QueryExtension requests.<br>
	 * @param c: The connection.<br>
	 * @param ext: The extension data.<br>
	 * @return A pointer to the xcb_query_extension_reply_t for the extension.<br>
	 * This function is the primary interface to the "extension cache",<br>
	 * which caches reply information from QueryExtension<br>
	 * requests. Invoking this function may cause a call to<br>
	 * xcb_query_extension to retrieve extension information from the<br>
	 * server, and may block until extension data is received from the<br>
	 * server.<br>
	 * The result must not be freed. This storage is managed by the cache<br>
	 * itself.<br>
	 * Original signature : <code>xcb_query_extension_reply_t* xcb_get_extension_data(xcb_connection_t*, xcb_extension_t*)</code><br>
	 * <i>native declaration : xcb/xcb.h:153</i>
	 */
	xcb_query_extension_reply_t xcb_get_extension_data(PointerByReference c, PointerByReference ext);
	/**
	 * @brief Prefetch of extension data into the extension cache<br>
	 * @param c: The connection.<br>
	 * @param ext: The extension data.<br>
	 * This function allows a "prefetch" of extension data into the<br>
	 * extension cache. Invoking the function may cause a call to<br>
	 * xcb_query_extension, but will not block waiting for the<br>
	 * reply. xcb_get_extension_data will return the prefetched data after<br>
	 * possibly blocking while it is retrieved.<br>
	 * Original signature : <code>void xcb_prefetch_extension_data(xcb_connection_t*, xcb_extension_t*)</code><br>
	 * <i>native declaration : xcb/xcb.h:165</i><br>
	 * @deprecated use the safer method {@link #xcb_prefetch_extension_data(com.sun.jna.ptr.PointerByReference, com.sun.jna.ptr.PointerByReference)} instead
	 */
	@Deprecated 
	void xcb_prefetch_extension_data(Pointer c, Pointer ext);
	/**
	 * @brief Prefetch of extension data into the extension cache<br>
	 * @param c: The connection.<br>
	 * @param ext: The extension data.<br>
	 * This function allows a "prefetch" of extension data into the<br>
	 * extension cache. Invoking the function may cause a call to<br>
	 * xcb_query_extension, but will not block waiting for the<br>
	 * reply. xcb_get_extension_data will return the prefetched data after<br>
	 * possibly blocking while it is retrieved.<br>
	 * Original signature : <code>void xcb_prefetch_extension_data(xcb_connection_t*, xcb_extension_t*)</code><br>
	 * <i>native declaration : xcb/xcb.h:165</i>
	 */
	void xcb_prefetch_extension_data(PointerByReference c, PointerByReference ext);
	/**
	 * @brief Access the data returned by the server.<br>
	 * @param c: The connection.<br>
	 * @return A pointer to an xcb_setup_t structure.<br>
	 * Accessor for the data returned by the server when the xcb_connection_t<br>
	 * was initialized. This data includes<br>
	 * - the server's required format for images,<br>
	 * - a list of available visuals,<br>
	 * - a list of available screens,<br>
	 * - the server's maximum request length (in the absence of the<br>
	 * BIG-REQUESTS extension),<br>
	 * - and other assorted information.<br>
	 * See the X protocol specification for more details.<br>
	 * The result must not be freed.<br>
	 * Original signature : <code>xcb_setup_t* xcb_get_setup(xcb_connection_t*)</code><br>
	 * <i>native declaration : xcb/xcb.h:182</i><br>
	 * @deprecated use the safer method {@link #xcb_get_setup(com.sun.jna.ptr.PointerByReference)} instead
	 */
	@Deprecated 
	xcb_setup_t xcb_get_setup(Pointer c);
	/**
	 * @brief Access the data returned by the server.<br>
	 * @param c: The connection.<br>
	 * @return A pointer to an xcb_setup_t structure.<br>
	 * Accessor for the data returned by the server when the xcb_connection_t<br>
	 * was initialized. This data includes<br>
	 * - the server's required format for images,<br>
	 * - a list of available visuals,<br>
	 * - a list of available screens,<br>
	 * - the server's maximum request length (in the absence of the<br>
	 * BIG-REQUESTS extension),<br>
	 * - and other assorted information.<br>
	 * See the X protocol specification for more details.<br>
	 * The result must not be freed.<br>
	 * Original signature : <code>xcb_setup_t* xcb_get_setup(xcb_connection_t*)</code><br>
	 * <i>native declaration : xcb/xcb.h:182</i>
	 */
	xcb_setup_t xcb_get_setup(PointerByReference c);
	/**
	 * @brief Access the file descriptor of the connection.<br>
	 * @param c: The connection.<br>
	 * @return The file descriptor.<br>
	 * Accessor for the file descriptor that was passed to the<br>
	 * xcb_connect_to_fd call that returned @p c.<br>
	 * Original signature : <code>int xcb_get_file_descriptor(xcb_connection_t*)</code><br>
	 * <i>native declaration : xcb/xcb.h:191</i><br>
	 * @deprecated use the safer method {@link #xcb_get_file_descriptor(com.sun.jna.ptr.PointerByReference)} instead
	 */
	@Deprecated 
	int xcb_get_file_descriptor(Pointer c);
	/**
	 * @brief Access the file descriptor of the connection.<br>
	 * @param c: The connection.<br>
	 * @return The file descriptor.<br>
	 * Accessor for the file descriptor that was passed to the<br>
	 * xcb_connect_to_fd call that returned @p c.<br>
	 * Original signature : <code>int xcb_get_file_descriptor(xcb_connection_t*)</code><br>
	 * <i>native declaration : xcb/xcb.h:191</i>
	 */
	int xcb_get_file_descriptor(PointerByReference c);
	/**
	 * @brief Test whether the connection has shut down due to a fatal error.<br>
	 * @param c: The connection.<br>
	 * @return > 0 if the connection is in an error state; 0 otherwise.<br>
	 * Some errors that occur in the context of an xcb_connection_t<br>
	 * are unrecoverable. When such an error occurs, the<br>
	 * connection is shut down and further operations on the<br>
	 * xcb_connection_t have no effect, but memory will not be freed until<br>
	 * xcb_disconnect() is called on the xcb_connection_t.<br>
	 * @return XCB_CONN_ERROR, because of socket errors, pipe errors or other stream errors.<br>
	 * @return XCB_CONN_CLOSED_EXT_NOTSUPPORTED, when extension not supported.<br>
	 * @return XCB_CONN_CLOSED_MEM_INSUFFICIENT, when memory not available.<br>
	 * @return XCB_CONN_CLOSED_REQ_LEN_EXCEED, exceeding request length that server accepts.<br>
	 * @return XCB_CONN_CLOSED_PARSE_ERR, error during parsing display string.<br>
	 * @return XCB_CONN_CLOSED_INVALID_SCREEN, because the server does not have a screen matching the display.<br>
	 * Original signature : <code>int xcb_connection_has_error(xcb_connection_t*)</code><br>
	 * <i>native declaration : xcb/xcb.h:209</i><br>
	 * @deprecated use the safer method {@link #xcb_connection_has_error(com.sun.jna.ptr.PointerByReference)} instead
	 */
	@Deprecated 
	int xcb_connection_has_error(Pointer c);
	/**
	 * @brief Test whether the connection has shut down due to a fatal error.<br>
	 * @param c: The connection.<br>
	 * @return > 0 if the connection is in an error state; 0 otherwise.<br>
	 * Some errors that occur in the context of an xcb_connection_t<br>
	 * are unrecoverable. When such an error occurs, the<br>
	 * connection is shut down and further operations on the<br>
	 * xcb_connection_t have no effect, but memory will not be freed until<br>
	 * xcb_disconnect() is called on the xcb_connection_t.<br>
	 * @return XCB_CONN_ERROR, because of socket errors, pipe errors or other stream errors.<br>
	 * @return XCB_CONN_CLOSED_EXT_NOTSUPPORTED, when extension not supported.<br>
	 * @return XCB_CONN_CLOSED_MEM_INSUFFICIENT, when memory not available.<br>
	 * @return XCB_CONN_CLOSED_REQ_LEN_EXCEED, exceeding request length that server accepts.<br>
	 * @return XCB_CONN_CLOSED_PARSE_ERR, error during parsing display string.<br>
	 * @return XCB_CONN_CLOSED_INVALID_SCREEN, because the server does not have a screen matching the display.<br>
	 * Original signature : <code>int xcb_connection_has_error(xcb_connection_t*)</code><br>
	 * <i>native declaration : xcb/xcb.h:209</i>
	 */
	int xcb_connection_has_error(PointerByReference c);
	/**
	 * @brief Connects to the X server.<br>
	 * @param fd: The file descriptor.<br>
	 * @param auth_info: Authentication data.<br>
	 * @return A newly allocated xcb_connection_t structure.<br>
	 * Connects to an X server, given the open socket @p fd and the<br>
	 * xcb_auth_info_t @p auth_info. The file descriptor @p fd is<br>
	 * bidirectionally connected to an X server. If the connection<br>
	 * should be unauthenticated, @p auth_info must be @c<br>
	 * NULL.<br>
	 * Always returns a non-NULL pointer to a xcb_connection_t, even on failure.<br>
	 * Callers need to use xcb_connection_has_error() to check for failure.<br>
	 * When finished, use xcb_disconnect() to close the connection and free<br>
	 * the structure.<br>
	 * Original signature : <code>xcb_connection_t* xcb_connect_to_fd(int, xcb_auth_info_t*)</code><br>
	 * <i>native declaration : xcb/xcb.h:226</i>
	 */
	PointerByReference xcb_connect_to_fd(int fd, xcb_auth_info_t auth_info);
	/**
	 * @brief Closes the connection.<br>
	 * @param c: The connection.<br>
	 * Closes the file descriptor and frees all memory associated with the<br>
	 * connection @c c. If @p c is @c NULL, nothing is done.<br>
	 * Original signature : <code>void xcb_disconnect(xcb_connection_t*)</code><br>
	 * <i>native declaration : xcb/xcb.h:234</i><br>
	 * @deprecated use the safer method {@link #xcb_disconnect(com.sun.jna.ptr.PointerByReference)} instead
	 */
	@Deprecated 
	void xcb_disconnect(Pointer c);
	/**
	 * @brief Closes the connection.<br>
	 * @param c: The connection.<br>
	 * Closes the file descriptor and frees all memory associated with the<br>
	 * connection @c c. If @p c is @c NULL, nothing is done.<br>
	 * Original signature : <code>void xcb_disconnect(xcb_connection_t*)</code><br>
	 * <i>native declaration : xcb/xcb.h:234</i>
	 */
	void xcb_disconnect(PointerByReference c);
	/**
	 * @brief Parses a display string name in the form documented by X(7x).<br>
	 * @param name: The name of the display.<br>
	 * @param host: A pointer to a malloc'd copy of the hostname.<br>
	 * @param display: A pointer to the display number.<br>
	 * @param screen: A pointer to the screen number.<br>
	 * @return 0 on failure, non 0 otherwise.<br>
	 * Parses the display string name @p display_name in the form<br>
	 * documented by X(7x). Has no side effects on failure. If<br>
	 * @p displayname is @c NULL or empty, it uses the environment<br>
	 * variable DISPLAY. @p hostp is a pointer to a newly allocated string<br>
	 * that contain the host name. @p displayp is set to the display<br>
	 * number and @p screenp to the preferred screen number. @p screenp<br>
	 * can be @c NULL. If @p displayname does not contain a screen number,<br>
	 * it is set to @c 0.<br>
	 * Original signature : <code>int xcb_parse_display(const char*, char**, int*, int*)</code><br>
	 * <i>native declaration : xcb/xcb.h:252</i><br>
	 * @deprecated use the safer methods {@link #xcb_parse_display(java.lang.String, com.sun.jna.ptr.PointerByReference, java.nio.IntBuffer, java.nio.IntBuffer)} and {@link #xcb_parse_display(com.sun.jna.Pointer, com.sun.jna.ptr.PointerByReference, com.sun.jna.ptr.IntByReference, com.sun.jna.ptr.IntByReference)} instead
	 */
	@Deprecated 
	int xcb_parse_display(Pointer name, PointerByReference host, IntByReference display, IntByReference screen);
	/**
	 * @brief Parses a display string name in the form documented by X(7x).<br>
	 * @param name: The name of the display.<br>
	 * @param host: A pointer to a malloc'd copy of the hostname.<br>
	 * @param display: A pointer to the display number.<br>
	 * @param screen: A pointer to the screen number.<br>
	 * @return 0 on failure, non 0 otherwise.<br>
	 * Parses the display string name @p display_name in the form<br>
	 * documented by X(7x). Has no side effects on failure. If<br>
	 * @p displayname is @c NULL or empty, it uses the environment<br>
	 * variable DISPLAY. @p hostp is a pointer to a newly allocated string<br>
	 * that contain the host name. @p displayp is set to the display<br>
	 * number and @p screenp to the preferred screen number. @p screenp<br>
	 * can be @c NULL. If @p displayname does not contain a screen number,<br>
	 * it is set to @c 0.<br>
	 * Original signature : <code>int xcb_parse_display(const char*, char**, int*, int*)</code><br>
	 * <i>native declaration : xcb/xcb.h:252</i>
	 */
	int xcb_parse_display(String name, PointerByReference host, IntBuffer display, IntBuffer screen);
	/**
	 * @brief Connects to the X server.<br>
	 * @param displayname: The name of the display.<br>
	 * @param screenp: A pointer to a preferred screen number.<br>
	 * @return A newly allocated xcb_connection_t structure.<br>
	 * Connects to the X server specified by @p displayname. If @p<br>
	 * displayname is @c NULL, uses the value of the DISPLAY environment<br>
	 * variable. If a particular screen on that server is preferred, the<br>
	 * int pointed to by @p screenp (if not @c NULL) will be set to that<br>
	 * screen; otherwise the screen will be set to 0.<br>
	 * Always returns a non-NULL pointer to a xcb_connection_t, even on failure.<br>
	 * Callers need to use xcb_connection_has_error() to check for failure.<br>
	 * When finished, use xcb_disconnect() to close the connection and free<br>
	 * the structure.<br>
	 * Original signature : <code>xcb_connection_t* xcb_connect(const char*, int*)</code><br>
	 * <i>native declaration : xcb/xcb.h:269</i><br>
	 * @deprecated use the safer methods {@link #xcb_connect(java.lang.String, java.nio.IntBuffer)} and {@link #xcb_connect(com.sun.jna.Pointer, com.sun.jna.ptr.IntByReference)} instead
	 */
	@Deprecated 
	PointerByReference xcb_connect(Pointer displayname, IntByReference screenp);
	/**
	 * @brief Connects to the X server.<br>
	 * @param displayname: The name of the display.<br>
	 * @param screenp: A pointer to a preferred screen number.<br>
	 * @return A newly allocated xcb_connection_t structure.<br>
	 * Connects to the X server specified by @p displayname. If @p<br>
	 * displayname is @c NULL, uses the value of the DISPLAY environment<br>
	 * variable. If a particular screen on that server is preferred, the<br>
	 * int pointed to by @p screenp (if not @c NULL) will be set to that<br>
	 * screen; otherwise the screen will be set to 0.<br>
	 * Always returns a non-NULL pointer to a xcb_connection_t, even on failure.<br>
	 * Callers need to use xcb_connection_has_error() to check for failure.<br>
	 * When finished, use xcb_disconnect() to close the connection and free<br>
	 * the structure.<br>
	 * Original signature : <code>xcb_connection_t* xcb_connect(const char*, int*)</code><br>
	 * <i>native declaration : xcb/xcb.h:269</i>
	 */
	PointerByReference xcb_connect(String displayname, IntBuffer screenp);
	/**
	 * @brief Connects to the X server, using an authorization information.<br>
	 * @param display: The name of the display.<br>
	 * @param auth: The authorization information.<br>
	 * @param screen: A pointer to a preferred screen number.<br>
	 * @return A newly allocated xcb_connection_t structure.<br>
	 * Connects to the X server specified by @p displayname, using the<br>
	 * authorization @p auth. If a particular screen on that server is<br>
	 * preferred, the int pointed to by @p screenp (if not @c NULL) will<br>
	 * be set to that screen; otherwise @p screenp will be set to 0.<br>
	 * Always returns a non-NULL pointer to a xcb_connection_t, even on failure.<br>
	 * Callers need to use xcb_connection_has_error() to check for failure.<br>
	 * When finished, use xcb_disconnect() to close the connection and free<br>
	 * the structure.<br>
	 * Original signature : <code>xcb_connection_t* xcb_connect_to_display_with_auth_info(const char*, xcb_auth_info_t*, int*)</code><br>
	 * <i>native declaration : xcb/xcb.h:286</i><br>
	 * @deprecated use the safer methods {@link #xcb_connect_to_display_with_auth_info(java.lang.String, xcb.xcb_auth_info_t, java.nio.IntBuffer)} and {@link #xcb_connect_to_display_with_auth_info(com.sun.jna.Pointer, xcb.xcb_auth_info_t, com.sun.jna.ptr.IntByReference)} instead
	 */
	@Deprecated 
	PointerByReference xcb_connect_to_display_with_auth_info(Pointer display, xcb_auth_info_t auth, IntByReference screen);
	/**
	 * @brief Connects to the X server, using an authorization information.<br>
	 * @param display: The name of the display.<br>
	 * @param auth: The authorization information.<br>
	 * @param screen: A pointer to a preferred screen number.<br>
	 * @return A newly allocated xcb_connection_t structure.<br>
	 * Connects to the X server specified by @p displayname, using the<br>
	 * authorization @p auth. If a particular screen on that server is<br>
	 * preferred, the int pointed to by @p screenp (if not @c NULL) will<br>
	 * be set to that screen; otherwise @p screenp will be set to 0.<br>
	 * Always returns a non-NULL pointer to a xcb_connection_t, even on failure.<br>
	 * Callers need to use xcb_connection_has_error() to check for failure.<br>
	 * When finished, use xcb_disconnect() to close the connection and free<br>
	 * the structure.<br>
	 * Original signature : <code>xcb_connection_t* xcb_connect_to_display_with_auth_info(const char*, xcb_auth_info_t*, int*)</code><br>
	 * <i>native declaration : xcb/xcb.h:286</i>
	 */
	PointerByReference xcb_connect_to_display_with_auth_info(String display, xcb_auth_info_t auth, IntBuffer screen);
	/**
	 * @brief Allocates an XID for a new object.<br>
	 * @param c: The connection.<br>
	 * @return A newly allocated XID.<br>
	 * Allocates an XID for a new object. Typically used just prior to<br>
	 * various object creation functions, such as xcb_create_window.<br>
	 * Original signature : <code>uint32_t xcb_generate_id(xcb_connection_t*)</code><br>
	 * <i>native declaration : xcb/xcb.h:295</i><br>
	 * @deprecated use the safer method {@link #xcb_generate_id(com.sun.jna.ptr.PointerByReference)} instead
	 */
	@Deprecated 
	int xcb_generate_id(Pointer c);
	/**
	 * @brief Allocates an XID for a new object.<br>
	 * @param c: The connection.<br>
	 * @return A newly allocated XID.<br>
	 * Allocates an XID for a new object. Typically used just prior to<br>
	 * various object creation functions, such as xcb_create_window.<br>
	 * Original signature : <code>uint32_t xcb_generate_id(xcb_connection_t*)</code><br>
	 * <i>native declaration : xcb/xcb.h:295</i>
	 */
	int xcb_generate_id(PointerByReference c);
	public static class xcb_special_event_t extends PointerType {
		public xcb_special_event_t(Pointer address) {
			super(address);
		}
		public xcb_special_event_t() {
			super();
		}
	};
	public static class xcb_extension_t extends PointerType {
		public xcb_extension_t(Pointer address) {
			super(address);
		}
		public xcb_extension_t() {
			super();
		}
	};
	public static class xcb_connection_t extends PointerType {
		public xcb_connection_t(Pointer address) {
			super(address);
		}
		public xcb_connection_t() {
			super();
		}
	};
}
